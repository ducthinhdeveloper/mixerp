-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/0.verbosity.sql --<--<--
SET CLIENT_MIN_MESSAGES TO WARNING;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/1.mixerp.sql --<--<--
/********************************************************************************
Copyright (C) Binod Nepal, Mix Open Foundation (http://mixof.org).

This file is part of MixERP.

MixERP is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MixERP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MixERP.  If not, see <http://www.gnu.org/licenses/>.
***********************************************************************************/
SET search_path = public;

DO 
$$
BEGIN   
    IF NOT EXISTS
    (
        SELECT * FROM pg_database 
        WHERE datcollate::text IN('C', 'POSIX')
        AND datctype::text IN('C', 'POSIX')
        AND datname=current_database()
    ) THEN
        RAISE EXCEPTION '%', 'The current server collation is not supported. Please change your database collation to "C" or "POSIX".';
    END IF;
    
    IF NOT EXISTS
    (
        SELECT 0 FROM pg_database 
        WHERE pg_encoding_to_char(encoding)::text = 'UTF8' 
        AND datname=current_database()
    ) THEN
        RAISE EXCEPTION '%', 'The current database encoding is not supported. Please change your encoding to "UTF8".';
    END IF;
    
   EXECUTE 'ALTER DATABASE ' || current_database() || ' SET timezone TO ''UTC''';    
END;
$$
LANGUAGE plpgsql;


CREATE EXTENSION IF NOT EXISTS tablefunc;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS hstore;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/1.scrud.sql --<--<--
DROP SCHEMA IF EXISTS scrud CASCADE;
CREATE SCHEMA scrud;

COMMENT ON SCHEMA scrud IS 'Contains objects related to MixERP''s ScrudFactory project.';


CREATE VIEW scrud.constraint_column_usage AS
    SELECT CAST(current_database() AS text) AS table_catalog,
           CAST(tblschema AS text) AS table_schema,
           CAST(tblname AS text) AS table_name,
           CAST(colname AS text) AS column_name,
           CAST(current_database() AS text) AS constraint_catalog,
           CAST(cstrschema AS text) AS constraint_schema,
           CAST(cstrname AS text) AS constraint_name

    FROM (
        /* check constraints */
        SELECT DISTINCT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
          FROM pg_namespace nr, pg_class r, pg_attribute a, pg_depend d, pg_namespace nc, pg_constraint c
          WHERE nr.oid = r.relnamespace
            AND r.oid = a.attrelid
            AND d.refclassid = 'pg_catalog.pg_class'::regclass
            AND d.refobjid = r.oid
            AND d.refobjsubid = a.attnum
            AND d.classid = 'pg_catalog.pg_constraint'::regclass
            AND d.objid = c.oid
            AND c.connamespace = nc.oid
            AND c.contype = 'c'
            AND r.relkind = 'r'
            AND NOT a.attisdropped

        UNION ALL

        /* unique/primary key/foreign key constraints */
        SELECT nr.nspname, r.relname, r.relowner, a.attname, nc.nspname, c.conname
          FROM pg_namespace nr, pg_class r, pg_attribute a, pg_namespace nc,
               pg_constraint c
          WHERE nr.oid = r.relnamespace
            AND r.oid = a.attrelid
            AND nc.oid = c.connamespace
            AND (CASE WHEN c.contype = 'f' THEN r.oid = c.confrelid AND a.attnum = ANY (c.confkey)
                      ELSE r.oid = c.conrelid AND a.attnum = ANY (c.conkey) END)
            AND NOT a.attisdropped
            AND c.contype IN ('p', 'u', 'f')
            AND r.relkind = 'r'

      ) AS x (tblschema, tblname, tblowner, colname, cstrschema, cstrname);

COMMENT ON VIEW scrud.constraint_column_usage IS 'Lists all columns having constraints.';

    

CREATE VIEW scrud.relationship_view
AS
SELECT 
    o.conname                                                       AS constraint_name,
    (SELECT nspname FROM pg_namespace WHERE oid=m.relnamespace)     AS table_schema,
    m.relname                                                       AS table_name,
    (SELECT a.attname FROM pg_attribute a 
    WHERE a.attrelid = m.oid
    AND a.attnum = o.conkey[1]
    AND a.attisdropped = FALSE)
                                                                    AS column_name,
    (SELECT nspname FROM pg_namespace
     WHERE oid=f.relnamespace) AS references_schema,
       f.relname
                                                                    AS references_table,
    (SELECT a.attname FROM pg_attribute a
     WHERE a.attrelid = f.oid
     AND a.attnum = o.confkey[1]
     AND a.attisdropped = FALSE)
                                                                    AS references_field
FROM pg_constraint o
LEFT JOIN pg_class c ON c.oid = o.conrelid
LEFT JOIN pg_class f ON f.oid = o.confrelid
LEFT JOIN pg_class m ON m.oid = o.conrelid
WHERE o.contype = 'f'
AND o.conrelid IN
(SELECT oid
 FROM pg_class c
 WHERE c.relkind = 'r');
 
COMMENT ON VIEW scrud.relationship_view IS 'Lists all foreign key columns and their relation with the parent tables.';

CREATE FUNCTION scrud.parse_default(text)
RETURNS text
AS
$$
DECLARE _sql text;
DECLARE _val text;
BEGIN
    IF($1 LIKE '%::%' AND $1 NOT LIKE 'nextval%') THEN
        _sql := 'SELECT ' || $1;
        EXECUTE _sql INTO _val;
        RETURN _val;
    END IF;

    RETURN $1;
END
$$
LANGUAGE plpgsql;

COMMENT ON FUNCTION scrud.parse_default(text) IS 'Parses default constraint column values.';


CREATE VIEW scrud.mixerp_table_view
AS
SELECT 
    pg_tables.schemaname                                    AS table_schema, 
    pg_tables.tablename                                     AS table_name, 
    pg_attribute.attname                                    AS column_name,
    constraint_name,
    references_schema, 
    references_table, 
    references_field, 
    pg_attribute.attnum                                     AS ordinal_position,
    CASE pg_attribute.attnotnull 
    WHEN false THEN 'YES' 
    ELSE 'NO' END                                           AS is_nullable, 
    (SELECT 
        scrud.parse_default(pg_attrdef.adsrc) 
        FROM pg_attrdef 
        WHERE pg_attrdef.adrelid = pg_class.oid 
        AND pg_attrdef.adnum = pg_attribute.attnum)         AS column_default,    
    format_type(pg_attribute.atttypid, NULL)                AS data_type, 
    format_type(pg_attribute.atttypid, NULL)                AS domain_name, 
    CASE pg_attribute.atttypmod
    WHEN -1 THEN NULL 
    ELSE pg_attribute.atttypmod - 4
    END                                         AS character_maximum_length,    
    pg_constraint.conname AS "key", 
    pc2.conname AS ckey
FROM pg_tables
INNER JOIN pg_class 
ON pg_class.relname = pg_tables.tablename 
INNER JOIN pg_attribute ON pg_class.oid = pg_attribute.attrelid 
    AND pg_attribute.attnum > 0 
LEFT JOIN pg_constraint ON pg_constraint.contype = 'p'::"char" 
    AND pg_constraint.conrelid = pg_class.oid AND
    (pg_attribute.attnum = ANY (pg_constraint.conkey)) 
LEFT JOIN pg_constraint AS pc2 ON pc2.contype = 'f'::"char" 
    AND pc2.conrelid = pg_class.oid 
    AND (pg_attribute.attnum = ANY (pc2.conkey))    
LEFT JOIN scrud.relationship_view 
ON pg_tables.schemaname = scrud.relationship_view.table_schema 
 AND pg_tables.tablename = scrud.relationship_view.table_name 
 AND pg_attribute.attname = scrud.relationship_view.column_name 
WHERE pg_attribute.attname NOT IN
    (
        'audit_user_id', 'audit_ts'
    )
AND NOT pg_attribute.attisdropped
ORDER BY pg_attribute.attnum;


COMMENT ON VIEW scrud.mixerp_table_view IS 'Lists all schema, table, and columns with associated types, domains, references, and constraints.';

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/2.install-unit-test.sql --<--<--
/********************************************************************************
The PostgreSQL License

Copyright (c) 2014, Binod Nepal, Mix Open Foundation (http://mixof.org).

Permission to use, copy, modify, and distribute this software and its documentation 
for any purpose, without fee, and without a written agreement is hereby granted, 
provided that the above copyright notice and this paragraph and 
the following two paragraphs appear in all copies.

IN NO EVENT SHALL MIX OPEN FOUNDATION BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, 
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, 
ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF 
MIX OPEN FOUNDATION HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

MIX OPEN FOUNDATION SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, 
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, 
AND MIX OPEN FOUNDATION HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, 
UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
***********************************************************************************/

DROP SCHEMA IF EXISTS assert CASCADE;
DROP SCHEMA IF EXISTS unit_tests CASCADE;
DROP DOMAIN IF EXISTS public.test_result CASCADE;

CREATE SCHEMA assert AUTHORIZATION postgres;
CREATE SCHEMA unit_tests AUTHORIZATION postgres;
CREATE DOMAIN public.test_result AS text;

CREATE TABLE unit_tests.tests
(
    test_id                                 SERIAL NOT NULL PRIMARY KEY,
    started_on                              TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT(CURRENT_TIMESTAMP AT TIME ZONE 'UTC'),
    completed_on                            TIMESTAMP WITHOUT TIME ZONE NULL,
    total_tests                             integer NULL DEFAULT(0),
    failed_tests                            integer NULL DEFAULT(0)
);

CREATE INDEX unit_tests_tests_started_on_inx
ON unit_tests.tests(started_on);

CREATE INDEX unit_tests_tests_completed_on_inx
ON unit_tests.tests(completed_on);

CREATE INDEX unit_tests_tests_failed_tests_inx
ON unit_tests.tests(failed_tests);

CREATE TABLE unit_tests.test_details
(
    id                                      BIGSERIAL NOT NULL PRIMARY KEY,
    test_id                                 integer NOT NULL REFERENCES unit_tests.tests(test_id),
    function_name                           text NOT NULL,
    message                                 text NOT NULL,
    ts                                      TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT(CURRENT_TIMESTAMP AT TIME ZONE 'UTC'),
    status                                  boolean NOT NULL
);

CREATE INDEX unit_tests_test_details_test_id_inx
ON unit_tests.test_details(test_id);

CREATE INDEX unit_tests_test_details_status_inx
ON unit_tests.test_details(status);

CREATE FUNCTION assert.fail(message text)
RETURNS text
AS
$$
BEGIN
    IF $1 IS NULL OR trim($1) = '' THEN
        message := 'NO REASON SPECIFIED';
    END IF;
    
    RAISE WARNING 'ASSERT FAILED : %', message;
    RETURN message;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;

CREATE FUNCTION assert.pass(message text)
RETURNS text
AS
$$
BEGIN
    RAISE NOTICE 'ASSERT PASSED : %', message;
    RETURN '';
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;

CREATE FUNCTION assert.ok(message text)
RETURNS text
AS
$$
BEGIN
    RAISE NOTICE 'OK : %', message;
    RETURN '';
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;

CREATE FUNCTION assert.is_equal(IN have anyelement, IN want anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 = $2) THEN
        message := 'Assert is equal.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;

    message := E'ASSERT IS_EQUAL FAILED.\n\nHave -> ' || $1::text || E'\nWant -> ' || $2::text || E'\n';    
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.are_equal(VARIADIC anyarray, OUT message text, OUT result boolean)
AS
$$
    DECLARE count integer=0;
BEGIN
    SELECT COUNT(DISTINCT $1[s.i]) INTO count
    FROM generate_series(array_lower($1,1), array_upper($1,1)) AS s(i)
    ORDER BY 1;

    IF count <> 1 THEN
        MESSAGE := 'ASSERT ARE_EQUAL FAILED.';  
        PERFORM assert.fail(MESSAGE);
        RESULT := FALSE;
        RETURN;
    END IF;

    message := 'Asserts are equal.';
    PERFORM assert.ok(message);
    result := true;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;

CREATE FUNCTION assert.is_not_equal(IN already_have anyelement, IN dont_want anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 != $2) THEN
        message := 'Assert is not equal.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_NOT_EQUAL FAILED.\n\nAlready Have -> ' || $1::text || E'\nDon''t Want   -> ' || $2::text || E'\n';   
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;

CREATE FUNCTION assert.are_not_equal(VARIADIC anyarray, OUT message text, OUT result boolean)
AS
$$
    DECLARE count integer=0;
BEGIN
    SELECT COUNT(DISTINCT $1[s.i]) INTO count
    FROM generate_series(array_lower($1,1), array_upper($1,1)) AS s(i)
    ORDER BY 1;

    IF count <> array_upper($1,1) THEN
        MESSAGE := 'ASSERT ARE_NOT_EQUAL FAILED.';  
        PERFORM assert.fail(MESSAGE);
        RESULT := FALSE;
        RETURN;
    END IF;

    message := 'Asserts are not equal.';
    PERFORM assert.ok(message);
    result := true;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_null(IN anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 IS NULL) THEN
        message := 'Assert is NULL.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_NULL FAILED. NULL value was expected.\n\n\n';    
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_not_null(IN anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 IS NOT NULL) THEN
        message := 'Assert is not NULL.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_NOT_NULL FAILED. The value is NULL.\n\n\n';  
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_true(IN boolean, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 == true) THEN
        message := 'Assert is true.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_TRUE FAILED. A true condition was expected.\n\n\n';  
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_false(IN boolean, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 == true) THEN
        message := 'Assert is false.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_FALSE FAILED. A false condition was expected.\n\n\n';    
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_greater_than(IN x anyelement, IN y anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 > $2) THEN
        message := 'Assert greater than condition is satisfied.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_GREATER_THAN FAILED.\n\n X : -> ' || $1::text || E'\n is not greater than Y:   -> ' || $2::text || E'\n';    
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.is_less_than(IN x anyelement, IN y anyelement, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF($1 < $2) THEN
        message := 'Assert less than condition is satisfied.';
        PERFORM assert.ok(message);
        result := true;
        RETURN;
    END IF;
    
    message := E'ASSERT IS_LESS_THAN FAILED.\n\n X : -> ' || $1::text || E'\n is not  than Y:   -> ' || $2::text || E'\n';  
    PERFORM assert.fail(message);
    result := false;
    RETURN;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


CREATE FUNCTION assert.function_exists(function_name text, OUT message text, OUT result boolean)
AS
$$
BEGIN
    IF NOT EXISTS
    (
        SELECT  1
        FROM    pg_catalog.pg_namespace n
        JOIN    pg_catalog.pg_proc p
        ON      pronamespace = n.oid
        WHERE replace(nspname || '.' || proname || '(' || oidvectortypes(proargtypes) || ')', ' ' , '')::text=$1
    ) THEN
        message := 'The function % does not exist.', $1;
        PERFORM assert.fail(message);

        result := false;
        RETURN;
    END IF;

    message := 'OK. The function ' || $1 || ' exists.';
    PERFORM assert.ok(message);
    result := true;
    RETURN;
END
$$
LANGUAGE plpgsql;



DROP FUNCTION IF EXISTS assert.if_functions_compile
(
    VARIADIC _schema_name text[],
    OUT message text, 
    OUT result boolean    
);

CREATE OR REPLACE FUNCTION assert.if_functions_compile
(
    VARIADIC _schema_name text[],
    OUT message text, 
    OUT result boolean
)
AS
$$
    DECLARE all_parameters              text;
    DECLARE current_function            RECORD;
    DECLARE current_function_name       text;
    DECLARE current_type                text;
    DECLARE current_type_schema         text;
    DECLARE current_parameter           text;
    DECLARE functions_count             smallint := 0;
    DECLARE current_parameters_count    int;
    DECLARE i                           int;
    DECLARE command_text                text;
    DECLARE failed_functions            text;
BEGIN
    FOR current_function IN 
        SELECT proname, proargtypes, nspname 
        FROM pg_proc 
        INNER JOIN pg_namespace 
        ON pg_proc.pronamespace = pg_namespace.oid 
        WHERE pronamespace IN 
        (
            SELECT oid FROM pg_namespace 
            WHERE nspname = ANY($1) 
            AND nspname NOT IN
            (
                'assert', 'unit_tests', 'information_schema'
            ) 
            AND proname NOT IN('if_functions_compile')
        ) 
    LOOP
        current_parameters_count := array_upper(current_function.proargtypes, 1) + 1;

        i := 0;
        all_parameters := '';

        LOOP
        IF i < current_parameters_count THEN
            IF i > 0 THEN
                all_parameters := all_parameters || ', ';
            END IF;

            SELECT 
                nspname, typname 
            INTO 
                current_type_schema, current_type 
            FROM pg_type 
            INNER JOIN pg_namespace 
            ON pg_type.typnamespace = pg_namespace.oid
            WHERE pg_type.oid = current_function.proargtypes[i];

            IF(current_type IN('int4', 'int8', 'numeric', 'integer_strict', 'money_strict','decimal_strict', 'integer_strict2', 'money_strict2','decimal_strict2', 'money','decimal', 'numeric', 'bigint')) THEN
                current_parameter := '1::' || current_type_schema || '.' || current_type;
            ELSIF(substring(current_type, 1, 1) = '_') THEN
                current_parameter := 'NULL::' || current_type_schema || '.' || substring(current_type, 2, length(current_type)) || '[]';
            ELSIF(current_type in ('date')) THEN            
                current_parameter := '''1-1-2000''::' || current_type;
            ELSIF(current_type = 'bool') THEN
                current_parameter := 'false';            
            ELSE
                current_parameter := '''''::' || quote_ident(current_type_schema) || '.' || quote_ident(current_type);
            END IF;
            
            all_parameters = all_parameters || current_parameter;

            i := i + 1;
        ELSE
            EXIT;
        END IF;
    END LOOP;

    BEGIN
        current_function_name := quote_ident(current_function.nspname)  || '.' || quote_ident(current_function.proname);
        command_text := 'SELECT * FROM ' || current_function_name || '(' || all_parameters || ');';

        EXECUTE command_text;
        functions_count := functions_count + 1;

        EXCEPTION WHEN OTHERS THEN
            IF(failed_functions IS NULL) THEN 
                failed_functions := '';
            END IF;

            IF(SQLSTATE IN('42702', '42704')) THEN
                failed_functions := failed_functions || E'\n' || command_text || E'\n' || SQLERRM || E'\n';                
            END IF;
    END;


    END LOOP;

    IF(failed_functions != '') THEN
        message := E'The test if_functions_compile failed. The following functions failed to compile : \n\n' || failed_functions;
        result := false;
        PERFORM assert.fail(message);
        RETURN;
    END IF;
END;
$$
LANGUAGE plpgsql 
VOLATILE;

DROP FUNCTION IF EXISTS assert.if_views_compile
(
    VARIADIC _schema_name text[],
    OUT message text, 
    OUT result boolean    
);

CREATE FUNCTION assert.if_views_compile
(
    VARIADIC _schema_name text[],
    OUT message text, 
    OUT result boolean    
)
AS
$$

    DECLARE message                     test_result;
    DECLARE current_view                RECORD;
    DECLARE current_view_name           text;
    DECLARE command_text                text;
    DECLARE failed_views                text;
BEGIN
    FOR current_view IN 
        SELECT table_name, table_schema 
        FROM information_schema.views
        WHERE table_schema = ANY($1) 
    LOOP

    BEGIN
        current_view_name := quote_ident(current_view.table_schema)  || '.' || quote_ident(current_view.table_name);
        command_text := 'SELECT * FROM ' || current_view_name || ' LIMIT 1;';

        RAISE NOTICE '%', command_text;
        
        EXECUTE command_text;

        EXCEPTION WHEN OTHERS THEN
            IF(failed_views IS NULL) THEN 
                failed_views := '';
            END IF;

            failed_views := failed_views || E'\n' || command_text || E'\n' || SQLERRM || E'\n';                
    END;


    END LOOP;

    IF(failed_views != '') THEN
        message := E'The test if_views_compile failed. The following views failed to compile : \n\n' || failed_views;
        result := false;
        PERFORM assert.fail(message);
        RETURN;
    END IF;

    RETURN;
END;
$$
LANGUAGE plpgsql 
VOLATILE;

CREATE FUNCTION unit_tests.begin(v int DEFAULT 9)
RETURNS TABLE(message text, result character(1))
AS
$$
    DECLARE this record;
    DECLARE _function_name text;
    DECLARE _sql text;
    DECLARE _message text;
    DECLARE _result character(1);
    DECLARE _test_id integer;
    DECLARE _status boolean;
    DECLARE _total_tests integer = 0;
    DECLARE _failed_tests integer = 0;
    DECLARE _list_of_failed_tests text;
    DECLARE _started_from TIMESTAMP WITHOUT TIME ZONE;
    DECLARE _completed_on TIMESTAMP WITHOUT TIME ZONE;
    DECLARE _delta integer;
    DECLARE _ret_val text = '';
    DECLARE _verbosity text[] = ARRAY['debug5', 'debug4', 'debug3', 'debug2', 'debug1', 'log', 'notice', 'warning', 'error', 'fatal', 'panic'];
BEGIN
    _started_from := clock_timestamp() AT TIME ZONE 'UTC';

    RAISE INFO 'Test started from : %', _started_from; 

    IF(v > 10) THEN
        v := 9;
    END IF;
    
    EXECUTE 'SET CLIENT_MIN_MESSAGES TO ' || _verbosity[v];

    RAISE WARNING 'CLIENT_MIN_MESSAGES set to : %' , _verbosity[v];
    

    SELECT nextval('unit_tests.tests_test_id_seq') INTO _test_id;

    INSERT INTO unit_tests.tests(test_id)
    SELECT _test_id;

    FOR this IN
        SELECT proname as function_name
        FROM    pg_catalog.pg_namespace n
        JOIN    pg_catalog.pg_proc p
        ON      pronamespace = n.oid
        WHERE   nspname = 'unit_tests'
        AND prorettype='test_result'::regtype::oid
    LOOP
        BEGIN
            _status := false;
            _total_tests := _total_tests + 1;
            
            _function_name = 'unit_tests.' || this.function_name || '()';
            _sql := 'SELECT ' || _function_name || ';';
            
            RAISE NOTICE 'RUNNING TEST : %.', _function_name;

            EXECUTE _sql INTO _message;

            IF _message = '' THEN
                _status := true;
            END IF;

            
            INSERT INTO unit_tests.test_details(test_id, function_name, message, status)
            SELECT _test_id, _function_name, _message, _status;

            IF NOT _status THEN
                _failed_tests := _failed_tests + 1;         
                RAISE WARNING 'TEST % FAILED.', _function_name;
                RAISE WARNING 'REASON: %', _message;
            ELSE
                RAISE NOTICE 'TEST % COMPLETED WITHOUT ERRORS.', _function_name;
            END IF;

        EXCEPTION WHEN OTHERS THEN
            _message := 'ERR' || SQLSTATE || ': ' || SQLERRM;
            INSERT INTO unit_tests.test_details(test_id, function_name, message, status)
            SELECT _test_id, _function_name, _message, false;

            _failed_tests := _failed_tests + 1;         
            RAISE WARNING 'TEST % FAILED.', _function_name;
            RAISE WARNING 'REASON: %', _message;
        END;
    END LOOP;

    _completed_on := clock_timestamp() AT TIME ZONE 'UTC';
    _delta := extract(millisecond from _completed_on - _started_from)::integer;
    
    UPDATE unit_tests.tests
    SET total_tests = _total_tests, failed_tests = _failed_tests, completed_on = _completed_on
    WHERE test_id = _test_id;

    
    WITH failed_tests AS
    (
        SELECT row_number() over (order by id) AS id, 
        unit_tests.test_details.function_name,
        unit_tests.test_details.message
        FROM unit_tests.test_details 
        WHERE test_id = _test_id
        AND status= false
    )

    SELECT array_to_string(array_agg(f.id::text || '. ' || f.function_name || ' --> ' || f.message), E'\n') INTO _list_of_failed_tests 
    FROM failed_tests f;

    _ret_val := _ret_val ||  'Test completed on : ' || _completed_on::text || E' UTC. \nTotal test runtime: ' || _delta::text || E' ms.\n';
    _ret_val := _ret_val || E'\nTotal tests run : ' || COALESCE(_total_tests, '0')::text;
    _ret_val := _ret_val || E'.\nPassed tests    : ' || (COALESCE(_total_tests, '0') - COALESCE(_failed_tests, '0'))::text;
    _ret_val := _ret_val || E'.\nFailed tests    : ' || COALESCE(_failed_tests, '0')::text;
    _ret_val := _ret_val || E'.\n\nList of failed tests:\n' || '----------------------';
    _ret_val := _ret_val || E'\n' || COALESCE(_list_of_failed_tests, '<NULL>')::text;
    _ret_val := _ret_val || E'\n' || E'End of plpgunit test.\n\n';


    IF _failed_tests > 0 THEN
        _result := 'N';
        RAISE INFO '%', _ret_val;
    ELSE
        _result := 'Y';
        RAISE INFO '%', _ret_val;
    END IF;

    SET CLIENT_MIN_MESSAGES TO notice;

    RETURN QUERY SELECT _ret_val, _result;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/2.mixerp-db-schema.sql --<--<--
DROP SCHEMA IF EXISTS audit CASCADE;
DROP SCHEMA IF EXISTS core CASCADE;
DROP SCHEMA IF EXISTS localization CASCADE;
DROP SCHEMA IF EXISTS mrp CASCADE;
DROP SCHEMA IF EXISTS office CASCADE;
DROP SCHEMA IF EXISTS policy CASCADE;
DROP SCHEMA IF EXISTS transactions CASCADE;
DROP SCHEMA IF EXISTS crm CASCADE;

CREATE SCHEMA audit;
COMMENT ON SCHEMA audit IS 'Contains audit-related objects.';

CREATE SCHEMA core;
COMMENT ON SCHEMA core IS 'Contains objects related to the core module. The core module is the default MixERP schema.';

CREATE SCHEMA crm;
COMMENT ON SCHEMA crm IS 'Contains objects related to customer relationship management.';

CREATE SCHEMA localization;
COMMENT ON SCHEMA localization IS 'Contains objects related to localizing MixERP.';

CREATE SCHEMA mrp;
COMMENT ON SCHEMA mrp IS 'Contains objects related to material resource planning.';

CREATE SCHEMA office;
COMMENT ON SCHEMA office IS 'Contains objects related to office.';

CREATE SCHEMA policy;
COMMENT ON SCHEMA policy IS 'Contains objects related to MixERP''s policy engine and workflow.';

CREATE SCHEMA transactions;
COMMENT ON SCHEMA transactions IS 'Contains objects related to transaction posting.';

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/3.roles-and-priviledge.sql --<--<--
DO
$$
BEGIN
    IF NOT EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname = 'mix_erp') THEN
        CREATE ROLE mix_erp WITH LOGIN PASSWORD 'change-on-deployment';
    END IF;

    COMMENT ON ROLE mix_erp IS 'The default user for MixERP databases.';

    EXECUTE 'ALTER DATABASE ' || current_database() || ' OWNER TO mix_erp;';

    REVOKE ALL ON SCHEMA assert FROM public;
    REVOKE ALL ON SCHEMA audit FROM public;
    REVOKE ALL ON SCHEMA core FROM public;
    REVOKE ALL ON SCHEMA crm FROM public;
    REVOKE ALL ON SCHEMA localization FROM public;
    REVOKE ALL ON SCHEMA office FROM public;
    REVOKE ALL ON SCHEMA mrp FROM public;
    REVOKE ALL ON SCHEMA policy FROM public;
    REVOKE ALL ON SCHEMA scrud FROM public;
    REVOKE ALL ON SCHEMA transactions FROM public;
    REVOKE ALL ON SCHEMA unit_tests FROM public;

        
    GRANT USAGE ON SCHEMA assert TO mix_erp;
    GRANT USAGE ON SCHEMA audit TO mix_erp;
    GRANT USAGE ON SCHEMA core TO mix_erp;
    GRANT USAGE ON SCHEMA crm TO mix_erp;
    GRANT USAGE ON SCHEMA information_schema TO mix_erp;
    GRANT USAGE ON SCHEMA localization TO mix_erp;
    GRANT USAGE ON SCHEMA mrp TO mix_erp;
    GRANT USAGE ON SCHEMA office TO mix_erp;
    GRANT USAGE ON SCHEMA policy TO mix_erp;
    GRANT USAGE ON SCHEMA public TO mix_erp;
    GRANT USAGE ON SCHEMA scrud TO mix_erp;
    GRANT USAGE ON SCHEMA transactions TO mix_erp;
    GRANT USAGE ON SCHEMA unit_tests TO mix_erp;

    ALTER DEFAULT PRIVILEGES IN SCHEMA assert GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA core GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA crm GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA information_schema GRANT SELECT ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA localization GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA mrp GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA office GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA policy GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA transactions GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA unit_tests GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO mix_erp;


    GRANT SELECT ON ALL TABLES IN SCHEMA scrud TO mix_erp;
    GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA scrud TO mix_erp;

    ALTER DEFAULT PRIVILEGES IN SCHEMA assert GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA core GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA crm GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA localization GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA mrp GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA office GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA policy GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA transactions GRANT ALL ON SEQUENCES TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA unit_tests GRANT ALL ON SEQUENCES TO mix_erp;


    ALTER DEFAULT PRIVILEGES IN SCHEMA assert GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA core GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA crm GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA information_schema GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA localization GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA mrp GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA office GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA policy GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA transactions GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    ALTER DEFAULT PRIVILEGES IN SCHEMA unit_tests GRANT EXECUTE ON FUNCTIONS TO mix_erp;
    
    
    GRANT ALL PRIVILEGES ON SCHEMA unit_tests TO mix_erp;
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA unit_tests TO mix_erp;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA unit_tests TO mix_erp;
    GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA unit_tests TO mix_erp;
END
$$
LANGUAGE plpgsql;




DO
$$
BEGIN
    IF NOT EXISTS (SELECT * FROM pg_catalog.pg_roles WHERE rolname= 'report_user') THEN
        CREATE ROLE report_user WITH LOGIN PASSWORD 'change-on-deployment';
    END IF;

    COMMENT ON ROLE report_user IS 'This user account should be used by the Reporting Engine to run ad-hoc queries.
    It is strictly advised for this user to only have a read-only access to the database.';

    GRANT USAGE ON SCHEMA public TO report_user;
    GRANT USAGE ON SCHEMA information_schema TO report_user;
    GRANT USAGE ON SCHEMA audit TO report_user;
    GRANT USAGE ON SCHEMA core TO report_user;
    GRANT USAGE ON SCHEMA office TO report_user;
    GRANT USAGE ON SCHEMA policy TO report_user;
    GRANT USAGE ON SCHEMA transactions TO report_user;
    GRANT USAGE ON SCHEMA crm TO report_user;
    GRANT USAGE ON SCHEMA mrp TO report_user;

    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA information_schema GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA core GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA office GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA policy GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA transactions GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA crm GRANT SELECT ON TABLES TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA mrp GRANT SELECT ON TABLES TO report_user;


    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA information_schema GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA audit GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA core GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA office GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA policy GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA transactions GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA crm GRANT EXECUTE ON FUNCTIONS TO report_user;
    ALTER DEFAULT PRIVILEGES IN SCHEMA mrp GRANT EXECUTE ON FUNCTIONS TO report_user;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/4.casts.sql --<--<--
DROP FUNCTION IF EXISTS pg_catalog.text(unknown) CASCADE;
CREATE FUNCTION pg_catalog.text(unknown) 
RETURNS text 
AS
$$
BEGIN
    RETURN $1::text;
END
$$
LANGUAGE plpgsql; 

CREATE CAST (unknown AS text) WITH FUNCTION pg_catalog.text(unknown) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(integer) CASCADE;
CREATE FUNCTION pg_catalog.text(integer) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(int4out($1));';
CREATE CAST (integer AS text) WITH FUNCTION pg_catalog.text(integer) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(smallint) CASCADE;
CREATE FUNCTION pg_catalog.text(smallint) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(int2out($1));';
CREATE CAST (smallint AS text) WITH FUNCTION pg_catalog.text(smallint) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(oid) CASCADE;
CREATE FUNCTION pg_catalog.text(oid) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(oidout($1));';
CREATE CAST (oid AS text) WITH FUNCTION pg_catalog.text(oid) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(date) CASCADE;
CREATE FUNCTION pg_catalog.text(date) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(date_out($1));';
CREATE CAST (date AS text) WITH FUNCTION pg_catalog.text(date) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(double precision) CASCADE;
CREATE FUNCTION pg_catalog.text(double precision) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(float8out($1));';
CREATE CAST (double precision AS text) WITH FUNCTION pg_catalog.text(double precision) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(real) CASCADE;
CREATE FUNCTION pg_catalog.text(real) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(float4out($1));';
CREATE CAST (real AS text) WITH FUNCTION pg_catalog.text(real) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(time with time zone) CASCADE;
CREATE FUNCTION pg_catalog.text(time with time zone) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(timetz_out($1));';
CREATE CAST (time with time zone AS text) WITH FUNCTION pg_catalog.text(time with time zone) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(time without time zone) CASCADE;
CREATE FUNCTION pg_catalog.text(time without time zone) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(time_out($1));';
CREATE CAST (time without time zone AS text) WITH FUNCTION pg_catalog.text(time without time zone) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(timestamp with time zone) CASCADE;
CREATE FUNCTION pg_catalog.text(timestamp with time zone) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(timestamptz_out($1));';
CREATE CAST (timestamp with time zone AS text) WITH FUNCTION pg_catalog.text(timestamp with time zone) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(timestamp without time zone) CASCADE;
CREATE FUNCTION pg_catalog.text(timestamp without time zone) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(timestamp_out($1));';
CREATE CAST (timestamp without time zone AS text) WITH FUNCTION pg_catalog.text(timestamp without time zone) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(interval) CASCADE;
CREATE FUNCTION pg_catalog.text(interval) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(interval_out($1));';
CREATE CAST (interval AS text) WITH FUNCTION pg_catalog.text(interval) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(bigint) CASCADE;
CREATE FUNCTION pg_catalog.text(bigint) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(int8out($1));';
CREATE CAST (bigint AS text) WITH FUNCTION pg_catalog.text(bigint) AS IMPLICIT;

DROP FUNCTION IF EXISTS pg_catalog.text(numeric) CASCADE;
CREATE FUNCTION pg_catalog.text(numeric) RETURNS text STRICT IMMUTABLE LANGUAGE SQL AS 'SELECT textin(numeric_out($1));';
CREATE CAST (numeric AS text) WITH FUNCTION pg_catalog.text(numeric) AS IMPLICIT;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/5.localization.sql --<--<--
CREATE TABLE localization.resources
(
    resource_id         SERIAL PRIMARY KEY,
    path                text,
    key                 text,
    value               text
);

CREATE UNIQUE INDEX resources_path_key_uix
ON localization.resources(UPPER(path), UPPER(key));

CREATE INDEX resources_path_key_inx
ON localization.resources(path, key);

CREATE INDEX resources_path_inx
ON localization.resources(path);

CREATE INDEX resources_key_inx
ON localization.resources(key);

CREATE TABLE localization.cultures
(
    culture_code        text PRIMARY KEY,
    culture_name        text
);

INSERT INTO localization.cultures
SELECT 'de-DE',     'German (Germany)'              UNION ALL
SELECT 'en-GB',     'English (United Kingdom)'      UNION ALL
SELECT 'es-ES',     'Spanish (Spain)'               UNION ALL
SELECT 'fil-PH',    'Filipino (Philippines)'        UNION ALL
SELECT 'fr-FR',     'French (France)'               UNION ALL
SELECT 'id-ID',     'Indonesian (Indonesia)'        UNION ALL
SELECT 'ja-JP',     'Japanese (Japan)'              UNION ALL
SELECT 'ms-MY',     'Malay (Malaysia)'              UNION ALL
SELECT 'nl-NL',     'Dutch (Netherlands)'           UNION ALL
SELECT 'pt-PT',     'Portuguese (Portugal)'         UNION ALL
SELECT 'ru-RU',     'Russian (Russia)'              UNION ALL
SELECT 'sv-SE',     'Swedish (Sweden)'              UNION ALL
SELECT 'zh-CN',     'Simplified Chinese (China)';


CREATE TABLE localization.localized_resources
(
    id                  SERIAL PRIMARY KEY,
    culture_code        text REFERENCES localization.cultures,
    key                 text,
    value               text
);

CREATE UNIQUE INDEX localized_resources_culture_key_uix
ON localization.localized_resources(UPPER(culture_code), UPPER(key));

CREATE FUNCTION localization.add_resource
(
    path                text,
    key                 text,
    value               text
)
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM localization.resources WHERE localization.resources.path=$1 AND localization.resources.key=$2) THEN
        INSERT INTO localization.resources(path, key, value)
        SELECT $1, $2, $3;
    END IF;
END
$$
LANGUAGE plpgsql;

CREATE FUNCTION localization.get_localization_table
(
    culture_code        text
)
RETURNS TABLE
(
    row_number          bigint,
    key                 text,
    invariant_resource  text,
    value               text
)
AS
$$
BEGIN   
    CREATE TEMPORARY TABLE t
    (
        key                 text,
        invariant_resource  text,
        value               text
    );
    INSERT INTO t(key, invariant_resource, value)
    SELECT
        DISTINCT localization.resources.key,
        localization.resources.value as invariant_resource,
        localization.localized_resources.value
    FROM localization.resources
    LEFT JOIN localization.localized_resources
    ON localization.resources.key = localization.localized_resources.key
    AND localization.localized_resources.culture_code = $1;

    RETURN QUERY 
    SELECT 
        row_number() OVER(ORDER BY t.key ~ '^[[:upper:]][^[:upper:]]' DESC, t.key),
        t.key,
        t.invariant_resource,
        t.value
    FROM t
    ORDER BY t.key ~ '^[[:upper:]][^[:upper:]]' DESC, t.key;
END
$$
LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION localization.add_localized_resource(text, text, text)
RETURNS void AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM localization.localized_resources 
        WHERE localization.localized_resources.culture_code=$1 
        AND localization.localized_resources.key=$2
    ) THEN
        UPDATE localization.localized_resources
        SET value=$3
        WHERE localization.localized_resources.culture_code=$1 AND key=$2;

        RETURN;
    END IF;

    INSERT INTO localization.localized_resources(culture_code, key, value)
    SELECT $1, $2, $3;
END
$$
LANGUAGE plpgsql VOLATILE
COST 100;

CREATE VIEW localization.localized_resources_view
AS
SELECT
    REPLACE(localization.resources.path, '.resx', '') || '.' || localization.localized_resources.culture_code || '.resx' AS resource,
    localization.resources.key,
    localization.localized_resources.culture_code,
    localization.localized_resources.value
FROM localization.resources
INNER JOIN localization.localized_resources
ON localization.localized_resources.key = localization.resources.key
ORDER BY PATH;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/00.db core/6.locale.sql --<--<--
DROP FUNCTION IF EXISTS core.get_locale();

CREATE FUNCTION core.get_locale()
RETURNS text
AS
$$
BEGIN
    RETURN 'en-US';
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/01.types-domains-tables-and-constraints/domains.sql --<--<--
DROP DOMAIN IF EXISTS public.transaction_type CASCADE;
CREATE DOMAIN public.transaction_type
AS char(2)
CHECK
(
    VALUE IN
    (
        'Dr', --Debit
        'Cr' --Credit
    )
);

COMMENT ON DOMAIN public.transaction_type IS 'This domain should not be localized.';


/*******************************************************************
    MIXERP STRICT Data Types: NEGATIVES ARE NOT ALLOWED
*******************************************************************/

DROP DOMAIN IF EXISTS public.money_strict CASCADE;
CREATE DOMAIN public.money_strict
AS DECIMAL(24, 4)
CHECK
(
    VALUE > 0
);


DROP DOMAIN IF EXISTS public.money_strict2 CASCADE;
CREATE DOMAIN public.money_strict2
AS DECIMAL(24, 4)
CHECK
(
    VALUE >= 0
);

DROP DOMAIN IF EXISTS public.integer_strict CASCADE;
CREATE DOMAIN public.integer_strict
AS integer
CHECK
(
    VALUE > 0
);

DROP DOMAIN IF EXISTS public.integer_strict2 CASCADE;
CREATE DOMAIN public.integer_strict2
AS integer
CHECK
(
    VALUE >= 0
);

DROP DOMAIN IF EXISTS public.smallint_strict CASCADE;
CREATE DOMAIN public.smallint_strict
AS smallint
CHECK
(
    VALUE > 0
);

DROP DOMAIN IF EXISTS public.smallint_strict2 CASCADE;
CREATE DOMAIN public.smallint_strict2
AS smallint
CHECK
(
    VALUE >= 0
);

DROP DOMAIN IF EXISTS public.decimal_strict CASCADE;
CREATE DOMAIN public.decimal_strict
AS decimal
CHECK
(
    VALUE > 0
);

DROP DOMAIN IF EXISTS public.decimal_strict2 CASCADE;
CREATE DOMAIN public.decimal_strict2
AS decimal
CHECK
(
    VALUE >= 0
);

DROP DOMAIN IF EXISTS public.color CASCADE;
CREATE DOMAIN public.color
AS text;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/01.types-domains-tables-and-constraints/tables-and-constraints.sql --<--<--
--Todo: Indexing has not been properly thought of, as of now.

CREATE TABLE core.verification_statuses
(
    verification_status_id                  smallint PRIMARY KEY,
    verification_status_name                national character varying(128) NOT NULL
);

COMMENT ON TABLE core.verification_statuses IS 
'Verification statuses are integer values used to represent the state of a transaction.
For example, a verification status of value "0" would mean that the transaction has not yet been verified.
A negative value indicates that the transaction was rejected, whereas a positive value means approved.

Remember:
1. Only approved transactions appear on ledgers and final reports.
2. Cash repository balance is maintained on the basis of LIFO principle. 

   This means that cash balance is affected (reduced) on your repository as soon as a credit transaction is posted,
   without the transaction being approved on the first place. If you reject the transaction, the cash balance then increases.
   This also means that the cash balance is not affected (increased) on your repository as soon as a debit transaction is posted.
   You will need to approve the transaction.

   It should however be noted that the cash repository balance might be less than the total cash shown on your balance sheet,
   if you have pending transactions to verify. You cannot perform EOD operation if you have pending verifications.
';


CREATE TABLE office.users
(
    user_id                                 SERIAL PRIMARY KEY,
    role_id                                 integer NOT NULL,
    department_id                           integer NOT NULL,
    office_id                               integer NOT NULL,
    user_name                               national character varying(50) NOT NULL,
    full_name                               national character varying(100) NOT NULL,
    can_change_password                     boolean NOT NULL DEFAULT(true),
    password                                text NOT NULL,
    elevated                                boolean NOT NULL 
                                            CONSTRAINT users_elevated_df DEFAULT(false),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

COMMENT ON TABLE office.users IS
'
The users table contains users accounts and their login information. It also contains a sys user account which does not have a password.
The sys user account is a special account used by the MixERP workflow to perform routine tasks. The sys user cannot have a valid password
or cannot be allowed to log in interactively.';


CREATE UNIQUE INDEX verification_statuses_verification_status_name_uix
ON core.verification_statuses(UPPER(verification_status_name));

CREATE TABLE core.entities
(
    entity_id                               SERIAL PRIMARY KEY,
    entity_name                             national character varying(100),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX entities_entity_name_uix
ON core.entities(UPPER(entity_name));


CREATE TABLE core.industries
(
    industry_id                             SERIAL PRIMARY KEY,
    industry_name                           national character varying(100) NOT NULL,
    parent_industry_id                      integer REFERENCES core.industries(industry_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX industries_industry_name_uix
ON core.industries(UPPER(industry_name));



CREATE TABLE office.departments
(
    department_id                           SERIAL PRIMARY KEY,
    department_code                         national character varying(12) NOT NULL,
    department_name                         national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

ALTER TABLE office.users
ADD CONSTRAINT users_departments_fk 
FOREIGN KEY(department_id)
REFERENCES office.departments(department_id);

CREATE TABLE core.flag_types
(
    flag_type_id                            SERIAL PRIMARY KEY,
    flag_type_name                          national character varying(24) NOT NULL,
    background_color                        color NOT NULL,
    foreground_color                        color NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL
                                            DEFAULT(NOW())
);

COMMENT ON TABLE core.flag_types IS 'Flags are used by users to mark transactions. The flags created by a user is not visible to others.';

CREATE TABLE core.flags
(
    flag_id                                 BIGSERIAL PRIMARY KEY,
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    flag_type_id                            integer NOT NULL REFERENCES core.flag_types(flag_type_id),
    resource                                text, --Fully qualified resource name. Example: transactions.non_gl_stock_master.
    resource_key                            text, --The unique identifier for lookup. Example: non_gl_stock_master_id,
    resource_id                             text, --The value of the unique identifier to lookup for,
    flagged_on                              TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);


CREATE TABLE core.countries
(
    country_id                              SERIAL PRIMARY KEY,
    country_code                            national character varying(12) NOT NULL,
    country_name                            national character varying(100) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX countries_country_code_uix
ON core.countries(UPPER(country_code));

CREATE UNIQUE INDEX countries_country_name_uix
ON core.countries(UPPER(country_name));

CREATE TABLE core.states
(
    state_id                                SERIAL PRIMARY KEY,
    country_id                              integer NOT NULL REFERENCES core.countries(country_id),
    state_code                              national character varying(12) NOT NULL,
    state_name                              national character varying(100) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX states_state_code_uix
ON core.states(country_id, UPPER(state_code));

CREATE UNIQUE INDEX states_state_name_uix
ON core.states(country_id, UPPER(state_name));


CREATE TABLE core.counties
(
    county_id                               SERIAL PRIMARY KEY,
    county_code                             national character varying(12) NOT NULL,
    county_name                             national character varying(100) NOT NULL,
    state_id                                integer NOT NULL REFERENCES core.states(state_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
    
);


CREATE TABLE core.zip_code_types
(
    zip_code_type_id                        SERIAL PRIMARY KEY,
    type                                    national character varying(12),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX zip_code_types_zip_code_type_uix
ON core.zip_code_types(UPPER(type));


CREATE TABLE core.zip_codes
(
    zip_code_id                             BIGSERIAL PRIMARY KEY,
    state_id                                integer NOT NULL REFERENCES core.states(state_id),
    code                                    national character varying(12) NOT NULL,
    zip_code_type_id                        integer NOT NULL REFERENCES core.zip_code_types(zip_code_type_id),
    city                                    national character varying(100) NOT NULL,
    lat                                     decimal,
    lon                                     decimal,
    x_axis                                  decimal,
    y_axis                                  decimal,    
    z_axis                                  decimal,    
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())    
);

CREATE UNIQUE INDEX flags_user_id_resource_resource_id_uix
ON core.flags(user_id, UPPER(resource), UPPER(resource_key), UPPER(resource_id));

CREATE TABLE core.attachment_lookup
(
        attachment_lookup_id                SERIAL PRIMARY KEY,
        book                                national character varying(50) NOT NULL,
        resource                            text NOT NULL,
        resource_key                        text NOT NULL        
);

CREATE UNIQUE INDEX attachment_lookup_book_uix
ON core.attachment_lookup(lower(book));

CREATE UNIQUE INDEX attachment_lookup_resource_resource_key_uix
ON core.attachment_lookup(lower(book), lower(resource_key));


CREATE TABLE core.attachments
(
    attachment_id                           BIGSERIAL PRIMARY KEY,
    user_id                                 integer NOT NULL 
                                            REFERENCES office.users(user_id),
    resource                                text NOT NULL, --Fully qualified resource name. Example: transactions.non_gl_stock_master.
    resource_key                            text NOT NULL, --The unique identifier for lookup. Example: non_gl_stock_master_id,
    resource_id                             bigint NOT NULL, --The value of the unique identifier to lookup for,
    original_file_name                      text NOT NULL,
    file_extension                          national character varying(12) NOT NULL,
    file_path                               text NOT NULL,
    comment                                 national character varying(96) NOT NULL  
                                            CONSTRAINT attachments_comment_df 
                                            DEFAULT(''),
    added_on                                TIMESTAMP WITH TIME ZONE NOT NULL  
                                            CONSTRAINT attachments_added_on_df 
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX attachments_file_path_uix
ON core.attachments(UPPER(file_path));


CREATE TABLE core.currencies
(
    currency_code                           national character varying(12) PRIMARY KEY,
    currency_symbol                         national character varying(12) NOT NULL,
    currency_name                           national character varying(48) NOT NULL UNIQUE,
    hundredth_name                          national character varying(48) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);



CREATE TABLE office.offices
(
    office_id                               SERIAL PRIMARY KEY,
    office_code                             national character varying(12) NOT NULL,
    office_name                             national character varying(150) NOT NULL,
    nick_name                               national character varying(50) NULL,
    registration_date                       date NOT NULL,
    currency_code                           national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    po_box                                  national character varying(128) NULL,
    address_line_1                          national character varying(128) NULL,   
    address_line_2                          national character varying(128) NULL,
    street                                  national character varying(50) NULL,
    city                                    national character varying(50) NULL,
    state                                   national character varying(50) NULL,
    zip_code                                national character varying(24) NULL,
    country                                 national character varying(50) NULL,
    phone                                   national character varying(24) NULL,
    fax                                     national character varying(24) NULL,
    email                                   national character varying(128) NULL,
    url                                     national character varying(50) NULL,
    registration_number                     national character varying(24) NULL,
    pan_number                              national character varying(24) NULL,
    allow_transaction_posting               boolean not null DEFAULT(true),
    parent_office_id                        integer NULL REFERENCES office.offices(office_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

ALTER TABLE office.users
ADD FOREIGN KEY(office_id) REFERENCES office.offices(office_id);

CREATE UNIQUE INDEX offices_office_code_uix
ON office.offices(UPPER(office_code));

CREATE UNIQUE INDEX offices_office_name_uix
ON office.offices(UPPER(office_name));

CREATE UNIQUE INDEX offices_nick_name_uix
ON office.offices(UPPER(nick_name));






CREATE TABLE core.exchange_rates
(
    exchange_rate_id                        BIGSERIAL PRIMARY KEY,
    updated_on                              TIMESTAMP WITH TIME ZONE NOT NULL   
                                            CONSTRAINT exchange_rates_updated_on_df 
                                            DEFAULT(NOW()),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    status                                  BOOLEAN NOT NULL   
                                            CONSTRAINT exchange_rates_status_df 
                                            DEFAULT(true)
);

CREATE TABLE core.exchange_rate_details
(
    exchange_rate_detail_id                 BIGSERIAL PRIMARY KEY,
    exchange_rate_id                        bigint NOT NULL REFERENCES core.exchange_rates(exchange_rate_id),
    local_currency_code                     national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    foreign_currency_code                   national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    unit                                    integer_strict NOT NULL,
    exchange_rate                           decimal_strict NOT NULL
);


CREATE UNIQUE INDEX departments_department_code_uix
ON office.departments(UPPER(department_code));

CREATE UNIQUE INDEX departments_department_name_uix
ON office.departments(UPPER(department_name));


CREATE TABLE office.roles
(
    role_id                                 SERIAL PRIMARY KEY,
    role_code                               national character varying(12) NOT NULL,
    role_name                               national character varying(50) NOT NULL,
    is_admin                                boolean NOT NULL   
                                            CONSTRAINT roles_is_admin_df 
                                            DEFAULT(false),
    is_system                               boolean NOT NULL   
                                            CONSTRAINT roles_is_system_df 
                                            DEFAULT(false),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

ALTER TABLE office.users
ADD FOREIGN KEY(role_id) REFERENCES office.roles(role_id);


CREATE UNIQUE INDEX roles_role_code_uix
ON office.roles(UPPER(role_code));

CREATE UNIQUE INDEX roles_role_name_uix
ON office.roles(UPPER(role_name));


CREATE UNIQUE INDEX users_user_name_uix
ON office.users(UPPER(user_name));


CREATE TABLE audit.logins
(
    login_id                                BIGSERIAL PRIMARY KEY,
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    browser                                 national character varying(500) NOT NULL,
    ip_address                              national character varying(50) NOT NULL,
    login_date_time                         TIMESTAMP WITH TIME ZONE NOT NULL 
                                            DEFAULT(NOW()),
    remote_user                             national character varying(50) NOT NULL,
    culture                                 national character varying(12) NOT NULL
);


CREATE TABLE audit.failed_logins
(
    failed_login_id                         BIGSERIAL PRIMARY KEY,
    user_id                                 integer NULL REFERENCES office.users(user_id),
    user_name                               national character varying(50) NOT NULL,
    office_id                               integer NULL REFERENCES office.offices(office_id),
    browser                                 national character varying(500) NOT NULL,
    ip_address                              national character varying(50) NOT NULL,
    failed_date_time                        TIMESTAMP WITH TIME ZONE NOT NULL 
                                            DEFAULT(NOW()),
    remote_user                             national character varying(50) NOT NULL,
    details                                 national character varying(250) NULL
);


CREATE TABLE policy.lock_outs
(
    lock_out_id                             BIGSERIAL PRIMARY KEY,
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    lock_out_time                           TIMESTAMP WITH TIME ZONE NOT NULL 
                                            DEFAULT(NOW()),
    lock_out_till                           TIMESTAMP WITH TIME ZONE NOT NULL 
                                            DEFAULT(NOW() + '5 minutes'::interval)
);


CREATE TABLE core.price_types
(
    price_type_id                           SERIAL PRIMARY KEY,
    price_type_code                         national character varying(12) NOT NULL,
    price_type_name                         national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX price_types_price_type_code_uix
ON core.price_types(UPPER(price_type_code));

CREATE UNIQUE INDEX price_types_price_type_name_uix
ON core.price_types(UPPER(price_type_name));


CREATE TABLE core.menus
(
    menu_id                                 SERIAL PRIMARY KEY,
    menu_text                               national character varying(250) NOT NULL,
    url                                     national character varying(250) NULL,
    menu_code                               national character varying(12) NOT NULL,
    level                                   smallint NOT NULL,
    parent_menu_id                          integer NULL REFERENCES core.menus(menu_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX menus_menu_code_uix
ON core.menus(UPPER(menu_code));

CREATE TABLE core.menu_locale
(
    menu_locale_id                          SERIAL PRIMARY KEY,
    menu_id                                 integer NOT NULL REFERENCES core.menus(menu_id),
    culture                                 national character varying(12) NOT NULL,
    menu_text                               national character varying(250) NOT NULL
);

CREATE UNIQUE INDEX menu_locale_menu_id_culture_uix
ON core.menu_locale(menu_id, LOWER(culture));

CREATE TABLE policy.menu_policy
(
    policy_id                               SERIAL PRIMARY KEY,
    menu_id                                 integer NOT NULL REFERENCES core.menus(menu_id),
    office_id                               integer NULL REFERENCES office.offices(office_id),
    inherit_in_child_offices                boolean NOT NULL  
                                            DEFAULT(false),
    role_id                                 integer NULL REFERENCES office.roles(role_id),
    user_id                                 integer NULL REFERENCES office.users(user_id),
    scope                                   national character varying(12) NOT NULL
                                            CONSTRAINT menu_policy_scope_chk
                                            CHECK(scope IN('Allow','Deny'))
    
);

CREATE TABLE policy.menu_access
(
    access_id                               BIGSERIAL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    menu_id                                 integer NOT NULL REFERENCES core.menus(menu_id),
    user_id                                 integer NULL REFERENCES office.users(user_id)   
);

    
CREATE TABLE core.frequencies
(
    frequency_id                            SERIAL PRIMARY KEY,
    frequency_code                          national character varying(12) NOT NULL,
    frequency_name                          national character varying(50) NOT NULL
);


CREATE UNIQUE INDEX frequencies_frequency_code_uix
ON core.frequencies(UPPER(frequency_code));

CREATE UNIQUE INDEX frequencies_frequency_name_uix
ON core.frequencies(UPPER(frequency_name));


CREATE TABLE core.fiscal_year
(
    fiscal_year_code                        national character varying(12) PRIMARY KEY,
    fiscal_year_name                        national character varying(50) NOT NULL,
    starts_from                             date NOT NULL,
    ends_on                                 date NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX fiscal_year_fiscal_year_name_uix
ON core.fiscal_year(UPPER(fiscal_year_name));

CREATE UNIQUE INDEX fiscal_year_starts_from_uix
ON core.fiscal_year(starts_from);

CREATE UNIQUE INDEX fiscal_year_ends_on_uix
ON core.fiscal_year(ends_on);


CREATE TABLE core.frequency_setups
(
    frequency_setup_id                      SERIAL PRIMARY KEY,
    fiscal_year_code                        national character varying(12) NOT NULL REFERENCES core.fiscal_year(fiscal_year_code),
    frequency_setup_code                    national character varying(12) NOT NULL,
    value_date                              date NOT NULL UNIQUE,
    frequency_id                            integer NOT NULL REFERENCES core.frequencies(frequency_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX frequency_setups_frequency_setup_code_uix
ON core.frequency_setups(UPPER(frequency_setup_code));


--TODO: Validation constraints for core.frequency_setups

CREATE TABLE core.units
(
    unit_id                                 SERIAL PRIMARY KEY,
    unit_code                               national character varying(12) NOT NULL,
    unit_name                               national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX units_unit_code_uix
ON core.units(UPPER(unit_code));

CREATE UNIQUE INDEX units_unit_name_uix
ON core.units(UPPER(unit_name));


CREATE TABLE core.compound_units
(
    compound_unit_id                        SERIAL PRIMARY KEY,
    base_unit_id                            integer NOT NULL REFERENCES core.units(unit_id),
    value                                   smallint NOT NULL,
    compare_unit_id                         integer NOT NULL REFERENCES core.units(unit_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL  
                                            DEFAULT(NOW()),
                                            CONSTRAINT compound_units_chk
                                            CHECK(base_unit_id != compare_unit_id)
);

CREATE UNIQUE INDEX compound_units_info_uix
ON core.compound_units(base_unit_id, compare_unit_id);

CREATE TABLE core.account_masters
(
    account_master_id                       smallint PRIMARY KEY,
    account_master_code                     national character varying(3) NOT NULL,
    account_master_name                     national character varying(40) NOT NULL,
    normally_debit                          boolean NOT NULL CONSTRAINT account_masters_normally_debit_df DEFAULT(false),
    parent_account_master_id                smallint NULL REFERENCES core.account_masters(account_master_id)
);

CREATE UNIQUE INDEX account_master_code_uix
ON core.account_masters(UPPER(account_master_code));

CREATE UNIQUE INDEX account_master_name_uix
ON core.account_masters(UPPER(account_master_name));

CREATE INDEX account_master_parent_account_master_id_inx
ON core.account_masters(parent_account_master_id);


CREATE TABLE core.cash_flow_headings
(
    cash_flow_heading_id                    integer NOT NULL PRIMARY KEY,
    cash_flow_heading_code                  national character varying(12) NOT NULL,
    cash_flow_heading_name                  national character varying(100) NOT NULL,
    cash_flow_heading_type                  character(1) NOT NULL
                                            CONSTRAINT cash_flow_heading_cash_flow_heading_type_chk
                                            CHECK(cash_flow_heading_type IN('O', 'I', 'F')),
    is_debit                                boolean NOT NULL
                                            CONSTRAINT cash_flow_headings_is_debit_df
                                            DEFAULT(false),
    is_sales                                boolean NOT NULL
                                            CONSTRAINT cash_flow_headings_is_sales_df
                                            DEFAULT(false),
    is_purchase                             boolean NOT NULL
                                            CONSTRAINT cash_flow_headings_is_purchase_df
                                            DEFAULT(false),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX cash_flow_headings_cash_flow_heading_code_uix
ON core.cash_flow_headings(UPPER(cash_flow_heading_code));

CREATE UNIQUE INDEX cash_flow_headings_cash_flow_heading_name_uix
ON core.cash_flow_headings(UPPER(cash_flow_heading_code));


CREATE TABLE core.accounts
(
    account_id                              BIGSERIAL PRIMARY KEY,
    account_master_id                       smallint NOT NULL REFERENCES core.account_masters(account_master_id),
    account_number                          national character varying(12) NOT NULL,
    external_code                           national character varying(12) NULL   
                                            CONSTRAINT accounts_external_code_df  
                                            DEFAULT(''),
    currency_code                           national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    account_name                            national character varying(100) NOT NULL,
    description                             national character varying(200) NULL,
    confidential                            boolean NOT NULL   
                                            CONSTRAINT accounts_confidential_df  
                                            DEFAULT(false),
    is_transaction_node                     boolean NOT NULL --Non transaction nodes cannot be used in transaction.
                                            CONSTRAINT accounts_is_transaction_node_df
                                            DEFAULT(true),
    sys_type                                boolean NOT NULL   
                                            CONSTRAINT accounts_sys_type_df  
                                            DEFAULT(false),
    parent_account_id                       bigint NULL REFERENCES core.accounts(account_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX accounts_account_number_uix
ON core.accounts(UPPER(account_number));

CREATE UNIQUE INDEX accounts_name_uix
ON core.accounts(UPPER(account_name));


CREATE TABLE core.bank_accounts
(
    account_id                              bigint PRIMARY KEY REFERENCES core.accounts(account_id),                                            
    maintained_by_user_id                   integer NOT NULL REFERENCES office.users(user_id),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    bank_name                               national character varying(128) NOT NULL,
    bank_branch                             national character varying(128) NOT NULL,
    bank_contact_number                     national character varying(128) NULL,
    bank_address                            text NULL,
    bank_account_number                     national character varying(128) NULL,
    bank_account_type                       national character varying(128) NULL,
    relationship_officer_name               national character varying(128) NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE TABLE core.transaction_types
(
    transaction_type_id                     smallint PRIMARY KEY,
    transaction_type_code                   national character varying(4),
    transaction_type_name                   national character varying(100)
);

CREATE UNIQUE INDEX transaction_types_transaction_type_code_uix
ON core.transaction_types(UPPER(transaction_type_code));

CREATE UNIQUE INDEX transaction_types_transaction_type_name_uix
ON core.transaction_types(UPPER(transaction_type_name));

INSERT INTO core.transaction_types
SELECT 1, 'Any', 'Any (Debit or Credit)' UNION ALL
SELECT 2, 'Dr', 'Debit' UNION ALL
SELECT 3, 'Cr', 'Credit';

CREATE TABLE core.cash_flow_setup
(
    cash_flow_setup_id                      SERIAL PRIMARY KEY,
    cash_flow_heading_id                    integer NOT NULL REFERENCES core.cash_flow_headings(cash_flow_heading_id),
    account_master_id                       smallint NOT NULL REFERENCES core.account_masters(account_master_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

CREATE INDEX cash_flow_setup_cash_flow_heading_id_inx
ON core.cash_flow_setup(cash_flow_heading_id);

CREATE INDEX cash_flow_setup_account_master_id_inx
ON core.cash_flow_setup(account_master_id);

CREATE TABLE core.sales_teams
(
    sales_team_id                           SERIAL PRIMARY KEY,
    sales_team_code                         national character varying(12) NOT NULL,
    sales_team_name                         national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX sales_teams_sales_team_code_uix
ON core.sales_teams(UPPER(sales_team_code));

CREATE UNIQUE INDEX sales_teams_sales_team_name_uix
ON core.sales_teams(UPPER(sales_team_name));

CREATE TABLE core.salespersons
(
    salesperson_id                          SERIAL PRIMARY KEY,
    sales_team_id                           integer NOT NULL REFERENCES core.sales_teams(sales_team_id),
    salesperson_code                        national character varying(12) NOT NULL,
    salesperson_name                        national character varying(100) NOT NULL,
    address                                 national character varying(100) NOT NULL,
    contact_number                          national character varying(50) NOT NULL,
    commission_rate                         decimal_strict2 NOT NULL   
                                            DEFAULT(0),
    account_id                              bigint NOT NULL REFERENCES core.accounts(account_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX salespersons_salesperson_name_uix
ON core.salespersons(UPPER(salesperson_name));

CREATE TABLE core.bonus_slabs
(
    bonus_slab_id                           SERIAL PRIMARY KEY,
    bonus_slab_code                         national character varying(12) NOT NULL,
    bonus_slab_name                         national character varying(50) NOT NULL,
    effective_from                          date NOT NULL,
    ends_on                                 date NOT NULL,
    checking_frequency_id                   integer NOT NULL REFERENCES core.frequencies(frequency_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX bonus_slabs_bonus_slab_code_uix
ON core.bonus_slabs(UPPER(bonus_slab_code));


CREATE UNIQUE INDEX bonus_slabs_bonus_slab_name_uix
ON core.bonus_slabs(UPPER(bonus_slab_name));



CREATE TABLE core.bonus_slab_details
(
    bonus_slab_detail_id                    SERIAL PRIMARY KEY,
    bonus_slab_id                           integer NOT NULL REFERENCES core.bonus_slabs(bonus_slab_id),
    amount_from                             money_strict NOT NULL,
    amount_to                               money_strict NOT NULL,
    bonus_rate                              decimal_strict NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW()),
                                            CONSTRAINT bonus_slab_details_amounts_chk 
                                            CHECK(amount_to>amount_from)
);


CREATE TABLE core.salesperson_bonus_setups
(
    salesperson_bonus_setup_id SERIAL       PRIMARY KEY,
    salesperson_id                          integer NOT NULL REFERENCES core.salespersons(salesperson_id),
    bonus_slab_id                           integer NOT NULL REFERENCES core.bonus_slabs(bonus_slab_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX salesperson_bonus_setups_uix
ON core.salesperson_bonus_setups(salesperson_id, bonus_slab_id);

CREATE TABLE core.ageing_slabs
(
    ageing_slab_id SERIAL                   PRIMARY KEY,
    ageing_slab_name                        national character varying(24) NOT NULL,
    from_days                               integer NOT NULL,
    to_days                                 integer NOT NULL CHECK(to_days > 0),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX ageing_slabs_ageing_slab_name_uix
ON core.ageing_slabs(UPPER(ageing_slab_name));


CREATE TABLE core.party_types
(
    party_type_id                           SERIAL PRIMARY KEY,
    party_type_code                         national character varying(12) NOT NULL, 
    party_type_name                         national character varying(50) NOT NULL,
    is_supplier                             boolean NOT NULL   
                                            CONSTRAINT party_types_is_supplier_df   
                                            DEFAULT(false),
    account_id                              bigint NOT NULL REFERENCES core.accounts(account_id),--When a new party is added, this becomes the parent account.
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                              
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX party_types_party_type_code_uix
ON core.party_types(UPPER(party_type_code));

CREATE UNIQUE INDEX party_types_party_type_name_uix
ON core.party_types(UPPER(party_type_name));


CREATE TABLE core.parties
(
    party_id                                BIGSERIAL PRIMARY KEY,
    party_type_id                           integer NOT NULL REFERENCES core.party_types(party_type_id),
    party_code                              national character varying(12) NULL,
    first_name                              national character varying(50) NOT NULL,
    middle_name                             national character varying(50) NULL,
    last_name                               national character varying(50) NOT NULL,
    party_name                              text NULL,
    date_of_birth                           date NULL,
    entity_id                               integer NULL REFERENCES core.entities(entity_id),
    industry_id                             integer NULL REFERENCES core.industries(industry_id),
    country_id                              integer NOT NULL REFERENCES core.countries(country_id),
    state_id                                integer NOT NULL REFERENCES core.states(state_id),
    zip_code                                national character varying(12) NULL,
    address_line_1                          national character varying(128) NULL,   
    address_line_2                          national character varying(128) NULL,
    street                                  national character varying(50) NULL,
    city                                    national character varying(50) NULL,
    phone                                   national character varying(24) NULL,
    fax                                     national character varying(24) NULL,
    cell                                    national character varying(24) NULL,
    email                                   national character varying(128) NULL,
    url                                     national character varying(50) NULL,
    pan_number                              national character varying(50) NULL,
    sst_number                              national character varying(50) NULL,
    cst_number                              national character varying(50) NULL,
    currency_code                           national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    allow_credit                            boolean NULL,
    maximum_credit_period                   smallint NULL,
    maximum_credit_amount                   money_strict2 NULL,
    account_id                              bigint NULL REFERENCES core.accounts(account_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX parties_party_code_uix
ON core.parties(UPPER(party_code));

CREATE TABLE core.shipping_addresses
(
    shipping_address_id                     BIGSERIAL PRIMARY KEY,
    shipping_address_code                   national character varying(24) NOT NULL,
    party_id                                bigint NOT NULL REFERENCES core.parties(party_id),
    country_id                              integer NOT NULL REFERENCES core.countries(country_id),
    state_id                                integer NOT NULL REFERENCES core.states(state_id),
    zip_code                                national character varying(12) NULL,
    address_line_1                          national character varying(128) NULL,   
    address_line_2                          national character varying(128) NULL,
    street                                  national character varying(128) NULL,
    city                                    national character varying(128) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX shipping_addresses_shipping_address_code_uix
ON core.shipping_addresses(UPPER(shipping_address_code), party_id);

CREATE TABLE core.tax_master
(
    tax_master_id                           SERIAL PRIMARY KEY,
    tax_master_code                         national character varying(12) NOT NULL,
    tax_master_name                         national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX tax_master_tax_master_code_uix
ON core.tax_master(UPPER(tax_master_code));

CREATE UNIQUE INDEX tax_master_tax_master_name_uix
ON core.tax_master(UPPER(tax_master_name));


CREATE TABLE core.tax_authorities
(
    tax_authority_id                        SERIAL PRIMARY KEY,
    tax_master_id                           integer NOT NULL REFERENCES core.tax_master(tax_master_id),
    tax_authority_code                      national character varying(12) NOT NULL,
    tax_authority_name                      national character varying(100) NOT NULL,
    country_id                              integer NOT NULL REFERENCES core.countries(country_id),
    state_id                                integer NULL REFERENCES core.states(state_id),
    zip_code                                national character varying(12) NULL,
    address_line_1                          national character varying(128) NULL,   
    address_line_2                          national character varying(128) NULL,
    street                                  national character varying(50) NULL,
    city                                    national character varying(50) NULL,
    phone                                   national character varying(100) NULL,
    fax                                     national character varying(24) NULL,
    cell                                    national character varying(24) NULL,
    email                                   national character varying(128) NULL,
    url                                     national character varying(50) NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX tax_authorities_tax_authority_code_uix
ON core.tax_authorities(UPPER(tax_authority_code));


CREATE UNIQUE INDEX tax_authorities_tax_authority_name_uix
ON core.tax_authorities(UPPER(tax_authority_name));

CREATE TABLE core.income_tax_setup
(
    income_tax_setup_id                     SERIAL NOT NULL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    effective_from                          date NOT NULL,
    tax_rate                                decimal_strict2 NOT NULL,
    tax_authority_id                        integer NOT NULL REFERENCES core.tax_authorities(tax_authority_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE INDEX income_tax_setup_office_id_inx
ON core.income_tax_setup(office_id);

CREATE TABLE core.sales_tax_types
(
    sales_tax_type_id                       SERIAL PRIMARY KEY,
    sales_tax_type_code                     national character varying(12) NOT NULL,
    sales_tax_type_name                     national character varying(50) NOT NULL,
    is_vat                                  boolean NOT NULL DEFAULT(false),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX sales_tax_types_sales_tax_type_code_uix
ON core.sales_tax_types(UPPER(sales_tax_type_code));

CREATE UNIQUE INDEX sales_tax_types_sales_tax_type_name_uix
ON core.sales_tax_types(UPPER(sales_tax_type_name));

CREATE INDEX sales_tax_types_is_vat_inx
ON core.sales_tax_types(is_vat);


CREATE TABLE core.tax_base_amount_types
(
    tax_base_amount_type_code               national character varying(12) PRIMARY KEY,--Should not be localized
    tax_base_amount_type_name               national character varying(50) NOT NULL
);

CREATE UNIQUE INDEX tax_base_amount_type_tax_base_amount_type_name_uix
ON core.tax_base_amount_types(UPPER(tax_base_amount_type_name));

CREATE TABLE core.tax_rate_types
(
    tax_rate_type_code                      national character varying(4) PRIMARY KEY,--Should not be localized
    tax_rate_type_name                      national character varying(50) NOT NULL
);

CREATE UNIQUE INDEX tax_rate_type_tax_rate_type_name_uix
ON core.tax_rate_types(UPPER(tax_rate_type_name));


CREATE TABLE core.rounding_methods
(
    rounding_method_code                    national character varying(4) PRIMARY KEY, --Should not be localized
    rounding_method_name                    national character varying(50) NOT NULL
);

CREATE UNIQUE INDEX rounding_methods_rounding_method_name_uix
ON core.rounding_methods(UPPER(rounding_method_name));



CREATE TABLE core.state_sales_taxes
(
    state_sales_tax_id                      SERIAL PRIMARY KEY,
    state_sales_tax_code                    character varying(12) NOT NULL,
    state_sales_tax_name                    character varying(100) NOT NULL,
    state_id                                integer NOT NULL REFERENCES core.states(state_id),
    entity_id                               integer NULL REFERENCES core.entities(entity_id),
    industry_id                             integer NULL REFERENCES core.industries(industry_id),
    item_group_id                           integer NULL /*REFERENCES core.item_groups(item_group_id)*/,        
    rate                                    decimal_strict2 NOT NULL DEFAULT(0),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX state_sales_taxes_state_sales_tax_code_uix
ON core.state_sales_taxes(UPPER(state_sales_tax_code));

CREATE UNIQUE INDEX state_sales_taxes_state_sales_tax_name_uix
ON core.state_sales_taxes(UPPER(state_sales_tax_name));

CREATE UNIQUE INDEX state_sales_taxes_state_id_entity_id_uix
ON core.state_sales_taxes(state_id, entity_id);

CREATE UNIQUE INDEX state_sales_taxes_state_id_industry_id_uix
ON core.state_sales_taxes(state_id, industry_id);

CREATE UNIQUE INDEX state_sales_taxes_state_id_item_group_id_uix
ON core.state_sales_taxes(state_id, item_group_id);

CREATE TABLE core.county_sales_taxes
(
    county_sales_tax_id                     SERIAL PRIMARY KEY,
    county_sales_tax_code                    character varying(12) NOT NULL,
    county_sales_tax_name                    character varying(100) NOT NULL,
    county_id                               integer REFERENCES core.counties(county_id),
    entity_id                               integer NULL REFERENCES core.entities(entity_id),
    industry_id                             integer NULL REFERENCES core.industries(industry_id),
    item_group_id                           integer NULL /*REFERENCES core.item_groups(item_group_id)*/,        
    rate                                    decimal_strict2 NOT NULL DEFAULT(0),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())

);


CREATE UNIQUE INDEX county_sales_taxes_county_sales_tax_code_uix
ON core.county_sales_taxes(UPPER(county_sales_tax_code));

CREATE UNIQUE INDEX county_sales_taxes_county_sales_tax_name_uix
ON core.county_sales_taxes(UPPER(county_sales_tax_name));

CREATE UNIQUE INDEX county_sales_taxes_county_id_entity_id_uix
ON core.county_sales_taxes(county_id, entity_id);

CREATE UNIQUE INDEX county_sales_taxes_county_id_industry_id_uix
ON core.county_sales_taxes(county_id, industry_id);

CREATE UNIQUE INDEX county_sales_taxes_county_id_item_group_id_uix
ON core.county_sales_taxes(county_id, item_group_id);

CREATE TABLE core.sales_taxes
(
    sales_tax_id                            SERIAL PRIMARY KEY,
    tax_master_id                           integer NOT NULL REFERENCES core.tax_master(tax_master_id),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    sales_tax_code                          national character varying(24) NOT NULL,
    sales_tax_name                          national character varying(50) NOT NULL,
    is_exemption                            boolean NOT NULL DEFAULT(false),        
    tax_base_amount_type_code               national character varying(12) NOT NULL 
                                            REFERENCES core.tax_base_amount_types(tax_base_amount_type_code)
                                            DEFAULT('P'),
    rate                                    decimal_strict2 NOT NULL DEFAULT(0), --Tax rate should be zero for parent tax.
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW()),
                                            CONSTRAINT taxes_is_exemption_chk
                                            CHECK
                                            (                                            
                                                CASE WHEN is_exemption = true THEN rate = 0 END
                                            )
);

CREATE UNIQUE INDEX sales_taxes_sales_tax_code_uix
ON core.sales_taxes(office_id, UPPER(sales_tax_code));

CREATE UNIQUE INDEX sales_taxes_sales_tax_name_uix
ON core.sales_taxes(office_id, UPPER(sales_tax_name));

CREATE TABLE core.sales_tax_details
(
    sales_tax_detail_id                     SERIAL PRIMARY KEY,
    sales_tax_id                            integer NOT NULL REFERENCES core.sales_taxes(sales_tax_id),
    sales_tax_type_id                       integer NOT NULL REFERENCES core.sales_tax_types(sales_tax_type_id),
    priority                                smallint NOT NULL DEFAULT(0),
    sales_tax_detail_code                   national character varying(24) NOT NULL,
    sales_tax_detail_name                   national character varying(50) NOT NULL,
    based_on_shipping_address               boolean NOT NULL DEFAULT(true),
    check_nexus                             boolean NOT NULL DEFAULT(true),
    applied_on_shipping_charge              boolean NOT NULL DEFAULT(true),
    state_sales_tax_id                      integer NULL REFERENCES core.state_sales_taxes(state_sales_tax_id),
    county_sales_tax_id                     integer NULL REFERENCES core.county_sales_taxes(county_sales_tax_id),
    tax_rate_type_code                      national character varying(12) NOT NULL 
                                            REFERENCES core.tax_rate_types(tax_rate_type_code)
                                            DEFAULT('P'),
    rate                                    decimal_strict2 NOT NULL
                                            CONSTRAINT sales_tax_details_rate_chk CHECK
                                            (
                                                CASE 
                                                    WHEN
                                                        (
                                                            state_sales_tax_id IS NOT NULL 
                                                            OR
                                                            county_sales_tax_id IS NOT NULL
                                                        )
                                                    THEN 
                                                        rate = 0 
                                                    ELSE 
                                                        rate > 0 
                                                    END
                                            ),
    reporting_tax_authority_id              integer NOT NULL REFERENCES core.tax_authorities(tax_authority_id),
    collecting_tax_authority_id             integer NOT NULL REFERENCES core.tax_authorities(tax_authority_id),
    collecting_account_id                   bigint NOT NULL REFERENCES core.accounts(account_id),
    use_tax_collecting_account_id           bigint NULL REFERENCES core.accounts(account_id),
    rounding_method_code                    national character varying(4) NULL REFERENCES core.rounding_methods(rounding_method_code),
    rounding_decimal_places                 integer_strict2 NOT NULL DEFAULT(2),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX sales_tax_details_sales_tax_detail_code_uix
ON core.sales_tax_details(UPPER(sales_tax_detail_code));

CREATE UNIQUE INDEX sales_tax_details_sales_tax_detail_name_uix
ON core.sales_tax_details(UPPER(sales_tax_detail_name));



CREATE TABLE core.tax_exempt_types
(
    tax_exempt_type_id                      SERIAL PRIMARY KEY,
    tax_exempt_type_code                    national character varying(12) NOT NULL,
    tax_exempt_type_name                    national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX tax_exempt_types_tax_exempt_type_code_uix
ON core.tax_exempt_types(UPPER(tax_exempt_type_code));

CREATE UNIQUE INDEX tax_exempt_types_tax_exempt_type_name_uix
ON core.tax_exempt_types(UPPER(tax_exempt_type_name));


CREATE TABLE core.sales_tax_exempts
(
    sales_tax_exempt_id                     SERIAL PRIMARY KEY,
    tax_master_id                           integer NOT NULL REFERENCES core.tax_master(tax_master_id),
    sales_tax_exempt_code                   national character varying(12),
    sales_tax_exempt_name                   national character varying(100),
    tax_exempt_type_id                      integer NOT NULL REFERENCES core.tax_exempt_types(tax_exempt_type_id),
    store_id                                integer NOT NULL,
    sales_tax_id                            integer NOT NULL REFERENCES core.sales_taxes(sales_tax_id),
    valid_from                              date NOT NULL,
    valid_till                              date NOT NULL,
                                            CONSTRAINT sales_tax_exempts_valid_till_chk 
                                            CHECK(valid_till >= valid_from),
    price_from                              money_strict2 NOT NULL DEFAULT(0),
    price_to                                money_strict2 NOT NULL DEFAULT(0),
                                            CONSTRAINT sales_tax_exempts_price_to_chk 
                                            CHECK(price_to >= price_from),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX sales_tax_exempts_sales_tax_exempt_code_uix
ON core.sales_tax_exempts(UPPER(sales_tax_exempt_code));

CREATE UNIQUE INDEX sales_tax_exempts_sales_tax_exempt_name_uix
ON core.sales_tax_exempts(UPPER(sales_tax_exempt_name));


CREATE TABLE core.sales_tax_exempt_details
(
    sales_tax_exempt_detail_id              SERIAL PRIMARY KEY,
    sales_tax_exempt_id                     integer NOT NULL REFERENCES core.sales_tax_exempts(sales_tax_exempt_id),
    entity_id                               integer NULL REFERENCES core.entities(entity_id),
    industry_id                             integer NULL REFERENCES core.industries(industry_id),    
    party_id                                bigint NULL REFERENCES core.parties(party_id),
    party_type_id                           integer NULL REFERENCES core.party_types(party_type_id),
    item_id                                 integer NULL /*REFERENCES core.items(item_id)*/,
    item_group_id                           integer NULL /*REFERENCES core.item_groups(item_group_id)*/, --Create trigger to disallow adding item group which is not allowed in sales.
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL
                                            DEFAULT(NOW())
);


CREATE TABLE core.brands
(
    brand_id SERIAL                         PRIMARY KEY,
    brand_code                              national character varying(12) NOT NULL,
    brand_name                              national character varying(150) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX brands_brand_code_uix
ON core.brands(UPPER(brand_code));

CREATE UNIQUE INDEX brands_brand_name_uix
ON core.brands(UPPER(brand_name));



CREATE TABLE core.shippers
(
    shipper_id                              SERIAL PRIMARY KEY,
    shipper_code                            national character varying(12) NULL,
    company_name                            national character varying(128) NOT NULL,
    shipper_name                            national character varying(150) NULL,
    po_box                                  national character varying(128) NULL,
    address_line_1                          national character varying(128) NULL,   
    address_line_2                          national character varying(128) NULL,
    street                                  national character varying(50) NULL,
    city                                    national character varying(50) NULL,
    state                                   national character varying(50) NULL,
    country                                 national character varying(50) NULL,
    phone                                   national character varying(50) NULL,
    fax                                     national character varying(50) NULL,
    cell                                    national character varying(50) NULL,
    email                                   national character varying(128) NULL,
    url                                     national character varying(50) NULL,
    contact_person                          national character varying(50) NULL,
    contact_po_box                          national character varying(128) NULL,
    contact_address_line_1                  national character varying(128) NULL,   
    contact_address_line_2                  national character varying(128) NULL,
    contact_street                          national character varying(50) NULL,
    contact_city                            national character varying(50) NULL,
    contact_state                           national character varying(50) NULL,
    contact_country                         national character varying(50) NULL,
    contact_email                           national character varying(128) NULL,
    contact_phone                           national character varying(50) NULL,
    contact_cell                            national character varying(50) NULL,
    factory_address                         national character varying(250) NULL,
    pan_number                              national character varying(50) NULL,
    sst_number                              national character varying(50) NULL,
    cst_number                              national character varying(50) NULL,
    account_id                              bigint NOT NULL REFERENCES core.accounts(account_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                              
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX shippers_shipper_code_uix
ON core.shippers(UPPER(shipper_code));

CREATE TABLE core.item_types
(
    item_type_id                            SERIAL PRIMARY KEY,
    item_type_code                          national character varying(12) NOT NULL,
    item_type_name                          national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX item_type_item_type_code_uix
ON core.item_types(UPPER(item_type_code));


CREATE UNIQUE INDEX item_type_item_type_name_uix
ON core.item_types(UPPER(item_type_name));

CREATE TABLE core.item_groups
(
    item_group_id                           SERIAL PRIMARY KEY,
    item_group_code                         national character varying(12) NOT NULL,
    item_group_name                         national character varying(50) NOT NULL,
    exclude_from_purchase                   boolean NOT NULL   
                                            CONSTRAINT item_groups_exclude_from_purchase_df   
                                            DEFAULT(false),
    exclude_from_sales                      boolean NOT NULL   --Todo: Create trigger to disallow switching this on when table "core.sales_tax_exempt_details" depends on it.
                                            CONSTRAINT item_groups_exclude_from_sales_df   
                                            DEFAULT(false),
    sales_tax_id                            integer NOT NULL REFERENCES core.sales_taxes(sales_tax_id),
    sales_account_id                        bigint NOT NULL REFERENCES core.accounts(account_id),
    sales_discount_account_id               bigint NOT NULL REFERENCES core.accounts(account_id),
    sales_return_account_id                 bigint NOT NULL REFERENCES core.accounts(account_id),
    purchase_account_id                     bigint NOT NULL REFERENCES core.accounts(account_id),
    purchase_discount_account_id            bigint NOT NULL REFERENCES core.accounts(account_id),
    inventory_account_id                    bigint NOT NULL REFERENCES core.accounts(account_id),
    cost_of_goods_sold_account_id           bigint NOT NULL REFERENCES core.accounts(account_id),    
    parent_item_group_id                    integer NULL REFERENCES core.item_groups(item_group_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

ALTER TABLE core.sales_tax_exempt_details
ADD FOREIGN KEY(item_group_id) REFERENCES core.item_groups(item_group_id);


ALTER TABLE core.state_sales_taxes
ADD FOREIGN KEY(item_group_id) REFERENCES core.item_groups(item_group_id);

ALTER TABLE core.county_sales_taxes
ADD FOREIGN KEY(item_group_id) REFERENCES core.item_groups(item_group_id);


CREATE UNIQUE INDEX item_groups_item_group_code_uix
ON core.item_groups(UPPER(item_group_code));

CREATE UNIQUE INDEX item_groups_item_group_name_uix
ON core.item_groups(UPPER(item_group_name));



CREATE TABLE core.shipping_mail_types
(
    shipping_mail_type_id                   SERIAL PRIMARY KEY,
    shipping_mail_type_code                 national character varying(12) NOT NULL,
    shipping_mail_type_name                 national character varying(64) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX shipping_mail_types_shipping_mail_type_code_uix
ON core.shipping_mail_types(UPPER(shipping_mail_type_code));

CREATE UNIQUE INDEX shipping_mail_types_shipping_mail_type_name_uix
ON core.shipping_mail_types(UPPER(shipping_mail_type_name));






CREATE TABLE core.shipping_package_shapes
(
    shipping_package_shape_id               SERIAL PRIMARY KEY,
    shipping_package_shape_code             national character varying(12) NOT NULL,
    shipping_package_shape_name             national character varying(64) NOT NULL,
    is_rectangular                          boolean NOT NULL   
                                            DEFAULT(false),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())    
);



CREATE UNIQUE INDEX shipping_package_shapes_shipping_package_shape_code_uix
ON core.shipping_package_shapes(UPPER(shipping_package_shape_code));

CREATE UNIQUE INDEX shipping_package_shapes_shipping_package_shape_name_uix
ON core.shipping_package_shapes(UPPER(shipping_package_shape_name));


CREATE TABLE core.items
(
    item_id                                 SERIAL PRIMARY KEY,
    item_code                               national character varying(12) NOT NULL,
    item_name                               national character varying(150) NOT NULL,
    item_group_id                           integer NOT NULL REFERENCES core.item_groups(item_group_id),
    item_type_id                            integer NOT NULL REFERENCES core.item_types(item_type_id),
    brand_id                                integer NOT NULL REFERENCES core.brands(brand_id),
    preferred_supplier_id                   bigint NOT NULL REFERENCES core.parties(party_id),
    lead_time_in_days                       integer NOT NULL   
                                            DEFAULT(0),
    weight_in_grams                         float NOT NULL   
                                            DEFAULT(0),  
    width_in_centimeters                    float NOT NULL   
                                            DEFAULT(0),
    height_in_centimeters                   float NOT NULL   
                                            DEFAULT(0),
    length_in_centimeters                   float NOT NULL   
                                            DEFAULT(0),
    machinable                              boolean NOT NULL   
                                            DEFAULT(false),
    preferred_shipping_mail_type_id         integer NULL REFERENCES core.shipping_mail_types(shipping_mail_type_id),
    shipping_package_shape_id               integer NULL REFERENCES core.shipping_package_shapes(shipping_package_shape_id),    
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    hot_item                                boolean NOT NULL,
    cost_price                              money_strict NOT NULL,
    cost_price_includes_tax                 boolean NOT NULL   
                                            CONSTRAINT items_cost_price_includes_tax_df                                               
                                            DEFAULT(false),
    selling_price                           money_strict NOT NULL,
    selling_price_includes_tax              boolean NOT NULL   
                                            CONSTRAINT items_selling_price_includes_tax_df 
                                            DEFAULT(false),
    sales_tax_id                            integer NOT NULL REFERENCES core.sales_taxes(sales_tax_id),
    reorder_unit_id                         integer NOT NULL REFERENCES core.units(unit_id),
    reorder_level                           integer NOT NULL,
    reorder_quantity                        integer NOT NULL
                                            CONSTRAINT items_reorder_quantity_df
                                            DEFAULT(0),
    maintain_stock                          boolean NOT NULL   
                                            DEFAULT(true),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);

ALTER TABLE core.sales_tax_exempt_details
ADD FOREIGN KEY(item_id) REFERENCES core.items(item_id);


CREATE UNIQUE INDEX items_item_name_uix
ON core.items(UPPER(item_name));

CREATE TABLE core.compound_items
(
    compound_item_id                        SERIAL PRIMARY KEY,
    compound_item_code                      national character varying(12) NOT NULL,
    compound_item_name                      national character varying(150) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())        
);

CREATE UNIQUE INDEX compound_items_compound_item_code_uix
ON core.compound_items(LOWER(compound_item_code));


CREATE UNIQUE INDEX compound_items_compound_item_name_uix
ON core.compound_items(LOWER(compound_item_name));

CREATE TABLE core.compound_item_details
(
    compound_item_detail_id                 SERIAL PRIMARY KEY,
    compound_item_id                        integer NOT NULL REFERENCES core.compound_items(compound_item_id),
    item_id                                 integer NOT NULL REFERENCES core.items(item_id),
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    quantity                                integer_strict NOT NULL,
    price                                   money_strict NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())        
);

CREATE UNIQUE INDEX compound_item_details_item_id_uix
ON core.compound_item_details(compound_item_id, item_id);


CREATE TABLE core.late_fee
(
    late_fee_id                                 SERIAL NOT NULL PRIMARY KEY,
    late_fee_code                               national character varying(12) NOT NULL,
    late_fee_name                               national character varying(50) NOT NULL,
    is_flat_amount                              boolean NOT NULL CONSTRAINT late_fee_is_flat_amount_df DEFAULT(false),
    rate                                        decimal(24, 4) NOT NULL,
    audit_user_id                               integer NULL REFERENCES office.users(user_id),
    audit_ts                                    TIMESTAMP WITH TIME ZONE NULL 
                                                DEFAULT(NOW())
);

CREATE UNIQUE INDEX late_fee_late_fee_code_uix
ON core.late_fee(UPPER(late_fee_code));

CREATE UNIQUE INDEX late_fee_late_fee_name_uix
ON core.late_fee(UPPER(late_fee_name));

CREATE INDEX late_fee_is_flat_amount_inx
ON core.late_fee(is_flat_amount);


CREATE TABLE core.payment_terms
(
    payment_term_id                             SERIAL NOT NULL PRIMARY KEY,
    payment_term_code                           national character varying(12) NOT NULL,
    payment_term_name                           national character varying(50) NOT NULL,
    due_on_date                                 boolean NOT NULL 
                                                CONSTRAINT payment_terms_due_on_specific_date_df DEFAULT(false),
    due_days                                    integer NOT NULL CONSTRAINT payment_terms_days_df DEFAULT(0),
    due_frequency_id                            integer NULL REFERENCES core.frequencies(frequency_id)
                                                CHECK
                                                (
                                                    CASE WHEN due_frequency_id IS NOT NULL THEN due_days = 0 END
                                                ),
    grace_peiod                                 integer NOT NULL CONSTRAINT payment_terms_grace_period_df DEFAULT(0),
    late_fee_id                                 integer NULL REFERENCES core.late_fee(late_fee_id),
    late_fee_posting_frequency_id               integer NULL REFERENCES core.frequencies(frequency_id)
                                                CONSTRAINT payment_terms_late_fee_chk
                                                CHECK
                                                (
                                                    (late_fee_id IS NULL)::integer + 
                                                    (late_fee_posting_frequency_id IS NULL)::integer IN
                                                    (
                                                        0, 2
                                                    )--Either every late fee information should be provided or none.
                                                ),
    audit_user_id                               integer NULL REFERENCES office.users(user_id),
    audit_ts                                    TIMESTAMP WITH TIME ZONE NULL   
                                                DEFAULT(NOW())        
);


CREATE UNIQUE INDEX payment_terms_payment_term_code_uix
ON core.payment_terms(UPPER(payment_term_code));

CREATE UNIQUE INDEX payment_terms_payment_term_name_uix
ON core.payment_terms(UPPER(payment_term_name));

CREATE INDEX payment_terms_due_on_date_inx
ON core.payment_terms(due_on_date);


CREATE INDEX payment_terms_due_frequency_id_inx
ON core.payment_terms(due_frequency_id);



CREATE TABLE core.recurring_invoices
(
    recurring_invoice_id                        SERIAL NOT NULL PRIMARY KEY,
    recurring_invoice_code                      national character varying(12) NOT NULL,
    recurring_invoice_name                      national character varying(50) NOT NULL,
    item_id                                     integer NULL REFERENCES core.items(item_id),
    compound_item_id                            integer NULL REFERENCES core.compound_items(compound_item_id)
                                                CONSTRAINT recurring_invoices_item_chk
                                                CHECK
                                                (
                                                    (item_id IS NULL)::integer + (compound_item_id IS NULL)::integer = 1 --Only one of these two can be NOT NULL.
                                                ),
    recurring_frequency_id                      integer NOT NULL REFERENCES core.frequencies(frequency_id),
    recurring_amount                            money_strict NOT NULL 
                                                CONSTRAINT recurring_invoices_recurring_amount_chk 
                                                CHECK(recurring_amount > 0),
    auto_trigger_on_sales                       boolean NOT NULL,
    audit_user_id                               integer NULL REFERENCES office.users(user_id),
    audit_ts                                    TIMESTAMP WITH TIME ZONE NULL 
                                                DEFAULT(NOW())    
);

CREATE UNIQUE INDEX recurring_invoices_item_id_auto_trigger_on_sales_uix
ON core.recurring_invoices(item_id, auto_trigger_on_sales)
WHERE auto_trigger_on_sales = true;

CREATE UNIQUE INDEX recurring_invoices_compound_item_id_auto_trigger_on_sales_uix
ON core.recurring_invoices(compound_item_id, auto_trigger_on_sales)
WHERE auto_trigger_on_sales = true;


CREATE TABLE core.recurring_invoice_setup
(
    recurring_invoice_setup_id                  SERIAL NOT NULL PRIMARY KEY,
    recurring_invoice_id                        integer NOT NULL REFERENCES core.recurring_invoices(recurring_invoice_id),
    party_id                                    bigint NOT NULL REFERENCES core.parties(party_id),
    starts_from                                 date NOT NULL,
    ends_on                                     date NOT NULL
                                                CONSTRAINT recurring_invoice_setup_date_chk
                                                CHECK
                                                (
                                                    ends_on >= starts_from
                                                ),
    recurring_amount                            money_strict NOT NULL 
                                                CONSTRAINT recurring_invoice_setup_recurring_amount_chk
                                                CHECK(recurring_amount > 0),
    payment_term_id                             integer NOT NULL REFERENCES core.payment_terms(payment_term_id),
    audit_user_id                               integer NULL REFERENCES office.users(user_id),
    audit_ts                                    TIMESTAMP WITH TIME ZONE NULL 
                                                DEFAULT(NOW())    
    
);

/*******************************************************************
    PLEASE NOTE :

    THESE ARE THE MOST EFFECTIVE STOCK ITEM PRICES.
    THE PRICE IN THIS CATALOG IS ACTUALLY
    PICKED UP AT THE TIME OF PURCHASE AND SALES.

    A STOCK ITEM PRICE MAY BE DIFFERENT FOR DIFFERENT UNITS.
    FURTHER, A STOCK ITEM WOULD BE SOLD AT A HIGHER PRICE
    WHEN SOLD LOOSE THAN WHAT IT WOULD ACTUALLY COST IN A
    COMPOUND UNIT.

    EXAMPLE, ONE CARTOON (20 BOTTLES) OF BEER BOUGHT AS A UNIT
    WOULD COST 25% LESS FROM THE SAME STORE.

*******************************************************************/

CREATE TABLE core.item_selling_prices
(   
    item_selling_price_id                   BIGSERIAL PRIMARY KEY,
    item_id                                 integer NOT NULL REFERENCES core.items(item_id),
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    party_type_id                           integer NULL REFERENCES core.party_types(party_type_id), 
    price_type_id                           integer NULL REFERENCES core.price_types(price_type_id),
    includes_tax                            boolean NOT NULL   
                                            CONSTRAINT item_selling_prices_includes_tax_df   
                                            DEFAULT('No'),
    price                                   money_strict NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);




CREATE TABLE core.item_cost_prices
(   
    item_cost_price_id                      BIGSERIAL PRIMARY KEY,
    item_id                                 integer NOT NULL REFERENCES core.items(item_id),
    entry_ts                                TIMESTAMP WITH TIME ZONE NOT NULL   
                                            DEFAULT(NOW()),
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    party_id                                bigint NULL REFERENCES core.parties(party_id),
    lead_time_in_days                       integer NOT NULL   
                                            DEFAULT(0),
    includes_tax                            boolean NOT NULL   
                                            CONSTRAINT item_cost_prices_includes_tax_df   
                                            DEFAULT('No'),
    price                                   money_strict NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);



CREATE TABLE office.store_types
(
    store_type_id                           SERIAL PRIMARY KEY,
    store_type_code                         national character varying(12) NOT NULL,
    store_type_name                         national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX store_types_code_uix
ON office.store_types(UPPER(store_type_code));


CREATE UNIQUE INDEX store_types_name_uix
ON office.store_types(UPPER(store_type_name));




CREATE TABLE office.cash_repositories
(
    cash_repository_id                      SERIAL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    cash_repository_code                    national character varying(12) NOT NULL,
    cash_repository_name                    national character varying(50) NOT NULL,
    parent_cash_repository_id               integer NULL REFERENCES office.cash_repositories(cash_repository_id),
    description                             national character varying(100) NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX cash_repositories_cash_repository_code_uix
ON office.cash_repositories(office_id, UPPER(cash_repository_code));

CREATE UNIQUE INDEX cash_repositories_cash_repository_name_uix
ON office.cash_repositories(office_id, UPPER(cash_repository_name));



CREATE TABLE office.stores
(
    store_id                                SERIAL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    store_code                              national character varying(12) NOT NULL,
    store_name                              national character varying(50) NOT NULL,
    address                                 national character varying(50) NULL,
    store_type_id                           integer NOT NULL REFERENCES office.store_types(store_type_id),
    allow_sales                             boolean NOT NULL   
                                            DEFAULT(true),
    sales_tax_id                            integer NOT NULL REFERENCES core.sales_taxes(sales_tax_id),
    default_cash_account_id                 bigint NOT NULL REFERENCES core.accounts(account_id),
    default_cash_repository_id              integer NOT NULL REFERENCES office.cash_repositories(cash_repository_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


ALTER TABLE core.sales_tax_exempts
ADD FOREIGN KEY(store_id) REFERENCES office.stores(store_id);

CREATE UNIQUE INDEX stores_store_code_uix
ON office.stores(office_id, UPPER(store_code));

CREATE UNIQUE INDEX stores_store_name_uix
ON office.stores(office_id, UPPER(store_name));


 
CREATE TABLE office.counters
(
    counter_id                              SERIAL PRIMARY KEY,
    store_id                                integer NOT NULL REFERENCES office.stores(store_id),
    cash_repository_id                      integer NOT NULL REFERENCES office.cash_repositories(cash_repository_id),
    counter_code                            national character varying(12) NOT NULL,
    counter_name                            national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX counters_counter_code_uix
ON office.counters(UPPER(counter_code));

CREATE UNIQUE INDEX counters_counter_name_uix
ON office.counters(UPPER(counter_name));


CREATE TABLE office.cost_centers
(
    cost_center_id                          SERIAL PRIMARY KEY,
    cost_center_code                        national character varying(24) NOT NULL,
    cost_center_name                        national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX cost_centers_cost_center_code_uix
ON office.cost_centers(UPPER(cost_center_code));

CREATE UNIQUE INDEX cost_centers_cost_center_name_uix
ON office.cost_centers(UPPER(cost_center_name));


CREATE TABLE office.cashiers
(
    cashier_id                              BIGSERIAL PRIMARY KEY,
    counter_id                              integer NOT NULL REFERENCES office.counters(counter_id),
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    assigned_by_user_id                     integer NOT NULL REFERENCES office.users(user_id),
    transaction_date                        date NOT NULL,
    closed                                  boolean NOT NULL
);

CREATE UNIQUE INDEX Cashiers_user_id_TDate_uix
ON office.cashiers(user_id ASC, transaction_date DESC);


/*******************************************************************
    STORE POLICY DEFINES THE RIGHT OF USERS TO ACCESS A STORE.
    AN ADMINISTRATOR CAN ACCESS ALL THE stores, BY DEFAULT.
*******************************************************************/

CREATE TABLE policy.store_policies
(
    store_policy_id                         BIGSERIAL PRIMARY KEY,
    written_by_user_id                      integer NOT NULL REFERENCES office.users(user_id),
    status                                  boolean NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE TABLE policy.store_policy_details
(
    store_policy_detail_id                  BIGSERIAL PRIMARY KEY,
    store_policy_id                         bigint NOT NULL REFERENCES policy.store_policies(store_policy_id),
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    store_id                                integer NOT NULL REFERENCES office.stores(store_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE TABLE transactions.transaction_master
(
    transaction_master_id                   BIGSERIAL PRIMARY KEY,
    transaction_counter                     integer NOT NULL, --Sequence of transactions of a date
    transaction_code                        national character varying(50) NOT NULL,
    book                                    national character varying(50) NOT NULL, --Transaction book. Ex. Sales, Purchase, Journal
    value_date                              date NOT NULL,
    transaction_ts                          TIMESTAMP WITH TIME ZONE NOT NULL   
                                            DEFAULT(NOW()),
    login_id                                bigint NOT NULL REFERENCES audit.logins(login_id),
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    sys_user_id                             integer NULL REFERENCES office.users(user_id),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    cost_center_id                          integer NULL REFERENCES office.cost_centers(cost_center_id),
    reference_number                        national character varying(24) NULL,
    statement_reference                     text NULL,
    last_verified_on                        TIMESTAMP WITH TIME ZONE NULL, 
    verified_by_user_id                     integer NULL REFERENCES office.users(user_id),
    verification_status_id                  smallint NOT NULL REFERENCES core.verification_statuses(verification_status_id)   
                                            DEFAULT(0/*Awaiting verification*/),
    verification_reason                     national character varying(128) NOT NULL   
                                            CONSTRAINT transaction_master_verification_reason_df   
                                            DEFAULT(''),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL                                               
                                            DEFAULT(NOW()),
                                            CONSTRAINT transaction_master_login_id_sys_user_id_chk
                                                CHECK
                                                (
                                                    (
                                                        login_id IS NULL AND sys_user_id IS NOT NULL
                                                    )

                                                    OR

                                                    (
                                                        login_id IS NOT NULL AND sys_user_id IS NULL
                                                    )
                                                )
);

CREATE UNIQUE INDEX transaction_master_transaction_code_uix
ON transactions.transaction_master(UPPER(transaction_code));



CREATE TABLE transactions.transaction_details
(
    transaction_detail_id                   BIGSERIAL PRIMARY KEY,
    transaction_master_id                   bigint NOT NULL REFERENCES transactions.transaction_master(transaction_master_id),
    value_date                              date NOT NULL,
    tran_type                               transaction_type NOT NULL,
    account_id                              bigint NOT NULL REFERENCES core.accounts(account_id),
    statement_reference                     text NULL,
    cash_repository_id                      integer NULL REFERENCES office.cash_repositories(cash_repository_id),
    currency_code                           national character varying(12) NULL REFERENCES core.currencies(currency_code),
    amount_in_currency                      money_strict NOT NULL,
    local_currency_code                     national character varying(12) NULL REFERENCES core.currencies(currency_code),
    er                                      decimal_strict NOT NULL,
    amount_in_local_currency                money_strict NOT NULL,  
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE TABLE transactions.customer_receipts
(
    receipt_id                              BIGSERIAL PRIMARY KEY,
    transaction_master_id                   bigint NOT NULL REFERENCES transactions.transaction_master(transaction_master_id),
    party_id                                bigint NOT NULL REFERENCES core.parties(party_id),
    currency_code                           national character varying(12) NOT NULL REFERENCES core.currencies(currency_code),
    amount                                  money_strict NOT NULL,
    er_debit                                decimal_strict NOT NULL,
    er_credit                               decimal_strict NOT NULL,
    cash_repository_id                      integer NULL REFERENCES office.cash_repositories(cash_repository_id),
    posted_date                             date NULL,
    bank_account_id                         bigint NULL REFERENCES core.bank_accounts(account_id),
    bank_instrument_code                    national character varying(128) NULL   
                                            CONSTRAINT customer_receipt_bank_instrument_code_df   
                                            DEFAULT(''),
    bank_tran_code                          national character varying(128) NULL   
                                            CONSTRAINT customer_receipt_bank_tran_code_df   
                                            DEFAULT('')
);

CREATE INDEX customer_receipts_transaction_master_id_inx
ON transactions.customer_receipts(transaction_master_id);

CREATE INDEX customer_receipts_party_id_inx
ON transactions.customer_receipts(party_id);

CREATE INDEX customer_receipts_currency_code_inx
ON transactions.customer_receipts(currency_code);

CREATE INDEX customer_receipts_cash_repository_id_inx
ON transactions.customer_receipts(cash_repository_id);

CREATE INDEX customer_receipts_posted_date_inx
ON transactions.customer_receipts(posted_date);

CREATE INDEX customer_receipts_bank_account_id_inx
ON transactions.customer_receipts(bank_account_id);


CREATE TABLE transactions.stock_master
(
    stock_master_id                         BIGSERIAL PRIMARY KEY,
    transaction_master_id                   bigint NOT NULL REFERENCES transactions.transaction_master(transaction_master_id),
    value_date                              date NOT NULL,
    party_id                                bigint NULL REFERENCES core.parties(party_id),
    salesperson_id                          integer NULL REFERENCES core.salespersons(salesperson_id),
    price_type_id                           integer NULL REFERENCES core.price_types(price_type_id),
    is_credit                               boolean NOT NULL   
                                            CONSTRAINT stock_master_is_credit_df   
                                            DEFAULT(false),
    payment_term_id                         integer NULL REFERENCES core.payment_terms(payment_term_id),
    shipper_id                              integer NULL REFERENCES core.shippers(shipper_id),
    shipping_address_id                     bigint NULL REFERENCES core.shipping_addresses(shipping_address_id),
    shipping_charge                         money_strict2 NOT NULL   
                                            CONSTRAINT stock_master_shipping_charge_df   
                                            DEFAULT(0),
    store_id                                integer NULL REFERENCES office.stores(store_id),
    non_taxable                             boolean NOT NULL DEFAULT(false),
    cash_repository_id                      integer NULL REFERENCES office.cash_repositories(cash_repository_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX stock_master_transaction_master_id_uix
ON transactions.stock_master(transaction_master_id);


CREATE TABLE transactions.stock_details
(
    stock_detail_id                         BIGSERIAL PRIMARY KEY,
    value_date                              date NOT NULL,
    stock_master_id                         bigint NOT NULL REFERENCES transactions.stock_master(stock_master_id),
    tran_type                               transaction_type NOT NULL,
    store_id                                integer NULL REFERENCES office.stores(store_id),
    item_id                                 integer NOT NULL REFERENCES core.items(item_id),
    quantity                                integer NOT NULL,
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    base_quantity                           decimal NOT NULL,
    base_unit_id                            integer NOT NULL REFERENCES core.units(unit_id),
    price                                   money_strict NOT NULL,
    cost_of_goods_sold                      money_strict2 NOT NULL DEFAULT(0),
    discount                                money_strict2 NOT NULL   
                                            CONSTRAINT stock_details_discount_df   
                                            DEFAULT(0),
    shipping_charge                         money_strict2 NOT NULL   
                                            CONSTRAINT stock_master_shipping_charge_df   
                                            DEFAULT(0),
    sales_tax_id                            integer NULL REFERENCES core.sales_taxes(sales_tax_id),
    tax                                     money_strict2 NOT NULL   
                                            CONSTRAINT stock_details_tax_df   
                                            DEFAULT(0)
                                            CONSTRAINT stock_details_tax_chk
                                            CHECK(CASE WHEN tax > 0 THEN sales_tax_id IS NOT NULL END),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE TABLE transactions.stock_tax_details
(
    stock_detail_id                         bigint NOT NULL REFERENCES transactions.stock_details(stock_detail_id),
    sales_tax_detail_id                     integer NOT NULL REFERENCES core.sales_tax_details(sales_tax_detail_id),
    state_sales_tax_id                      integer NULL REFERENCES core.state_sales_taxes(state_sales_tax_id),
    county_sales_tax_id                     integer NULL REFERENCES core.county_sales_taxes(county_sales_tax_id),
    principal                               money_strict NOT NULL,
    rate                                    decimal_strict NOT NULL,
    tax                                     money_strict NOT NULL
);


CREATE TABLE transactions.stock_return
(
    sales_return_id                         BIGSERIAL PRIMARY KEY, 
    transaction_master_id                   bigint NOT NULL REFERENCES transactions.transaction_master(transaction_master_id),
    return_transaction_master_id            bigint NOT NULL REFERENCES transactions.transaction_master(transaction_master_id)
);

CREATE TABLE transactions.non_gl_stock_master
(
    non_gl_stock_master_id                  BIGSERIAL PRIMARY KEY,
    value_date                              date NOT NULL,
    book                                    national character varying(48) NOT NULL,
    party_id                                bigint NULL REFERENCES core.parties(party_id),
    price_type_id                           integer NULL REFERENCES core.price_types(price_type_id),
    transaction_ts                          TIMESTAMP WITH TIME ZONE NOT NULL   
                                            DEFAULT(NOW()),
    login_id                                bigint NOT NULL REFERENCES audit.logins(login_id),
    user_id                                 integer NOT NULL REFERENCES office.users(user_id),
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    reference_number                        national character varying(24) NULL,
    statement_reference                     text NULL,
    non_taxable                             boolean NOT NULL DEFAULT(false),
    salesperson_id                          integer NULL REFERENCES core.salespersons(salesperson_id),
    shipper_id                              integer NULL REFERENCES core.shippers(shipper_id),
    shipping_address_id                     bigint NULL REFERENCES core.shipping_addresses(shipping_address_id),
    shipping_charge                         money_strict2 NOT NULL   
                                            CONSTRAINT stock_master_shipping_charge_df   
                                            DEFAULT(0),
    store_id                                integer NULL REFERENCES office.stores(store_id),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE TABLE transactions.non_gl_stock_details
(
    non_gl_stock_detail_id                  BIGSERIAL PRIMARY KEY,
    non_gl_stock_master_id                  bigint NOT NULL REFERENCES transactions.non_gl_stock_master(non_gl_stock_master_id),
    value_date                              date NOT NULL,
    item_id                                 integer NOT NULL REFERENCES core.items(item_id),
    quantity                                integer NOT NULL,
    unit_id                                 integer NOT NULL REFERENCES core.units(unit_id),
    base_quantity                           decimal NOT NULL,
    base_unit_id                            integer NOT NULL REFERENCES core.units(unit_id),
    price                                   money_strict NOT NULL,
    discount                                money_strict2 NOT NULL   
                                            CONSTRAINT non_gl_stock_details_discount_df   
                                            DEFAULT(0),
    shipping_charge                         money_strict2 NOT NULL   
                                            CONSTRAINT stock_master_shipping_charge_df   
                                            DEFAULT(0),
    sales_tax_id                            integer NULL REFERENCES core.sales_taxes(sales_tax_id),
    tax                                     money_strict2 NOT NULL   
                                            CONSTRAINT stock_details_tax_df   
                                            DEFAULT(0)
                                            CONSTRAINT stock_details_tax_chk
                                            CHECK(CASE WHEN tax > 0 THEN sales_tax_id IS NOT NULL END),
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE TABLE transactions.non_gl_stock_tax_details
(
    non_gl_stock_detail_id                  bigint NOT NULL REFERENCES transactions.non_gl_stock_details(non_gl_stock_detail_id),
    sales_tax_detail_id                     integer NOT NULL REFERENCES core.sales_tax_details(sales_tax_detail_id),
    state_sales_tax_id                      integer NULL REFERENCES core.state_sales_taxes(state_sales_tax_id),
    county_sales_tax_id                     integer NULL REFERENCES core.county_sales_taxes(county_sales_tax_id),
    principal                               money_strict NOT NULL,
    rate                                    decimal_strict NOT NULL,
    tax                                     money_strict NOT NULL
);



--This table stores information of quotations
--which were upgraded to order(s).
CREATE TABLE transactions.non_gl_stock_master_relations
(
    non_gl_stock_master_relation_id         BIGSERIAL PRIMARY KEY, 
    order_non_gl_stock_master_id            bigint NOT NULL REFERENCES transactions.non_gl_stock_master(non_gl_stock_master_id),
    quotation_non_gl_stock_master_id        bigint NOT NULL REFERENCES transactions.non_gl_stock_master(non_gl_stock_master_id)
);


--This table stores information of Non GL Stock Transactions such as orders and quotations
--which were upgraded to deliveries or invoices.
CREATE TABLE transactions.stock_master_non_gl_relations
(
    stock_master_non_gl_relation_id         BIGSERIAL PRIMARY KEY, 
    stock_master_id                         bigint NOT NULL REFERENCES transactions.stock_master(stock_master_id),
    non_gl_stock_master_id                  bigint NOT NULL REFERENCES transactions.non_gl_stock_master(non_gl_stock_master_id)
);

CREATE TABLE transactions.routines
(
    routine_id                              SERIAL NOT NULL PRIMARY KEY,
    "order"                                 integer NOT NULL,
    routine_code                            national character varying(12) NOT NULL,
    routine_name                            regproc NOT NULL UNIQUE,
    status                                  boolean NOT NULL CONSTRAINT routines_status_df DEFAULT(true)
);

CREATE UNIQUE INDEX routines_routine_code_uix
ON transactions.routines(LOWER(routine_code));

CREATE TABLE transactions.day_operation
(
    day_id                                  BIGSERIAL NOT NULL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    value_date                              date NOT NULL,
    started_on                              TIMESTAMP WITH TIME ZONE NOT NULL,
    started_by                              integer NOT NULL REFERENCES office.users(user_id),    
    completed_on                            TIMESTAMP WITH TIME ZONE NULL,
    completed_by                            integer NULL REFERENCES office.users(user_id),
    completed                               boolean NOT NULL 
                                            CONSTRAINT day_operation_completed_df DEFAULT(false)
                                            CONSTRAINT day_operation_completed_chk 
                                            CHECK
                                            (
                                                (completed OR completed_on IS NOT NULL)
                                                OR
                                                (NOT completed OR completed_on IS NULL)
                                            )
);

CREATE UNIQUE INDEX day_operation_value_date_uix
ON transactions.day_operation(value_date);

CREATE INDEX day_operation_completed_on_inx
ON transactions.day_operation(completed_on);

CREATE TABLE transactions.day_operation_routines
(
    day_operation_routine_id                BIGSERIAL NOT NULL PRIMARY KEY,
    day_id                                  bigint NOT NULL REFERENCES transactions.day_operation(day_id),
    routine_id                              integer NOT NULL REFERENCES transactions.routines(routine_id),
    started_on                              TIMESTAMP WITH TIME ZONE NOT NULL,
    completed_on                            TIMESTAMP WITH TIME ZONE NULL
);

CREATE INDEX day_operation_routines_started_on_inx
ON transactions.day_operation_routines(started_on);

CREATE INDEX day_operation_routines_completed_on_inx
ON transactions.day_operation_routines(completed_on);

CREATE TABLE crm.lead_sources
(
    lead_source_id                          SERIAL PRIMARY KEY,
    lead_source_code                        national character varying(12) NOT NULL,
    lead_source_name                        national character varying(128) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX lead_sources_lead_source_code_uix
ON crm.lead_sources(UPPER(lead_source_code));


CREATE UNIQUE INDEX lead_sources_lead_source_name_uix
ON crm.lead_sources(UPPER(lead_source_name));



CREATE TABLE crm.lead_statuses
(
    lead_status_id                          SERIAL PRIMARY KEY,
    lead_status_code                        national character varying(12) NOT NULL,
    lead_status_name                        national character varying(128) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX lead_statuses_lead_status_code_uix
ON crm.lead_statuses(UPPER(lead_status_code));


CREATE UNIQUE INDEX lead_statuses_lead_status_name_uix
ON crm.lead_statuses(UPPER(lead_status_name));



CREATE TABLE crm.opportunity_stages
(
    opportunity_stage_id                    SERIAL  PRIMARY KEY,
    opportunity_stage_code                  national character varying(12) NOT NULL,
    opportunity_stage_name                  national character varying(50) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE UNIQUE INDEX opportunity_stages_opportunity_stage_code_uix
ON crm.opportunity_stages(UPPER(opportunity_stage_code));

CREATE UNIQUE INDEX opportunity_stages_opportunity_stage_name_uix
ON crm.opportunity_stages(UPPER(opportunity_stage_name));




CREATE TABLE office.work_centers
(
    work_center_id                          SERIAL PRIMARY KEY,
    office_id                               integer NOT NULL REFERENCES office.offices(office_id),
    work_center_code                        national character varying(12) NOT NULL,
    work_center_name                        national character varying(128) NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);

CREATE UNIQUE INDEX work_centers_work_center_code_uix
ON office.work_centers(UPPER(work_center_code));

CREATE UNIQUE INDEX work_centers_work_center_name_uix
ON office.work_centers(UPPER(work_center_name));


CREATE TABLE policy.voucher_verification_policy
(
    policy_id                               SERIAL NOT NULL PRIMARY KEY,
    user_id                                 integer REFERENCES office.users(user_id),
    can_verify_sales_transactions           boolean NOT NULL   
                                            CONSTRAINT voucher_verification_policy_verify_sales_df 
                                            DEFAULT(false),
    sales_verification_limit                money_strict2 NOT NULL   
                                            CONSTRAINT voucher_verification_policy_sales_verification_limit_df 
                                            DEFAULT(0),
    can_verify_purchase_transactions        boolean NOT NULL   
                                            CONSTRAINT voucher_verification_policy_verify_purchase_df 
                                            DEFAULT(false),
    purchase_verification_limit             money_strict2 NOT NULL   
                                            CONSTRAINT voucher_verification_policy_purchase_verification_limit_df 
                                            DEFAULT(0),
    can_verify_gl_transactions              boolean NOT NULL   
                                            CONSTRAINT voucher_verification_policy_verify_gl_df 
                                            DEFAULT(false),
    gl_verification_limit                   money_strict2 NOT NULL   
                                            CONSTRAINT voucher_verification_policy_gl_verification_limit_df 
                                            DEFAULT(0),
    can_self_verify                         boolean NOT NULL   
                                            CONSTRAINT voucher_verification_policy_verify_self_df 
                                            DEFAULT(false),
    self_verification_limit                 money_strict2 NOT NULL   
                                            CONSTRAINT voucher_verification_policy_self_verification_limit_df 
                                            DEFAULT(0),
    effective_from                          date NOT NULL,
    ends_on                                 date NOT NULL,
    is_active                               boolean NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL 
                                            DEFAULT(NOW())
);


CREATE TABLE policy.auto_verification_policy
(
    user_id                                 integer PRIMARY KEY REFERENCES office.users(user_id),
    verify_sales_transactions               boolean NOT NULL   
                                            CONSTRAINT auto_verification_policy_verify_sales_df   
                                            DEFAULT(false),
    sales_verification_limit                money_strict2 NOT NULL   
                                            CONSTRAINT auto_verification_policy_sales_verification_limit_df   
                                            DEFAULT(0),
    verify_purchase_transactions            boolean NOT NULL   
                                            CONSTRAINT auto_verification_policy_verify_purchase_df   
                                            DEFAULT(false),
    purchase_verification_limit             money_strict2 NOT NULL   
                                            CONSTRAINT auto_verification_policy_purchase_verification_limit_df   
                                            DEFAULT(0),
    verify_gl_transactions                  boolean NOT NULL   
                                            CONSTRAINT auto_verification_policy_verify_gl_df   
                                            DEFAULT(false),
    gl_verification_limit                   money_strict2 NOT NULL   
                                            CONSTRAINT auto_verification_policy_gl_verification_limit_df   
                                            DEFAULT(0),
    effective_from                          date NOT NULL,
    ends_on                                 date NOT NULL,
    is_active                               boolean NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())
);


CREATE TABLE core.config
(
    config_id                               integer PRIMARY KEY,
    config_name                             national character varying(50) NOT NULL UNIQUE    
);

CREATE TABLE office.configuration
(
    configuration_id                        SERIAL PRIMARY KEY,
    config_id                               integer REFERENCES core.config(config_id),
    office_id                               integer NOT NULL,
    value                                   text NOT NULL,
    configuration_details                   text NOT NULL,
    audit_user_id                           integer NULL REFERENCES office.users(user_id),
    audit_ts                                TIMESTAMP WITH TIME ZONE NULL   
                                            DEFAULT(NOW())    
);

CREATE TABLE core.widgets
(
    widget_id           SERIAL NOT NULL PRIMARY KEY,
    widget_name         text,
    widget_source       text NOT NULL,
    row_number          integer NOT NULL,
    column_number       integer NOT NULL
);

CREATE UNIQUE INDEX widgets_widget_name_uix
ON core.widgets(UPPER(widget_name));

CREATE UNIQUE INDEX widgets_widget_source_uix
ON core.widgets(UPPER(widget_source));



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/01.types-domains-tables-and-constraints/types.sql --<--<--
DROP TYPE IF EXISTS transactions.stock_detail_type CASCADE;
CREATE TYPE transactions.stock_detail_type AS
(
    store_id            integer,
    item_code           national character varying(12),
    quantity            integer_strict,
    unit_name           national character varying(50),
    price               money_strict,
    discount            money_strict2,
    shipping_charge     money_strict2,
    tax_form            national character varying(24),
    tax                 money_strict2
);


DROP TYPE IF EXISTS core.attachment_type CASCADE;
CREATE TYPE core.attachment_type AS
(
    comment                 national character varying(96),
    file_path               text,
    original_file_name      text,
    file_extension          text
);

DROP TYPE IF EXISTS transactions.purchase_reorder_type CASCADE;
CREATE TYPE transactions.purchase_reorder_type
AS
(
    item_id                 integer,
    supplier_code           national character varying(12),
    unit_id                 integer,
    price                   decimal_strict,
    tax_code                national character varying(24),
    order_quantity          integer_strict
);


DROP TYPE IF EXISTS transactions.stock_adjustment_type CASCADE;
CREATE TYPE transactions.stock_adjustment_type AS
(
    tran_type       transaction_type,
    store_name      national character varying(50),
    item_code       national character varying(12),
    unit_name       national character varying(50),
    quantity        integer_strict
);

DROP TYPE IF EXISTS transactions.opening_stock_type CASCADE;
CREATE TYPE transactions.opening_stock_type AS
(
    store_name      national character varying(50),
    item_code       national character varying(12),
    quantity        integer_strict,
    unit_name       national character varying(50),
    amount          money_strict
);

DROP TYPE IF EXISTS core.period CASCADE;

CREATE TYPE core.period AS
(
    period_name                     text,
    date_from                       date,
    date_to                         date
);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/audit/audit.is_valid_login_id.sql --<--<--
DROP FUNCTION IF EXISTS audit.is_valid_login_id(bigint);

CREATE FUNCTION audit.is_valid_login_id(bigint)
RETURNS boolean
STABLE
AS
$$
BEGIN
    IF EXISTS(SELECT 1 FROM audit.logins WHERE login_id=$1) THEN
            RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.append_if_not_null.sql --<--<--
CREATE FUNCTION core.append_if_not_null(text, text)
RETURNS text
IMMUTABLE
AS
$$
BEGIN
	IF($1 IS NULL) THEN
	    RETURN '';
	END IF;

	RETURN $1 || $2;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.convert_unit.sql --<--<--
DROP FUNCTION IF EXISTS core.convert_unit(from_unit integer, to_unit integer);

CREATE FUNCTION core.convert_unit(from_unit integer, to_unit integer)
RETURNS decimal
STABLE
AS
$$
    DECLARE _factor decimal;
BEGIN
    IF(core.get_root_unit_id($1) != core.get_root_unit_id($2)) THEN
        RETURN 0;
    END IF;

    IF($1 = $2) THEN
        RETURN 1.00;
    END IF;
    
    IF(core.is_parent_unit($1, $2)) THEN
            WITH RECURSIVE unit_cte(unit_id, value) AS 
            (
                SELECT tn.compare_unit_id, tn.value
                FROM core.compound_units AS tn WHERE tn.base_unit_id = $1

                UNION ALL

                SELECT 
                c.compare_unit_id, c.value * p.value
                FROM unit_cte AS p, 
                core.compound_units AS c 
                WHERE base_unit_id = p.unit_id
            )
        SELECT 1.00/value INTO _factor
        FROM unit_cte
        WHERE unit_id=$2;
    ELSE
            WITH RECURSIVE unit_cte(unit_id, value) AS 
            (
             SELECT tn.compare_unit_id, tn.value
                FROM core.compound_units AS tn WHERE tn.base_unit_id = $2
            UNION ALL
             SELECT 
                c.compare_unit_id, c.value * p.value
                FROM unit_cte AS p, 
              core.compound_units AS c 
                WHERE base_unit_id = p.unit_id
            )

        SELECT value INTO _factor
        FROM unit_cte
        WHERE unit_id=$1;
    END IF;

    RETURN _factor;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.count_item_in_stock.sql --<--<--
DROP FUNCTION IF EXISTS core.count_item_in_stock(_item_id integer, _unit_id integer, _store_id integer);

CREATE FUNCTION core.count_item_in_stock(_item_id integer, _unit_id integer, _store_id integer)
RETURNS decimal
STABLE
AS
$$
    DECLARE _debit decimal;
    DECLARE _credit decimal;
    DECLARE _balance decimal;
BEGIN

    _debit := core.count_purchases($1, $2, $3);
    _credit := core.count_sales($1, $2, $3);

    _balance:= _debit - _credit;    
    return _balance;  
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.count_purchases.sql --<--<--
DROP FUNCTION IF EXISTS core.count_purchases(_item_id integer, _unit_id integer, _store_id integer);

CREATE FUNCTION core.count_purchases(_item_id integer, _unit_id integer, _store_id integer)
RETURNS decimal
STABLE
AS
$$
        DECLARE _base_unit_id integer;
        DECLARE _debit decimal;
        DECLARE _factor decimal;
BEGIN
    --Get the base item unit
    SELECT 
        core.get_root_unit_id(core.items.unit_id) 
    INTO _base_unit_id
    FROM core.items
    WHERE core.items.item_id=$1;

    SELECT
        COALESCE(SUM(base_quantity), 0)
    INTO _debit
    FROM transactions.stock_details
    INNER JOIN transactions.stock_master
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    INNER JOIN transactions.transaction_master
    ON transactions.stock_master.transaction_master_id = transactions.transaction_master.transaction_master_id
    WHERE transactions.transaction_master.verification_status_id > 0
    AND transactions.stock_details.item_id=$1
    AND transactions.stock_details.store_id=$3
    AND transactions.stock_details.tran_type='Dr';

    _factor = core.convert_unit($2, _base_unit_id);    
    RETURN _debit * _factor;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.count_sales.sql --<--<--
DROP FUNCTION IF EXISTS core.count_sales(_item_id integer, _unit_id integer, _store_id integer);
CREATE FUNCTION core.count_sales(_item_id integer, _unit_id integer, _store_id integer)
RETURNS decimal
STABLE
AS
$$
        DECLARE _base_unit_id integer;
        DECLARE _credit decimal;
        DECLARE _factor decimal;
BEGIN
    --Get the base item unit
    SELECT 
        core.get_root_unit_id(core.items.unit_id) 
    INTO _base_unit_id
    FROM core.items
    WHERE core.items.item_id=$1;

    SELECT 
        COALESCE(SUM(base_quantity), 0)
    INTO _credit
    FROM transactions.stock_details
    INNER JOIN transactions.stock_master
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    INNER JOIN transactions.transaction_master
    ON transactions.stock_master.transaction_master_id = transactions.transaction_master.transaction_master_id
    WHERE transactions.transaction_master.verification_status_id > 0
    AND transactions.stock_details.item_id=$1
    AND transactions.stock_details.store_id=$3
    AND transactions.stock_details.tran_type='Cr';

    _factor = core.convert_unit($2, _base_unit_id);    
    RETURN _credit * _factor;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.create_flag.sql --<--<--
CREATE FUNCTION core.create_flag
(
    user_id_            integer,
    flag_type_id_       integer,
    resource_           text,
    resource_key_       text,
    resource_id_        text
)
RETURNS void
VOLATILE
AS
$$
BEGIN
    IF NOT EXISTS(SELECT * FROM core.flags WHERE user_id=user_id_ AND resource=resource_ AND resource_key=resource_key_ AND resource_id=resource_id_) THEN
        INSERT INTO core.flags(user_id, flag_type_id, resource, resource_key, resource_id)
        SELECT user_id_, flag_type_id_, resource_, resource_key_, resource_id_;
    ELSE
        UPDATE core.flags
        SET
            flag_type_id=flag_type_id_
        WHERE 
            user_id=user_id_ 
        AND 
            resource=resource_ 
        AND 
            resource_key=resource_key_ 
        AND 
            resource_id=resource_id_;
    END IF;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_account_number.sql --<--<--
CREATE FUNCTION core.get_account_id_by_account_number(text)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN
		account_id
    FROM core.accounts
    WHERE account_number=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_parameter.sql --<--<--


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_party_code.sql --<--<--
CREATE FUNCTION core.get_account_id_by_party_code(party_code text)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN
		account_id
    FROM core.parties
    WHERE core.parties.party_code=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_party_id.sql --<--<--
CREATE FUNCTION core.get_account_id_by_party_id(party_id bigint)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN account_id
    FROM core.parties
    WHERE core.parties.party_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_party_type_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_account_id_by_party_type_id(_party_type_id integer);

CREATE FUNCTION core.get_account_id_by_party_type_id(_party_type_id integer)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN account_id
    FROM core.party_types
    WHERE party_type_id=$1;
END;
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_id_by_shipper_id.sql --<--<--
CREATE FUNCTION core.get_account_id_by_shipper_id(integer)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN
        core.shippers.account_id
    FROM
        core.shippers
    WHERE
        core.shippers.shipper_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_ids.sql --<--<--
DROP FUNCTION IF EXISTS core.get_account_ids(root_account_id bigint);

CREATE FUNCTION core.get_account_ids(root_account_id bigint)
RETURNS SETOF bigint
STABLE
AS
$$
BEGIN
    RETURN QUERY 
    (
        WITH RECURSIVE account_cte(account_id, path) AS (
         SELECT
            tn.account_id,  tn.account_id::TEXT AS path
            FROM core.accounts AS tn WHERE tn.account_id =$1
        UNION ALL
         SELECT
            c.account_id, (p.path || '->' || c.account_id::TEXT)
            FROM account_cte AS p, core.accounts AS c WHERE parent_account_id = p.account_id
        )

        SELECT account_id FROM account_cte
    );
END
$$LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_master_id_by_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_account_master_id_by_account_id(bigint) CASCADE;

CREATE FUNCTION core.get_account_master_id_by_account_id(bigint)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN core.accounts.account_master_id
    FROM core.accounts
    WHERE core.accounts.account_id= $1;
END
$$
LANGUAGE plpgsql;

ALTER TABLE core.bank_accounts
ADD CONSTRAINT bank_accounts_account_id_chk 
CHECK
(
    core.get_account_master_id_by_account_id(account_id) = '10102'
);




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_master_id_by_account_master_code.sql --<--<--
CREATE FUNCTION core.get_account_master_id_by_account_master_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN core.account_masters.account_master_id
    FROM core.account_masters
    WHERE core.account_masters.account_master_code = $1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_name.sql --<--<--
--Todo:Rename to core.get_account_name_by_account_id
CREATE FUNCTION core.get_account_name(bigint)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN account_name
    FROM core.accounts
    WHERE account_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_account_name_by_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_account_name_by_account_id(bigint);

CREATE FUNCTION core.get_account_name_by_account_id(bigint)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN account_name
    FROM core.accounts
    WHERE account_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_associated_units.sql --<--<--
DROP FUNCTION IF EXISTS core.get_associated_units(integer);

CREATE FUNCTION core.get_associated_units(integer)
RETURNS TABLE
(
    unit_id integer, 
    unit_code text, 
    unit_name text
)
VOLATILE
AS
$$
    DECLARE root_unit_id integer;
BEGIN
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_unit(unit_id integer) ON COMMIT DROP; 
    
    SELECT core.get_root_unit_id($1) INTO root_unit_id;
    
    INSERT INTO temp_unit(unit_id) 
    SELECT root_unit_id
    WHERE NOT EXISTS
    (
        SELECT * FROM temp_unit
        WHERE temp_unit.unit_id=root_unit_id
    );
    
    WITH RECURSIVE cte(unit_id)
    AS
    (
         SELECT 
            compare_unit_id
         FROM 
            core.compound_units
         WHERE 
            base_unit_id = root_unit_id

        UNION ALL

         SELECT
            units.compare_unit_id
         FROM 
            core.compound_units units
         INNER JOIN cte 
         ON cte.unit_id = units.base_unit_id
    )
    
    INSERT INTO temp_unit(unit_id)
    SELECT cte.unit_id FROM cte;
    
    DELETE FROM temp_unit
    WHERE temp_unit.unit_id IS NULL;
    
    RETURN QUERY 
    SELECT 
        core.units.unit_id,
        core.units.unit_code::text,
        core.units.unit_name::text
    FROM
        core.units
    WHERE
        core.units.unit_id 
    IN
    (
        SELECT temp_unit.unit_id FROM temp_unit
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_associated_units_from_item_code.sql --<--<--
CREATE FUNCTION core.get_associated_units_from_item_code(text)
RETURNS TABLE(unit_id integer, unit_code text, unit_name text)
VOLATILE
AS
$$
	DECLARE _unit_id integer;
BEGIN
    SELECT core.items.unit_id INTO _unit_id
    FROM core.items
    WHERE core.items.item_code=$1;

    RETURN QUERY
    SELECT ret.unit_id, ret.unit_code, ret.unit_name
    FROM core.get_associated_units(_unit_id) AS ret;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_associated_units_from_item_id.sql --<--<--
CREATE FUNCTION core.get_associated_units_from_item_id(integer)
RETURNS TABLE(unit_id integer, unit_code text, unit_name text)
VOLATILE
AS
$$
DECLARE _unit_id integer;
BEGIN
    SELECT core.items.unit_id INTO _unit_id
    FROM core.items
    WHERE core.items.item_id=$1;

    RETURN QUERY
    SELECT ret.unit_id, ret.unit_code, ret.unit_name
    FROM core.get_associated_units(_unit_id) AS ret;

END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_attachment_lookup_info.sql --<--<--
DROP FUNCTION IF EXISTS core.get_attachment_lookup_info(national character varying(50));

CREATE FUNCTION core.get_attachment_lookup_info(national character varying(50))
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN resource || resource_key
    FROM core.attachment_lookup
    WHERE book=$1;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_base_quantity_by_unit_name.sql --<--<--
CREATE FUNCTION core.get_base_quantity_by_unit_name(text, integer)
RETURNS decimal
STABLE
AS
$$
	DECLARE _unit_id integer;
	DECLARE _root_unit_id integer;
	DECLARE _factor decimal;
BEGIN
    _unit_id := core.get_unit_id_by_unit_name($1);
    _root_unit_id = core.get_root_unit_id(_unit_id);
    _factor = core.convert_unit(_unit_id, _root_unit_id);

    RETURN _factor * $2;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_base_unit_id_by_unit_name.sql --<--<--
CREATE FUNCTION core.get_base_unit_id_by_unit_name(text)
RETURNS integer
STABLE
AS
$$
DECLARE _unit_id integer;
BEGIN
    _unit_id := core.get_unit_id_by_unit_name($1);

    RETURN core.get_root_unit_id(_unit_id);
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_brand_code_by_brand_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_brand_code_by_brand_id(integer);

CREATE FUNCTION core.get_brand_code_by_brand_id(integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN brand_code
    FROM core.brands
    WHERE brand_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_brand_id_by_brand_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_brand_id_by_brand_code(text);

CREATE FUNCTION core.get_brand_id_by_brand_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
        RETURN brand_id
        FROM core.brands
        WHERE brand_code=$1;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM core.get_brand_id_by_brand_code('DEF');

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_brand_id_by_brand_name.sql --<--<--
DROP FUNCTION IF EXISTS core.get_brand_id_by_brand_name(text);

CREATE FUNCTION core.get_brand_id_by_brand_name(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN brand_id
    FROM core.brands
    WHERE brand_name=$1;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM core.get_brand_id_by_brand_name('DEF');

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_brand_name_by_brand_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_brand_name_by_brand_id(integer);

CREATE FUNCTION core.get_brand_name_by_brand_id(integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN brand_name
    FROM core.brands
    WHERE brand_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_cash_account_id.sql --<--<--
--TODO:DROP THIS FUNCTION
CREATE FUNCTION core.get_cash_account_id()
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN account_id
    FROM core.accounts
    WHERE account_master_id = 10101
    ORDER BY account_id ASC
    LIMIT 1;
END
$$
LANGUAGE plpgsql;

COMMENT ON FUNCTION core.get_cash_account_id() IS 'This function is now obsolete, core.get_cash_account_id_by_store_id(_store_id integer) should be used instead.';

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_cash_account_id_by_store_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_cash_account_id_by_store_id(_store_id integer);

CREATE FUNCTION core.get_cash_account_id_by_store_id(_store_id integer)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN
        default_cash_account_id
    FROM
        office.stores
    WHERE
        office.stores.store_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_cash_flow_heading_id_by_cash_flow_heading_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_cash_flow_heading_id_by_cash_flow_heading_code(_cash_flow_heading_code national character varying(12));

CREATE FUNCTION core.get_cash_flow_heading_id_by_cash_flow_heading_code(_cash_flow_heading_code national character varying(12))
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN
        cash_flow_heading_id
    FROM
        core.cash_flow_headings
    WHERE
        cash_flow_heading_code = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_cash_repository_id_by_store_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_cash_repository_id_by_store_id(_store_id integer);

CREATE FUNCTION core.get_cash_repository_id_by_store_id(_store_id integer)
RETURNS bigint
STABLE
AS
$$
BEGIN
    RETURN
        default_cash_repository_id
    FROM
        office.stores
    WHERE
        office.stores.store_id=$1;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_cost_of_goods_sold_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_cost_of_goods_sold_account_id(_item_id integer);

CREATE FUNCTION core.get_cost_of_goods_sold_account_id(_item_id integer)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN
        cost_of_goods_sold_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_country_id_by_country_code.sql --<--<--
CREATE FUNCTION core.get_country_id_by_country_code(national character varying(12))
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN country_id
    FROM core.countries
    WHERE country_code = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_country_name_by_country_id.sql --<--<--
CREATE FUNCTION core.get_country_name_by_country_id(integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN
    country_name
    FROM core.countries
    WHERE country_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_county_id_by_county_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_county_id_by_county_code(national character varying(12));

CREATE FUNCTION core.get_county_id_by_county_code(national character varying(12))
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN county_id
    FROM core.counties
    WHERE county_code = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_county_id_by_county_name.sql --<--<--
DROP FUNCTION IF EXISTS core.get_county_id_by_county_name(text);

CREATE FUNCTION core.get_county_id_by_county_name(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN county_id
    FROM core.counties
    WHERE county_name = $1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_county_sales_tax_rate.sql --<--<--
DROP FUNCTION IF EXISTS core.get_county_sales_tax_rate(_county_sales_tax_id integer);

CREATE FUNCTION core.get_county_sales_tax_rate(_county_sales_tax_id integer)
RETURNS decimal_strict2
STABLE
AS
$$
BEGIN
    RETURN rate
    FROM core.county_sales_taxes
    WHERE county_sales_tax_id=$1;
END
$$
LANGUAGE plpgsql;





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_currency_code_by_office_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_currency_code_by_office_id(integer);

CREATE FUNCTION core.get_currency_code_by_office_id(office_id integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN office.offices.currency_code
    FROM office.offices
    WHERE office.offices.office_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_currency_code_by_party_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_currency_code_by_party_code(national character varying(12));

CREATE FUNCTION core.get_currency_code_by_party_code(_party_code national character varying(12))
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN core.accounts.currency_code
    FROM core.accounts
    INNER JOIN core.parties
    ON core.accounts.account_id = core.parties.account_id
    AND core.parties.party_code=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_currency_code_by_party_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_currency_code_by_party_id(bigint);

CREATE FUNCTION core.get_currency_code_by_party_id(party_id bigint)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN core.accounts.currency_code
    FROM core.accounts
    INNER JOIN core.parties
    ON core.accounts.account_id = core.parties.account_id
    AND core.parties.party_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_current_year.sql --<--<--
--TODO:Drop this function. We now have frequency setup.
DROP FUNCTION IF EXISTS core.get_current_year();
CREATE FUNCTION core.get_current_year()
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN(SELECT EXTRACT(year FROM current_date)::integer);
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_email_address_by_party_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_email_address_by_party_id(bigint);

CREATE FUNCTION core.get_email_address_by_party_id(bigint)
RETURNS TEXT
STABLE
AS
$$
BEGIN
    RETURN email 
    FROM core.parties
    WHERE party_id=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_entity_id_by_party_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_entity_id_by_party_id(_party_id bigint);

CREATE FUNCTION core.get_entity_id_by_party_id(_party_id bigint)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN entity_id
    FROM core.parties
    WHERE party_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_flag_background_color.sql --<--<--
CREATE FUNCTION core.get_flag_background_color(flag_type_id_ integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN background_color
    FROM core.flag_types
    WHERE core.flag_types.flag_type_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_flag_foreground_color.sql --<--<--
CREATE FUNCTION core.get_flag_foreground_color(flag_type_id_ integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN foreground_color
    FROM core.flag_types
    WHERE core.flag_types.flag_type_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_flag_type_id.sql --<--<--
CREATE FUNCTION core.get_flag_type_id
(
    user_id_        integer,
    resource_       text,
    resource_key_   text,
    resource_id_    text
)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN flag_type_id
    FROM core.flags
    WHERE user_id=$1
    AND resource=$2
    AND resource_key=$3
    AND resource_id=$4;
END
$$
LANGUAGE plpgsql;

-- CREATE FUNCTION core.get_flag_type_id
-- (
--     user_id_        integer,
--     resource_       text,
--     resource_id_    text
-- )
-- RETURNS integer
-- STABLE
-- AS
-- $$
-- BEGIN
--     RETURN core.get_flag_type_id($1, $2, $3::text);
-- END
-- $$
-- LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_frequency_code_by_frequency_id.sql --<--<--
CREATE FUNCTION core.get_frequency_code_by_frequency_id(integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN frequency_code
    FROM core.frequencies
    WHERE core.frequencies.frequency_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_frequency_setup_code_by_frequency_setup_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_frequency_setup_code_by_frequency_setup_id(_frequency_setup_id integer);

CREATE FUNCTION core.get_frequency_setup_code_by_frequency_setup_id(_frequency_setup_id integer)
RETURNS text
STABLE
AS
$$
BEGIN
    RETURN frequency_setup_code
    FROM core.frequency_setups
    WHERE frequency_setup_id = $1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_frequency_setup_end_date_frequency_setup_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_frequency_setup_end_date_frequency_setup_id(_frequency_setup_id integer);
CREATE FUNCTION core.get_frequency_setup_end_date_frequency_setup_id(_frequency_setup_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN
        value_date
    FROM
        core.frequency_setups
    WHERE
        frequency_setup_id = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_frequency_setup_start_date_frequency_setup_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_frequency_setup_start_date_frequency_setup_id(_frequency_setup_id integer);
CREATE FUNCTION core.get_frequency_setup_start_date_frequency_setup_id(_frequency_setup_id integer)
RETURNS date
AS
$$
    DECLARE _start_date date;
BEGIN
    SELECT MAX(value_date) + 1 
    INTO _start_date
    FROM core.frequency_setups
    WHERE value_date < 
    (
        SELECT value_date
        FROM core.frequency_setups
        WHERE frequency_setup_id = $1
    );

    IF(_start_date IS NULL) THEN
        SELECT starts_from 
        INTO _start_date
        FROM core.fiscal_year;
    END IF;

    RETURN _start_date;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_industry_id_by_party_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_industry_id_by_party_id(_party_id bigint);

CREATE FUNCTION core.get_industry_id_by_party_id(_party_id bigint)
RETURNS integer
AS
$$
BEGIN
    RETURN industry_id
    FROM core.parties
    WHERE party_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_inventory_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_inventory_account_id(_item_id integer);

CREATE FUNCTION core.get_inventory_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        inventory_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_code_by_item_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_code_by_item_id(integer);

CREATE FUNCTION core.get_item_code_by_item_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN
                item_code
        FROM
                core.items
        WHERE item_id=$1;
END
$$
LANGUAGE plpgsql;

--SELECT core.get_item_code_by_item_id(1);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_cost_price.sql --<--<--
CREATE FUNCTION core.get_item_cost_price(item_id_ integer, unit_id_ integer, party_id_ bigint)
RETURNS money_strict2
AS
$$
    DECLARE _price money_strict2;
    DECLARE _unit_id integer;
    DECLARE _factor decimal;
    DECLARE _tax_rate decimal;
    DECLARE _includes_tax boolean;
    DECLARE _tax money_strict2;
BEGIN
    --Fist pick the catalog price which matches all these fields:
    --Item, Unit, and Supplier.
    --This is the most effective price.
    SELECT 
        item_cost_prices.price, 
        item_cost_prices.unit_id,
        item_cost_prices.includes_tax
    INTO 
        _price, 
        _unit_id,
        _includes_tax       
    FROM core.item_cost_prices
    WHERE item_cost_prices.item_id = $1
    AND item_cost_prices.unit_id = $2
    AND item_cost_prices.party_id =$3;

    IF(_unit_id IS NULL) THEN
        --We do not have a cost price of this item for the unit supplied.
        --Let's see if this item has a price for other units.
        SELECT 
            item_cost_prices.price, 
            item_cost_prices.unit_id,
            item_cost_prices.includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.item_cost_prices
        WHERE item_cost_prices.item_id=$1
        AND item_cost_prices.party_id =$3;
    END IF;

    
    IF(_price IS NULL) THEN
        --This item does not have cost price defined in the catalog.
        --Therefore, getting the default cost price from the item definition.
        SELECT 
            cost_price, 
            unit_id,
            cost_price_includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.items
        WHERE core.items.item_id = $1;
    END IF;

    IF(_includes_tax) THEN
        _tax_rate := core.get_item_tax_rate($1);
        _price := _price / ((100 + _tax_rate)/ 100);
    END IF;

    --Get the unitary conversion factor if the requested unit does not match with the price defition.
    _factor := core.convert_unit($2, _unit_id);

    RETURN _price * _factor;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_group_code_by_item_group_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_group_code_by_item_group_id(integer);

CREATE FUNCTION core.get_item_group_code_by_item_group_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN item_group_code
        FROM core.item_groups
        WHERE item_group_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_group_id_by_item_group_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_group_id_by_item_group_code(text);

CREATE FUNCTION core.get_item_group_id_by_item_group_code(text)
RETURNS integer
AS
$$
BEGIN
        RETURN item_group_id
        FROM core.item_groups
        WHERE item_group_code=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_group_id_by_item_group_name.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_group_id_by_item_group_name(text);

CREATE FUNCTION core.get_item_group_id_by_item_group_name(text)
RETURNS integer
AS
$$
BEGIN
        RETURN item_group_id
        FROM core.item_groups
        WHERE item_group_name=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_group_id_by_item_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_group_id_by_item_id(integer);

CREATE FUNCTION core.get_item_group_id_by_item_id(integer)
RETURNS integer
AS
$$
BEGIN
        RETURN item_group_id
        FROM core.items
        WHERE item_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_group_name_by_item_group_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_group_name_by_item_group_id(integer);

CREATE FUNCTION core.get_item_group_name_by_item_group_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN item_group_name
        FROM core.item_groups
        WHERE item_group_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_id_by_item_code.sql --<--<--
CREATE FUNCTION core.get_item_id_by_item_code(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT
            item_id
        FROM
            core.items
        WHERE 
            core.items.item_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_name_by_item_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_name_by_item_id(integer);

CREATE FUNCTION core.get_item_name_by_item_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN
                item_name
        FROM
                core.items
        WHERE item_id=$1;
END
$$
LANGUAGE plpgsql;

--SELECT core.get_item_name_by_item_id(1);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_tax_rate.sql --<--<--
CREATE FUNCTION core.get_item_tax_rate(_item_id integer)
RETURNS decimal
STABLE
AS
$$
BEGIN
    RETURN
        core.sales_taxes.rate
    FROM core.sales_taxes
    INNER JOIN core.items
    ON core.items.sales_tax_id = core.sales_taxes.sales_tax_id
    AND core.items.item_id = $1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_item_type_id_by_item_type_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_type_id_by_item_type_code(text);

CREATE FUNCTION core.get_item_type_id_by_item_type_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN item_type_id
    FROM core.item_types
    WHERE item_type_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_menu_id.sql --<--<--
CREATE FUNCTION core.get_menu_id(menu_code text)
RETURNS INTEGER
AS
$$
BEGIN
    RETURN
    (
        SELECT core.menus.menu_id
        FROM core.menus
        WHERE core.menus.menu_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_office_id_by_sales_tax_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_office_id_by_sales_tax_id(_sales_tax_id integer);

CREATE FUNCTION core.get_office_id_by_sales_tax_id(_sales_tax_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN office_id
    FROM core.sales_taxes
    WHERE core.sales_taxes.sales_tax_id=$1;
END
$$
LANGUAGE plpgsql;

ALTER TABLE office.stores
ADD CONSTRAINT stores_sales_tax_id_chk
CHECK(core.get_office_id_by_sales_tax_id(sales_tax_id) = office_id);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_party_code.sql --<--<--


/*******************************************************************
    GET UNIQUE EIGHT-TO-TEN DIGIT CUSTOMER CODE
    TO IDENTIFY A PARTY.
    BASIC FORMULA:
        1. FIRST TWO LETTERS OF FIRST NAME
        2. FIRST LETTER OF MIDDLE NAME (IF AVAILABLE)
        3. FIRST TWO LETTERS OF LAST NAME
        4. CUSTOMER NUMBER
*******************************************************************/

CREATE OR REPLACE FUNCTION core.get_party_code
(
    text, --First Name
    text, --Middle Name
    text  --Last Name
)
RETURNS text AS
$$
    DECLARE _party_code TEXT;
BEGIN
    SELECT INTO 
        _party_code 
            party_code
    FROM
        core.parties
    WHERE
        party_code LIKE 
            UPPER(left($1,2) ||
            CASE
                WHEN $2 IS NULL or $2 = '' 
                THEN left($3,3)
            ELSE 
                left($2,1) || left($3,2)
            END 
            || '%')
    ORDER BY party_code desc
    LIMIT 1;

    _party_code :=
                    UPPER
                    (
                        left($1,2)||
                        CASE
                            WHEN $2 IS NULL or $2 = '' 
                            THEN left($3,3)
                        ELSE 
                            left($2,1)||left($3,2)
                        END
                    ) 
                    || '-' ||
                    CASE
                        WHEN _party_code IS NULL 
                        THEN '0001'
                    ELSE 
                        to_char(CAST(right(_party_code,4) AS integer)+1,'FM0000')
                    END;
    RETURN _party_code;
END;
$$
LANGUAGE 'plpgsql';




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_party_id_by_party_code.sql --<--<--
CREATE FUNCTION core.get_party_id_by_party_code(text)
RETURNS bigint
AS
$$
BEGIN
    RETURN
    (
        SELECT
            party_id
        FROM
            core.parties
        WHERE 
            core.parties.party_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_party_type_id_by_party_code.sql --<--<--
CREATE FUNCTION core.get_party_type_id_by_party_code(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT
            party_type_id
        FROM
            core.parties
        WHERE 
            core.parties.party_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_party_type_id_by_party_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_party_type_id_by_party_id(_party_id bigint);

CREATE FUNCTION core.get_party_type_id_by_party_id(_party_id bigint)
RETURNS integer
AS
$$
BEGIN
    RETURN party_type_id
    FROM core.parties
    WHERE party_id=$1;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_party_type_id_by_party_type_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_party_type_id_by_party_type_code(text);

CREATE FUNCTION core.get_party_type_id_by_party_type_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN party_type_id
    FROM core.party_types
    WHERE party_type_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_payment_term_id_by_payment_term_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_payment_term_id_by_payment_term_code(text);

CREATE FUNCTION core.get_payment_term_id_by_payment_term_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN payment_term_id
    FROM core.payment_terms
    WHERE payment_term_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_price_type_id_by_price_type_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_price_type_id_by_price_type_code(text);

CREATE FUNCTION core.get_price_type_id_by_price_type_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN price_type_id
    FROM core.price_types
    WHERE price_type_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_price_type_name_by_price_type_id.sql --<--<--
CREATE FUNCTION core.get_price_type_name_by_price_type_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT price_type_name
        FROM core.price_types
        WHERE price_type_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_purchase_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_purchase_account_id(_item_id integer);

CREATE FUNCTION core.get_purchase_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        purchase_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_purchase_discount_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_purchase_discount_account_id(_item_id integer);

CREATE FUNCTION core.get_purchase_discount_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        purchase_discount_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_recurring_amount_by_recurring_invoice_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_recurring_amount_by_recurring_invoice_id(_recurring_invoice_id integer);

CREATE FUNCTION core.get_recurring_amount_by_recurring_invoice_id(_recurring_invoice_id integer)
RETURNS money_strict
AS
$$
BEGIN
    RETURN
        recurring_amount
    FROM
        core.recurring_invoices
    WHERE
        core.recurring_invoices.recurring_invoice_id=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_root_parent_menu_id.sql --<--<--
CREATE FUNCTION core.get_root_parent_menu_id(text)
RETURNS integer
AS
$$
    DECLARE retVal integer;
BEGIN
    WITH RECURSIVE find_parent(menu_id_group, parent, parent_menu_id, recentness) AS
    (
            SELECT menu_id, menu_id, parent_menu_id, 0
            FROM core.menus
            WHERE url=$1
            UNION ALL
            SELECT fp.menu_id_group, i.menu_id, i.parent_menu_id, fp.recentness + 1
            FROM core.menus i
            JOIN find_parent fp ON i.menu_id = fp.parent_menu_id
    )

        SELECT parent INTO retVal
        FROM find_parent q 
        JOIN
        (
                SELECT menu_id_group, MAX(recentness) AS answer
                FROM find_parent
                GROUP BY menu_id_group 
        ) AS ans ON q.menu_id_group = ans.menu_id_group AND q.recentness = ans.answer 
        ORDER BY q.menu_id_group;

    RETURN retVal;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_root_unit_id.sql --<--<--
CREATE FUNCTION core.get_root_unit_id(integer)
RETURNS integer
AS
$$
    DECLARE root_unit_id integer;
BEGIN
    SELECT base_unit_id INTO root_unit_id
    FROM core.compound_units
    WHERE compare_unit_id=$1;

    IF(root_unit_id IS NULL) THEN
        RETURN $1;
    ELSE
        RETURN core.get_root_unit_id(root_unit_id);
    END IF; 
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_account_id(_item_id integer);

CREATE FUNCTION core.get_sales_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        sales_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_discount_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_discount_account_id(_item_id integer);

CREATE FUNCTION core.get_sales_discount_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        sales_discount_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_return_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_return_account_id(_item_id integer);

CREATE FUNCTION core.get_sales_return_account_id(_item_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
        sales_return_account_id
    FROM core.item_groups
    INNER JOIN core.items
    ON core.item_groups.item_group_id = core.items.item_group_id
    WHERE core.items.item_id = $1;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_tax_code_by_sales_tax_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_tax_code_by_sales_tax_id(_sales_tax_id integer);


CREATE FUNCTION core.get_sales_tax_code_by_sales_tax_id(_sales_tax_id integer)
RETURNS national character varying(24)
AS
$$
BEGIN
    RETURN
        sales_tax_code
    FROM
        core.sales_taxes
    WHERE
        sales_tax_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_tax_id_by_sales_tax_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_tax_id_by_sales_tax_code(_sales_tax_code national character varying(24));


CREATE FUNCTION core.get_sales_tax_id_by_sales_tax_code(_sales_tax_code national character varying(24))
RETURNS integer
AS
$$
BEGIN
    RETURN
        sales_tax_id
    FROM
        core.sales_taxes
    WHERE
        sales_tax_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_tax_name_by_sales_tax_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_tax_name_by_sales_tax_id(_sales_tax_id integer);


CREATE FUNCTION core.get_sales_tax_name_by_sales_tax_id(_sales_tax_id integer)
RETURNS national character varying(24)
AS
$$
BEGIN
    RETURN
        sales_tax_name
    FROM
        core.sales_taxes
    WHERE
        sales_tax_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_sales_team_id_by_sales_team_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_sales_team_id_by_sales_team_code(text);

CREATE FUNCTION core.get_sales_team_id_by_sales_team_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN sales_team_id
    FROM core.sales_teams
    WHERE sales_team_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_salesperson_id_by_salesperson_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_salesperson_id_by_salesperson_code(text);

CREATE FUNCTION core.get_salesperson_id_by_salesperson_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN salesperson_id
    FROM core.salespersons
    WHERE salesperson_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_salesperson_name_by_salesperson_id.sql --<--<--
CREATE FUNCTION core.get_salesperson_name_by_salesperson_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT salesperson_name
        FROM core.salespersons
        WHERE salesperson_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_second_root_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_second_root_account_id(integer, integer);

CREATE FUNCTION core.get_second_root_account_id(_account_id bigint, _parent bigint default 0)
RETURNS integer
AS
$$
    DECLARE _parent_account_id bigint;
BEGIN
    SELECT 
        parent_account_id
        INTO _parent_account_id
    FROM core.accounts
    WHERE account_id=$1;

    IF(_parent_account_id IS NULL) THEN
        RETURN $2;
    ELSE
        RETURN core.get_second_root_account_id(_parent_account_id, $1);
    END IF; 
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipper_code.sql --<--<--

/*******************************************************************
    GET UNIQUE EIGHT-TO-TEN DIGIT shipper CODE
    TO IDENTIFY A shipper.
    BASIC FORMULA:
        1. FIRST TWO LETTERS OF FIRST NAME
        2. FIRST LETTER OF MIDDLE NAME (IF AVAILABLE)
        3. FIRST TWO LETTERS OF LAST NAME
        4. shipper NUMBER
*******************************************************************/

CREATE OR REPLACE FUNCTION core.get_shipper_code
(
    text --company name
)
RETURNS text AS
$$
    DECLARE __shipper_code TEXT;
BEGIN
    SELECT INTO 
        __shipper_code 
            shipper_code
    FROM
        core.shippers
    WHERE
        shipper_code LIKE 
            UPPER(left($1, 3) || '%')
    ORDER BY shipper_code desc
    LIMIT 1;

    __shipper_code :=
                    UPPER
                    (
                        left($1,3)
                    ) 
                    || '-' ||
                    CASE
                        WHEN __shipper_code IS NULL 
                        THEN '0001'
                    ELSE 
                        to_char(CAST(right(__shipper_code, 4) AS integer)+1,'FM0000')
                    END;
    RETURN __shipper_code;
END;
$$
LANGUAGE 'plpgsql';




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipper_id_by_shipper_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_shipper_id_by_shipper_code(text);

CREATE FUNCTION core.get_shipper_id_by_shipper_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN shipper_id
    FROM core.shippers
    WHERE shipper_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipper_name_by_shipper_id.sql --<--<--
CREATE FUNCTION core.get_shipper_name_by_shipper_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT company_name
        FROM core.shippers
        WHERE shipper_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipping_address_by_shipping_address_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_shipping_address_by_shipping_address_id(bigint);

CREATE FUNCTION core.get_shipping_address_by_shipping_address_id(bigint)
RETURNS text
AS
$$
BEGIN
        IF($1 IS NULL OR $1 <=0) THEN
                RETURN '';
        END IF;


        RETURN
                core.append_if_not_null(po_box, '&lt;br /&gt;') || 
                core.append_if_not_null(address_line_1, '&lt;br /&gt;') || 
                core.append_if_not_null(address_line_2, '&lt;br /&gt;') || 
                core.append_if_not_null(street, '&lt;br /&gt;') ||
                city  || '&lt;br /&gt;' ||
                state  || '&lt;br /&gt;' ||
                country 
        FROM core.shipping_addresses
        WHERE shipping_address_id=$1;
        
END
$$
LANGUAGE plpgsql;

--SELECT core.get_shipping_address_by_shipping_address_id(1);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipping_address_code_by_shipping_address_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_shipping_address_code_by_shipping_address_id(bigint);

CREATE FUNCTION core.get_shipping_address_code_by_shipping_address_id(bigint)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT
            shipping_address_code
        FROM
            core.shipping_addresses
        WHERE 
            core.shipping_addresses.shipping_address_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_shipping_address_id_by_shipping_address_code.sql --<--<--

CREATE FUNCTION core.get_shipping_address_id_by_shipping_address_code(text, bigint)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN
    (
        SELECT
            shipping_address_id
        FROM
            core.shipping_addresses
        WHERE 
            core.shipping_addresses.shipping_address_code=$1
        AND
            core.shipping_addresses.party_id=$2
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_state_id_by_shipping_address_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_state_id_by_shipping_address_code(text, bigint);

CREATE FUNCTION core.get_state_id_by_shipping_address_code(text, bigint)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT
            state_id
        FROM
            core.shipping_addresses
        WHERE 
            core.shipping_addresses.shipping_address_code=$1
        AND
            core.shipping_addresses.party_id=$2
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_state_id_by_state_code.sql --<--<--
CREATE FUNCTION core.get_state_id_by_state_code(national character varying(12))
RETURNS integer
AS
$$
BEGIN
    RETURN
        state_id
    FROM
        core.states
    WHERE
        state_code = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_state_id_by_state_name.sql --<--<--
DROP FUNCTION IF EXISTS core.get_state_id_by_state_name(text);

CREATE FUNCTION core.get_state_id_by_state_name(text)
RETURNS integer
AS
$$
BEGIN
    RETURN state_id
    FROM core.states
    WHERE state_name = $1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_state_name_by_state_id.sql --<--<--
CREATE FUNCTION core.get_state_name_by_state_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
        state_name
    FROM
        core.states
    WHERE
        state_id = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_state_sales_tax_rate.sql --<--<--
DROP FUNCTION IF EXISTS core.get_state_sales_tax_rate(_state_sales_tax_id integer);

CREATE FUNCTION core.get_state_sales_tax_rate(_state_sales_tax_id integer)
RETURNS decimal_strict2
AS
$$
BEGIN
    RETURN
        rate
    FROM core.state_sales_taxes
    WHERE state_sales_tax_id=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_tax_master_id_by_tax_master_code.sql --<--<--
DROP FUNCTION IF EXISTS core.get_tax_master_id_by_tax_master_code(text);

CREATE FUNCTION core.get_tax_master_id_by_tax_master_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN tax_master_id
    FROM core.tax_master
    WHERE tax_master_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_unit_code_by_unit_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_unit_code_by_unit_id(integer);

CREATE FUNCTION core.get_unit_code_by_unit_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN
                unit_code
        FROM
                core.units
        WHERE unit_id=$1;
END
$$
LANGUAGE plpgsql;

--SELECT core.get_unit_code_by_unit_id(1);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_unit_id_by_unit_code.sql --<--<--
CREATE FUNCTION core.get_unit_id_by_unit_code(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT
            core.units.unit_id
        FROM
            core.units
        WHERE
            core.units.unit_code=$1
    );
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_unit_id_by_unit_name.sql --<--<--
CREATE FUNCTION core.get_unit_id_by_unit_name(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT
            core.units.unit_id
        FROM
            core.units
        WHERE
            core.units.unit_name=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_unit_name_by_unit_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_unit_name_by_unit_id(integer);

CREATE FUNCTION core.get_unit_name_by_unit_id(integer)
RETURNS text
AS
$$
BEGIN
        RETURN
                unit_name
        FROM
                core.units
        WHERE unit_id=$1;
END
$$
LANGUAGE plpgsql;

--SELECT core.get_unit_name_by_unit_id(1);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.get_verification_status_name_by_verification_status_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_verification_status_name_by_verification_status_id(integer);

CREATE FUNCTION core.get_verification_status_name_by_verification_status_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
        verification_status_name
    FROM core.verification_statuses
    WHERE verification_status_id = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.has_child_accounts.sql --<--<--
CREATE FUNCTION core.has_child_accounts(bigint)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS(SELECT 0 FROM core.accounts WHERE parent_account_id=$1 LIMIT 1) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_leap_year.sql --<--<--
DROP FUNCTION IF EXISTS core.is_leap_year(integer);
CREATE FUNCTION core.is_leap_year(integer)
RETURNS boolean
AS
$$
BEGIN
    RETURN (SELECT date_part('day', (($1::text || '-02-01')::date + '1 month'::interval - '1 day'::interval)) = 29);
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


DROP FUNCTION IF EXISTS core.is_leap_year();
CREATE FUNCTION core.is_leap_year()
RETURNS boolean
AS
$$
BEGIN
    RETURN core.is_leap_year(core.get_current_year());
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_parent_unit.sql --<--<--
CREATE FUNCTION core.is_parent_unit(parent integer, child integer)
RETURNS boolean
AS
$$      
BEGIN
    IF $1!=$2 THEN
        IF EXISTS
        (
            WITH RECURSIVE unit_cte(unit_id) AS 
            (
             SELECT tn.compare_unit_id
                FROM core.compound_units AS tn WHERE tn.base_unit_id = $1
            UNION ALL
             SELECT
                c.compare_unit_id
                FROM unit_cte AS p, 
              core.compound_units AS c 
                WHERE base_unit_id = p.unit_id
            )

            SELECT * FROM unit_cte
            WHERE unit_id=$2
        ) THEN
            RETURN TRUE;
        END IF;
    END IF;
    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_stock_item.sql --<--<--
DROP FUNCTION IF EXISTS core.is_stock_item(item_id integer);

CREATE FUNCTION core.is_stock_item(item_id integer)
RETURNS bool
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM core.items WHERE core.items.item_id=$1 AND maintain_stock=true
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.is_stock_item(item_code national character varying(12));

CREATE FUNCTION core.is_stock_item(item_code national character varying(12))
RETURNS bool
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM core.items WHERE core.items.item_code=$1 AND maintain_stock=true
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_supplier.sql --<--<--
CREATE FUNCTION core.is_supplier(bigint)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM core.parties 
        INNER JOIN core.party_types 
        ON core.parties.party_type_id=core.party_types.party_type_id
        WHERE core.parties.party_id=$1
        AND core.party_types.is_supplier=true
    ) THEN
        RETURN true;
    END IF;
    
    RETURN false;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_valid_item_id.sql --<--<--
DROP FUNCTION IF EXISTS core.is_valid_item_id(integer);

CREATE FUNCTION core.is_valid_item_id(integer)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT 1 FROM core.items WHERE item_id=$1) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_valid_unit.sql --<--<--
DROP FUNCTION IF EXISTS core.is_valid_unit(_item_id integer, _unit_id integer);

CREATE FUNCTION core.is_valid_unit(_item_id integer, _unit_id integer)
RETURNS boolean
AS
$$
        DECLARE _item_unit_id integer;
BEGIN
        SELECT unit_id INTO _item_unit_id
        FROM core.items
        WHERE item_id=$1;

        IF(core.get_root_unit_id(_item_unit_id) = core.get_root_unit_id(_unit_id)) THEN
                RETURN true;
        END IF;

        RETURN false;        
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/core/core.is_valid_unit_id.sql --<--<--
DROP FUNCTION IF EXISTS core.is_valid_unit_id(integer);

CREATE FUNCTION core.is_valid_unit_id(integer)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT 1 FROM core.units WHERE unit_id=$1) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.is_valid_unit_id(_unit_id integer, _item_id integer);

CREATE FUNCTION core.is_valid_unit_id(_unit_id integer, _item_id integer)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS
        (
                SELECT 1
                FROM core.items
                WHERE item_id = $2
                AND core.get_root_unit_id($1) = core.get_root_unit_id(unit_id)
        ) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/audit/audit.get_office_information_model.sql --<--<--
DROP FUNCTION IF EXISTS audit.get_office_information_model(integer);

CREATE FUNCTION audit.get_office_information_model(integer)
RETURNS TABLE
(
    office              text,
    logged_in_to        text,
    last_login_ip       text,
    last_login_on       TIMESTAMP WITH TIME ZONE,
    current_ip          text,
    current_login_on    TIMESTAMP WITH TIME ZONE,
    role                text,
    department          text
)
VOLATILE
AS
$$
BEGIN
    CREATE TEMPORARY TABLE temp_model
    (
        office              text,
        logged_in_to        text,
        last_login_ip       text,
        last_login_on       TIMESTAMP WITH TIME ZONE,
        current_ip          text,
        current_login_on    TIMESTAMP WITH TIME ZONE,
        role                text,
        department          text
    ) ON COMMIT DROP;


    INSERT INTO temp_model(office, role, department)
    SELECT 
        office.offices.office_code || ' (' || office.offices.office_name || ')',
        office.roles.role_code || ' (' || office.roles.role_name || ')',
        office.departments.department_code || ' (' || office.departments.department_name
    FROM office.users
    INNER JOIN office.offices
    ON office.users.office_id = office.users.office_id
    INNER JOIN office.roles
    ON office.users.role_id = office.roles.role_id
    INNER JOIN office.departments
    ON office.users.department_id = office.departments.department_id
    WHERE office.users.user_id = $1;

    WITH login_info
    AS
    (
        SELECT 
            office.offices.office_code || ' (' || office.offices.office_name || ')' AS logged_in_to,
            ip_address AS current_ip,
            login_date_time AS current_login_on
        FROM audit.logins
        INNER JOIN office.offices
        ON audit.logins.office_id = office.offices.office_id
        WHERE user_id = $1
        AND login_date_time = 
        (
            SELECT max(login_date_time)
            FROM audit.logins
            WHERE user_id = $1
        )
    )

    UPDATE temp_model
    SET 
        logged_in_to        = login_info.logged_in_to,
        current_ip          = login_info.current_ip,
        current_login_on    = login_info.current_login_on
    FROM login_info;


    WITH last_login_info
    AS
    (
        SELECT 
            ip_address          AS last_login_ip,
            login_date_time     AS last_login_on
        FROM audit.logins
        WHERE user_id = $1
        AND login_date_time < 
        (
            SELECT max(login_date_time)
            FROM audit.logins
            WHERE user_id = $1
        )
        ORDER BY login_date_time DESC
        LIMIT 1
    )
    UPDATE temp_model
    SET 
        last_login_ip       = last_login_info.last_login_ip,
        last_login_on       = last_login_info.last_login_on
    FROM last_login_info;
    
    
    RETURN QUERY
    SELECT * FROM temp_model;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.calculate_interest.sql --<--<--
DROP FUNCTION IF EXISTS core.calculate_interest(principal numeric, rate numeric, days integer, num_of_days_in_year integer, round_up integer);
CREATE FUNCTION core.calculate_interest(principal numeric, rate numeric, days integer, round_up integer, num_of_days_in_year integer)
RETURNS numeric
AS
$$
    DECLARE interest numeric;
BEGIN
    IF num_of_days_in_year = 0 OR num_of_days_in_year IS NULL THEN
        RAISE EXCEPTION 'Cannot calculate interest. The number of days in a year was not provided.'
        USING ERRCODE='P1301';
    END IF;
    
    interest := ROUND(principal * rate * days / (num_of_days_in_year * 100), round_up);

    RETURN interest;
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;


DROP FUNCTION IF EXISTS core.calculate_interest(principal numeric, rate numeric, days integer, round_up integer);
CREATE FUNCTION core.calculate_interest(principal numeric, rate numeric, days integer, round_up integer)
RETURNS numeric
AS
$$
    DECLARE num_of_days_in_year integer = 365;
BEGIN
    IF core.is_leap_year() THEN
        num_of_days_in_year = 366;
    END IF;
    
    RETURN core.calculate_interest(principal, rate, days, round_up, num_of_days_in_year);
END
$$
LANGUAGE plpgsql
IMMUTABLE STRICT;



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.dates.sql --<--<--
DROP FUNCTION IF EXISTS core.get_date(_office_id integer);

CREATE FUNCTION core.get_date(_office_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN transactions.get_value_date($1);
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.get_month_end_date(_office_id integer);

CREATE FUNCTION core.get_month_end_date(_office_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN MIN(value_date) 
    FROM core.frequency_setups
    WHERE value_date >= transactions.get_value_date($1);
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.get_month_start_date(_office_id integer);

CREATE FUNCTION core.get_month_start_date(_office_id integer)
RETURNS date
AS
$$
    DECLARE _date               date;
BEGIN
    SELECT MAX(value_date) + 1
    INTO _date
    FROM core.frequency_setups
    WHERE value_date < 
    (
        SELECT MIN(value_date)
        FROM core.frequency_setups
        WHERE value_date >= transactions.get_value_date($1)
    );

    IF(_date IS NULL) THEN
        SELECT starts_from 
        INTO _date
        FROM core.fiscal_year;
    END IF;

    RETURN _date;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.get_quarter_end_date(_office_id integer);

CREATE FUNCTION core.get_quarter_end_date(_office_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN MIN(value_date) 
    FROM core.frequency_setups
    WHERE value_date >= transactions.get_value_date($1)
    AND frequency_id > 2;
END
$$
LANGUAGE plpgsql;



DROP FUNCTION IF EXISTS core.get_quarter_start_date(_office_id integer);

CREATE FUNCTION core.get_quarter_start_date(_office_id integer)
RETURNS date
AS
$$
    DECLARE _date               date;
BEGIN
    SELECT MAX(value_date) + 1
    INTO _date
    FROM core.frequency_setups
    WHERE value_date < 
    (
        SELECT MIN(value_date)
        FROM core.frequency_setups
        WHERE value_date >= transactions.get_value_date($1)
    )
    AND frequency_id > 2;

    IF(_date IS NULL) THEN
        SELECT starts_from 
        INTO _date
        FROM core.fiscal_year;
    END IF;

    RETURN _date;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS core.get_fiscal_half_end_date(_office_id integer);

CREATE FUNCTION core.get_fiscal_half_end_date(_office_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN MIN(value_date) 
    FROM core.frequency_setups
    WHERE value_date >= transactions.get_value_date($1)
    AND frequency_id > 3;
END
$$
LANGUAGE plpgsql;



DROP FUNCTION IF EXISTS core.get_fiscal_half_start_date(_office_id integer);

CREATE FUNCTION core.get_fiscal_half_start_date(_office_id integer)
RETURNS date
AS
$$
    DECLARE _date               date;
BEGIN
    SELECT MAX(value_date) + 1
    INTO _date
    FROM core.frequency_setups
    WHERE value_date < 
    (
        SELECT MIN(value_date)
        FROM core.frequency_setups
        WHERE value_date >= transactions.get_value_date($1)
    )
    AND frequency_id > 3;

    IF(_date IS NULL) THEN
        SELECT starts_from 
        INTO _date
        FROM core.fiscal_year;
    END IF;

    RETURN _date;
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS core.get_fiscal_year_end_date(_office_id integer);

CREATE FUNCTION core.get_fiscal_year_end_date(_office_id integer)
RETURNS date
AS
$$
BEGIN
    RETURN MIN(value_date) 
    FROM core.frequency_setups
    WHERE value_date >= transactions.get_value_date($1)
    AND frequency_id > 4;
END
$$
LANGUAGE plpgsql;



DROP FUNCTION IF EXISTS core.get_fiscal_year_start_date(_office_id integer);

CREATE FUNCTION core.get_fiscal_year_start_date(_office_id integer)
RETURNS date
AS
$$
    DECLARE _date               date;
BEGIN

    SELECT starts_from 
    INTO _date
    FROM core.fiscal_year;

    RETURN _date;
END
$$
LANGUAGE plpgsql;

--SELECT core.get_date(1), core.get_month_start_date(1),core.get_month_end_date(1), core.get_quarter_start_date(1), core.get_quarter_end_date(1), core.get_fiscal_half_start_date(1), core.get_fiscal_half_end_date(1), core.get_fiscal_year_start_date(1), core.get_fiscal_year_end_date(1);






-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_account_view_by_account_master_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_account_view_by_account_master_id
(
    _account_master_id      integer,
    _row_number             integer
);

CREATE FUNCTION core.get_account_view_by_account_master_id
(
    _account_master_id      integer,
    _row_number             integer
)
RETURNS table
(
    id                      bigint,
    account_id              bigint,
    account_name            text    
)
AS
$$
BEGIN
    RETURN QUERY
    SELECT ROW_NUMBER() OVER (ORDER BY accounts.account_id) +_row_number, * FROM 
    (
        SELECT core.accounts.account_id, core.get_account_name_by_account_id(core.accounts.account_id)
        FROM core.accounts
        WHERE core.accounts.account_master_id = _account_master_id
    ) AS accounts;    
END;
$$
LANGUAGE plpgsql;



















-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_base_quantity_by_unit_id.sql --<--<--
DROP FUNCTION IF EXISTS core.get_base_quantity_by_unit_id(integer, integer);

CREATE FUNCTION core.get_base_quantity_by_unit_id(integer, integer)
RETURNS decimal
AS
$$
DECLARE _root_unit_id integer;
DECLARE _factor decimal;
BEGIN
    _root_unit_id = core.get_root_unit_id($1);
    _factor = core.convert_unit($1, _root_unit_id);

    RETURN _factor * $2;
END
$$
LANGUAGE plpgsql;



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/


DROP FUNCTION IF EXISTS unit_tests.get_base_quantity_by_unit_id_test();

CREATE FUNCTION unit_tests.get_base_quantity_by_unit_id_test()
RETURNS public.test_result
AS
$$
    DECLARE message test_result;
    DECLARE result boolean;
    DECLARE actual decimal;
    DECLARE expected decimal=345;
BEGIN

        INSERT INTO core.units(unit_code, unit_name)
        SELECT 'TUC-0000001', 'Test Unit 1' UNION ALL 
        SELECT 'TUC-0000002', 'Test Unit 2';


        INSERT INTO core.compound_units(base_unit_id, compare_unit_id, value)
        SELECT core.get_unit_id_by_unit_code('TUC-0000001'), core.get_unit_id_by_unit_code('TUC-0000002'), 345;

        SELECT core.get_base_quantity_by_unit_id(core.get_unit_id_by_unit_code('TUC-0000002'), 1) INTO actual;

        DELETE FROM core.compound_units WHERE base_unit_id = core.get_unit_id_by_unit_code('TUC-0000001');
        DELETE FROM core.units WHERE unit_code IN('TUC-0000001', 'TUC-0000002');

        RAISE NOTICE '%', actual;

        SELECT * FROM assert.is_equal(actual, expected) INTO message, result;        

        IF(result = false) THEN
                RETURN message;
        END IF;

        SELECT assert.ok('End of test.') INTO message;  
        RETURN message;
END
$$
LANGUAGE plpgsql;






-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_field.sql --<--<--
DROP FUNCTION IF EXISTS core.get_field(this HSTORE, _column_name text);

CREATE FUNCTION core.get_field(this HSTORE, _column_name text)
RETURNS text
AS
$$
   DECLARE _field_value text;
BEGIN
    _field_value := this->_column_name;
    RETURN _field_value;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_income_tax_provison_amount.sql --<--<--
DROP FUNCTION IF EXISTS core.get_income_tax_provison_amount(_office_id integer, _profit  decimal(24, 4), _balance  decimal(24, 4));

CREATE FUNCTION core.get_income_tax_provison_amount(_office_id integer, _profit decimal(24, 4), _balance decimal(24, 4))
RETURNS  decimal(24, 4)
AS
$$
    DECLARE _rate real;
BEGIN
    _rate := core.get_income_tax_rate(_office_id);

    RETURN
    (
        (_profit * _rate/100) - _balance
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_income_tax_rate.sql --<--<--
DROP FUNCTION IF EXISTS core.get_income_tax_rate(_office_id integer);

CREATE FUNCTION core.get_income_tax_rate(_office_id integer)
RETURNS real
AS
$$
BEGIN
    RETURN 19.00;--TODO
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_item_cost_price.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_cost_price(item_id_ integer, party_id_ bigint, unit_id_ integer);
CREATE FUNCTION core.get_item_cost_price(item_id_ integer, party_id_ bigint, unit_id_ integer)
RETURNS money_strict2
AS
$$
    DECLARE _price money_strict2;
    DECLARE _unit_id integer;
    DECLARE _factor decimal;
    DECLARE _tax_rate decimal;
    DECLARE _includes_tax boolean;
    DECLARE _tax money_strict2;
BEGIN

    --Fist pick the catalog price which matches all these fields:
    --Item, Customer Type, Price Type, and Unit.
    --This is the most effective price.
    SELECT 
        item_cost_prices.price, 
        item_cost_prices.unit_id,
        item_cost_prices.includes_tax
    INTO 
        _price, 
        _unit_id,
        _includes_tax       
    FROM core.item_cost_prices
    WHERE item_cost_prices.item_id=$1
    AND item_cost_prices.party_id=$2
    AND item_cost_prices.unit_id = $3;

    IF(_unit_id IS NULL) THEN
        --We do not have a cost price of this item for the unit supplied.
        --Let's see if this item has a price for other units.
        SELECT 
            item_cost_prices.price, 
            item_cost_prices.unit_id,
            item_cost_prices.includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.item_cost_prices
        WHERE item_cost_prices.item_id=$1
        AND item_cost_prices.party_id=$2;
    END IF;

    
    IF(_price IS NULL) THEN
        --This item does not have cost price defined in the catalog.
        --Therefore, getting the default cost price from the item definition.
        SELECT 
            cost_price, 
            unit_id,
            cost_price_includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.items
        WHERE core.items.item_id = $1;
    END IF;

    IF(_includes_tax) THEN
        _tax_rate := core.get_item_tax_rate($1);
        _price := _price / ((100 + _tax_rate)/ 100);
    END IF;

    --Get the unitary conversion factor if the requested unit does not match with the price defition.
    _factor := core.convert_unit($3, _unit_id);

    RETURN _price * _factor;
END
$$
LANGUAGE plpgsql;


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_item_selling_price.sql --<--<--
DROP FUNCTION IF EXISTS core.get_item_selling_price(item_id_ integer, party_type_id_ integer, price_type_id_ integer, unit_id_ integer);
CREATE FUNCTION core.get_item_selling_price(item_id_ integer, party_type_id_ integer, price_type_id_ integer, unit_id_ integer)
RETURNS money_strict2
AS
$$
    DECLARE _price money_strict2;
    DECLARE _unit_id integer;
    DECLARE _factor decimal;
    DECLARE _tax_rate decimal;
    DECLARE _includes_tax boolean;
    DECLARE _tax money_strict2;
BEGIN

    --Fist pick the catalog price which matches all these fields:
    --Item, Customer Type, Price Type, and Unit.
    --This is the most effective price.
    SELECT 
        item_selling_prices.price, 
        item_selling_prices.unit_id,
        item_selling_prices.includes_tax
    INTO 
        _price, 
        _unit_id,
        _includes_tax       
    FROM core.item_selling_prices
    WHERE item_selling_prices.item_id=$1
    AND item_selling_prices.party_type_id=$2
    AND item_selling_prices.price_type_id =$3
    AND item_selling_prices.unit_id = $4;

    IF(_unit_id IS NULL) THEN
        --We do not have a selling price of this item for the unit supplied.
        --Let's see if this item has a price for other units.
        SELECT 
            item_selling_prices.price, 
            item_selling_prices.unit_id,
            item_selling_prices.includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.item_selling_prices
        WHERE item_selling_prices.item_id=$1
        AND item_selling_prices.party_type_id=$2
        AND item_selling_prices.price_type_id =$3;
    END IF;

    
    IF(_price IS NULL) THEN
        --This item does not have selling price defined in the catalog.
        --Therefore, getting the default selling price from the item definition.
        SELECT 
            selling_price, 
            unit_id,
            selling_price_includes_tax
        INTO 
            _price, 
            _unit_id,
            _includes_tax
        FROM core.items
        WHERE core.items.item_id = $1;
    END IF;

    IF(_includes_tax) THEN
        _tax_rate := core.get_item_tax_rate($1);
        _price := _price / ((100 + _tax_rate)/ 100);
    END IF;

    --Get the unitary conversion factor if the requested unit does not match with the price defition.
    _factor := core.convert_unit($4, _unit_id);

    RETURN _price * _factor;
END
$$
LANGUAGE plpgsql;



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_ordered_quantity.sql --<--<--
DROP FUNCTION IF EXISTS core.get_ordered_quantity(_item_id integer, _unit_id integer, _office_id integer);

CREATE FUNCTION core.get_ordered_quantity(_item_id integer, _unit_id integer, _office_id integer)
RETURNS numeric
AS
$$
        DECLARE last_received_on date;
        DECLARE factor decimal(24, 8);
BEGIN
        SELECT 
        MAX(transactions.transaction_master.value_date) INTO last_received_on
        FROM transactions.transaction_master
        INNER JOIN transactions.stock_master
        ON transactions.transaction_master.transaction_master_id = transactions.stock_master.transaction_master_id
        INNER JOIN transactions.stock_details
        ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
        WHERE transactions.stock_details.item_id = $1
        AND transactions.transaction_master.office_id = $3        
        AND transactions.transaction_master.book like 'Purchase%';

        RAISE NOTICE '%', last_received_on;

        RETURN COALESCE(SUM(quantity * core.convert_unit(unit_id, $2)), 0)
        FROM transactions.non_gl_stock_details
        INNER JOIN transactions.non_gl_stock_master
        ON transactions.non_gl_stock_details.non_gl_stock_master_id = transactions.non_gl_stock_master.non_gl_stock_master_id
        WHERE transactions.non_gl_stock_master.office_id = $3        
        AND item_id = $1
        AND transactions.non_gl_stock_details.value_date > last_received_on
        AND transactions.non_gl_stock_master.book = 'Purchase.Order';
        
END
$$
LANGUAGE plpgsql;



--SELECT core.get_ordered_quantity(17, 1, 2);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_periods.sql --<--<--
DROP FUNCTION IF EXISTS core.get_periods
(
    _date_from                      date,
    _date_to                        date
);

CREATE FUNCTION core.get_periods
(
    _date_from                      date,
    _date_to                        date
)
RETURNS core.period[]
AS
$$
BEGIN
    RETURN 
        array_agg
        (
            (
                core.get_frequency_setup_code_by_frequency_setup_id(frequency_setup_id),
                core.get_frequency_setup_start_date_frequency_setup_id(frequency_setup_id),
                core.get_frequency_setup_end_date_frequency_setup_id(frequency_setup_id)
            )::core.period
        )::core.period[]
    FROM core.frequency_setups
    WHERE value_date BETWEEN _date_from AND _date_to;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.get_workflow_model.sql --<--<--
DROP FUNCTION IF EXISTS core.get_workflow_model();

CREATE FUNCTION core.get_workflow_model()
RETURNS TABLE
(
    flagged_transactions        integer,
    in_verification_stack       integer,
    auto_approved               integer,
    approved                    integer,
    rejected                    integer,
    closed                      integer,
    withdrawn                   integer
)
VOLATILE
AS
$$
    DECLARE _flagged            integer;
    DECLARE _in_verification    integer;
    DECLARE _auto_approved      integer;
    DECLARE _approved           integer;
    DECLARE _rejected           integer;
    DECLARE _closed             integer;
    DECLARE _withdrawn          integer;
BEGIN
    SELECT COUNT(*) INTO _flagged 
    FROM core.flags;

    SELECT COUNT(*) INTO _in_verification
    FROM transactions.transaction_master
    WHERE verification_status_id = 0;

    SELECT COUNT(*) INTO _auto_approved
    FROM transactions.transaction_master
    WHERE verification_status_id = 1;

    SELECT COUNT(*) INTO _approved
    FROM transactions.transaction_master
    WHERE verification_status_id = 2;

    SELECT COUNT(*) INTO _rejected
    FROM transactions.transaction_master
    WHERE verification_status_id = -3;

    SELECT COUNT(*) INTO _closed
    FROM transactions.transaction_master
    WHERE verification_status_id = -2;

    SELECT COUNT(*) INTO _withdrawn
    FROM transactions.transaction_master
    WHERE verification_status_id = -1;

    RETURN QUERY
    SELECT
        _flagged, 
        _in_verification, 
        _auto_approved,
        _approved,
        _rejected,
        _closed,
        _withdrawn;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.is_cash_account_id.sql --<--<--
DROP FUNCTION IF EXISTS core.is_cash_account_id(_account_id bigint);

CREATE FUNCTION core.is_cash_account_id(_account_id bigint)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM core.accounts WHERE account_master_id IN(10101)
        AND account_id=$1
    ) THEN
        RETURN true;
    END IF;
    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/core/core.is_cash_equivalent.sql --<--<--
DROP FUNCTION IF EXISTS core.is_cash_equivalent(_account_id bigint);

CREATE FUNCTION core.is_cash_equivalent(_account_id bigint)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1 FROM core.accounts WHERE account_master_id IN(10101, 10102)
        AND account_id=$1
    ) THEN
        RETURN true;
    END IF;
    RETURN false;
END
$$
LANGUAGE plpgsql;

ALTER TABLE office.stores
ADD CONSTRAINT stores_default_cash_account_id_chk
CHECK(core.is_cash_equivalent(default_cash_account_id));


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/office/office.can_login.sql --<--<--
DROP FUNCTION IF EXISTS office.can_login(user_id integer_strict, office_id integer_strict, OUT result boolean, OUT message text);
CREATE FUNCTION office.can_login(user_id integer_strict, office_id integer_strict, OUT result boolean, OUT message text)
RETURNS RECORD
AS
$$
DECLARE _office_id      integer;
BEGIN
    _office_id  := office.get_office_id_by_user_id($1);
    message     := '';

    IF $1 = office.get_sys_user_id() THEN
        result = false;
    END IF;

    IF $2=_office_id THEN
        result = true;
    ELSE
        IF office.is_parent_office(_office_id,$2) THEN
            result = true;
        END IF;
    END IF;

    IF(result) THEN
        IF(policy.is_restricted_mode() AND NOT policy.is_elevated_user($1)) THEN
            result := false;
            message := 'You need to have an elevated priviledge to login interactively during end of day operation';
            RAISE WARNING '%', message;
        END IF;
    END IF;
    
    RETURN;
END;
$$
LANGUAGE plpgsql;




/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/office/office.has_child_offices.sql --<--<--
CREATE FUNCTION office.has_child_offices(integer)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS(SELECT 0 FROM office.offices WHERE parent_office_id=$1 LIMIT 1) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/office/office.sign_in.sql --<--<--
DROP FUNCTION IF EXISTS office.sign_in
(
    office_id       integer_strict, 
    user_name       text, 
    password        text, 
    browser         text, 
    ip_address      text, 
    remote_user     text, 
    culture         text, 
    challenge       text, 
    OUT login_id    bigint, 
    OUT message     text
);
CREATE FUNCTION office.sign_in
(
    office_id       integer_strict, 
    user_name       text, 
    password        text, 
    browser         text, 
    ip_address      text, 
    remote_user     text, 
    culture         text, 
    challenge       text, 
    OUT login_id    bigint, 
    OUT message     text
)
RETURNS RECORD
AS
$$
    DECLARE _user_id            integer;
    DECLARE _lock_out_till      TIMESTAMP WITH TIME ZONE;
    DECLARE result              boolean;
BEGIN
    _user_id        :=office.get_user_id_by_user_name($2);
    login_id        := 0;
    
    IF _user_id IS NULL THEN
        INSERT INTO audit.failed_logins(user_name,browser,ip_address,remote_user,details)
        SELECT $2, $4, $5, $6, 'Invalid user name.';
        message := 'Invalid login attempt.';
    ELSE
        _lock_out_till:=policy.is_locked_out_till(_user_id);


        IF NOT ((_lock_out_till IS NOT NULL) AND (_lock_out_till>NOW())) THEN
            IF(office.validate_login($2,$3, $8)) THEN

                SELECT * FROM office.can_login(_user_id,$1) 
                INTO result, message;

                IF(result) THEN
                    INSERT INTO audit.logins(office_id,user_id,browser,ip_address,remote_user, culture)
                    SELECT $1, _user_id, $4, $5, $6, $7;

                    login_id := currval('audit.logins_login_id_seq')::bigint;
                ELSE
                    IF(COALESCE(message, '') = '') THEN
                        message := format('A user from %1$s cannot login to %2$s.', office.get_office_name_by_id(office.get_office_id_by_user_id(_user_id)), office.get_office_name_by_id($1));
                    END IF;

                    INSERT INTO audit.failed_logins(office_id,user_id,user_name,browser,ip_address,remote_user,details)
                    SELECT $1, _user_id, $2, $4, $5, $6, message;
                END IF;
            ELSE
                IF(COALESCE(message, '') = '') THEN
                    message := 'Invalid login attempt.';
                END IF;
                
                INSERT INTO audit.failed_logins(office_id,user_id,user_name,browser,ip_address,remote_user,details)
                SELECT $1, _user_id, $2, $4, $5, $6, message;
            END IF;
        ELSE
             message        := format('You are locked out till %1$s.', _lock_out_till);

            INSERT INTO audit.failed_logins(office_id,user_id,user_name,browser,ip_address,remote_user,details)
            SELECT $1, _user_id, $2, $4, $5, $6, message;
        END IF;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM office.sign_in(2, 'binod2', '4e99cb7523794ad53b4da66c91f56d0143a679e1c6d396cda9ad0c9b41ed53e90bd5c59bf98255a4f1946b216b3ba539074a8a86cedd4af8bb208a8fad748e82', 'Firefox', '0.0.0.0', 'N/A', 'en-US', 'cd0ad7446ab64801837bfd43197d19c1');


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.can_post_transaction.sql --<--<--
DROP FUNCTION IF EXISTS policy.can_post_transaction(_login_id bigint, _user_id integer, _office_id integer, transaction_book text, _value_date date);

CREATE FUNCTION policy.can_post_transaction(_login_id bigint, _user_id integer, _office_id integer, transaction_book text, _value_date date)
RETURNS bool
AS
$$
BEGIN
    IF(audit.is_valid_login_id(_login_id) = false) THEN
        RAISE EXCEPTION 'Invalid LoginId.'
        USING ERRCODE='P3101';
    END IF; 

    IF(office.is_valid_office_id(_office_id) = false) THEN
        RAISE EXCEPTION 'Invalid OfficeId.'
        USING ERRCODE='P3010';
    END IF;

    IF(policy.is_transaction_restricted(_office_id)) THEN
        RAISE EXCEPTION 'This establishment does not allow transaction posting.'
        USING ERRCODE='P5100';
    END IF;
    
    IF(policy.is_restricted_mode()) THEN
        RAISE EXCEPTION 'Cannot post transaction during restricted transaction mode.'
        USING ERRCODE='P5101';
    END IF;

    IF(_value_date < transactions.get_value_date(_office_id)) THEN
        RAISE EXCEPTION 'Past dated transactions are not allowed.'
        USING ERRCODE='P5010';
    END IF;
    
    IF NOT EXISTS 
    (
        SELECT *
        FROM office.users
        INNER JOIN office.roles
        ON office.users.role_id = office.roles.role_id
        WHERE is_system=false
        AND user_id = $2
    ) THEN
        RAISE EXCEPTION 'Access is denied. You are not authorized to post this transaction.'
        USING ERRCODE='P9010';        
    END IF;

    RETURN true;
END
$$
LANGUAGE plpgsql;




/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.change_password.sql --<--<--
DROP FUNCTION IF EXISTS policy.change_password
(
    _user_name          text,
    _current_password   text,
    _new_password       text
);

CREATE FUNCTION policy.change_password
(
    _user_name          text,
    _current_password   text,
    _new_password       text
)
RETURNS boolean
VOLATILE
AS
$$
BEGIN
    IF(COALESCE($1, '') = '') THEN
        RAISE EXCEPTION 'Invalid user name.'
        USING ERRCODE='P3001';
    END IF;

    IF(COALESCE($2, '') = '' OR COALESCE($3, '') = '') THEN
        RAISE EXCEPTION 'Password cannot be empty.'
        USING ERRCODE='P3005';
    END IF;

    IF($2=$3) THEN
        RAISE EXCEPTION 'Please provide a new password.'
        USING ERRCODE='P3006';
    END IF;

    IF NOT EXISTS
    (
        SELECT * FROM office.users
        WHERE user_name = $1
        AND can_change_password
        AND role_id NOT IN
        (
            SELECT role_id FROM office.roles
            WHERE is_system
        )
    ) THEN
        RAISE EXCEPTION 'Access is denied.'
        USING ERRCODE='P9001';
    END IF;

    IF NOT EXISTS
    (
        SELECT * FROM office.users 
        WHERE office.users.user_name=$1
        AND encode(digest($1 || $2, 'sha512'), 'hex') = office.users.password 
    ) THEN
        RAISE EXCEPTION 'Your current password is incorrect.'
        USING ERRCODE='P3104';
    END IF;

    UPDATE office.users
    SET password = encode(digest($1 || $3, 'sha512'), 'hex')
    WHERE office.users.user_name=$1;
    

    RETURN true;
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS policy.change_password
(
    _admin_user_id          integer,
    _user_name              text,
    _new_password           text
);

CREATE FUNCTION policy.change_password
(
    _admin_user_id          integer,
    _user_name              text,
    _new_password           text
)
RETURNS void
VOLATILE
AS
$$
    DECLARE _user_id            integer;
    DECLARE _office_id          integer;
    DECLARE _admin_office_id    integer;
BEGIN
    IF(COALESCE($2, '') = '') THEN
        RAISE EXCEPTION 'Invalid user name.'
        USING ERRCODE='P3001';
    END IF;

    IF(COALESCE($3, '') = '') THEN
        RAISE EXCEPTION 'Password cannot be empty.'
        USING ERRCODE='P3005';
    END IF;

    SELECT 
        office.users.user_id,
        office.users.office_id
    INTO
        _user_id,
        _office_id
    FROM office.users
    WHERE office.users.user_name=_user_name;

    IF(COALESCE(_user_id, 0) = 0) THEN
        RAISE EXCEPTION 'Invalid user name.'
        USING ERRCODE='P3001';
    END IF;

    IF(NOT office.is_admin(_admin_user_id)) THEN
        RAISE EXCEPTION 'Access is denied.'
        USING ERRCODE='P9001';
    END IF;

    SELECT office.users.office_id INTO _admin_office_id
    FROM office.users
    WHERE office.users.user_id = _admin_user_id;

    IF(_admin_office_id != _office_id AND NOT office.is_parent_office(_admin_office_id, _office_id)) THEN
        RAISE EXCEPTION 'Access is denied.'
        USING ERRCODE='P9001';
    END IF;

    UPDATE office.users
    SET password = encode(digest($2 || $3, 'sha512'), 'hex')
    WHERE office.users.user_name=$2;    
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.get_menu.sql --<--<--
DROP FUNCTION IF EXISTS policy.get_menu
(
    _user_id    integer, 
    _office_id  integer, 
    _culture_   text
);

CREATE FUNCTION policy.get_menu
(
    _user_id    integer, 
    _office_id  integer, 
    _culture_   text
)
RETURNS TABLE
(
    menu_id         integer,
    menu_text       national character varying(250),
    url             national character varying(250),
    menu_code       character varying(12),
    level           smallint,
    parent_menu_id  integer
)
AS
$$
    DECLARE culture_exists boolean = false;
BEGIN    
    IF EXISTS(SELECT * FROM core.menu_locale WHERE culture=$3) THEN
        culture_exists := true;
    END IF;

    IF(NOT culture_exists) THEN
        IF EXISTS(SELECT * FROM core.menu_locale WHERE culture=split_part($3,'-', 1)) THEN
            $3 := split_part($3,'-', 1);
            culture_exists := true;
        END IF;
    END IF;

    IF culture_exists THEN
        RETURN QUERY 
        SELECT
            core.menus.menu_id,
            core.menu_locale.menu_text,
            core.menus.url,
            core.menus.menu_code,
            core.menus.level,
            core.menus.parent_menu_id   
        FROM core.menus
        INNER JOIN policy.menu_access
        ON core.menus.menu_id = policy.menu_access.menu_id
        INNER JOIN core.menu_locale
        ON core.menus.menu_id = core.menu_locale.menu_id
        WHERE policy.menu_access.user_id=$1
        AND policy.menu_access.office_id=$2
        AND core.menu_locale.culture=$3;
    ELSE
        RETURN QUERY 
        SELECT
            core.menus.menu_id,
            core.menus.menu_text,
            core.menus.url,
            core.menus.menu_code,
            core.menus.level,
            core.menus.parent_menu_id   
        FROM core.menus
        INNER JOIN policy.menu_access
        ON core.menus.menu_id = policy.menu_access.menu_id
        WHERE policy.menu_access.user_id=$1
        AND policy.menu_access.office_id=$2;
    END IF;

END
$$
LANGUAGE plpgsql;

--SELECT * FROM policy.get_menu(2, 2, 'de-DE');

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.get_menu_policy.sql --<--<--
DROP FUNCTION IF EXISTS policy.get_menu_policy
(
    _user_id        integer,
    _office_id      integer,
    _culture        text
);

CREATE FUNCTION policy.get_menu_policy
(
    _user_id        integer,
    _office_id      integer,
    _culture        text
)
RETURNS TABLE
(
    row_number      bigint,
    access          boolean,
    menu_id         integer,
    menu_code       text,
    menu_text       text,
    url             text
)
STABLE AS
$$
    DECLARE culture_exists boolean = false;
BEGIN
    IF EXISTS(SELECT * FROM core.menu_locale WHERE culture=$3) THEN
        culture_exists := true;
    END IF;


    IF culture_exists THEN
        RETURN QUERY 
        SELECT
            row_number() OVER(ORDER BY core.menus.menu_id),
            CASE WHEN policy.menu_access.access_id IS NOT NULL THEN true ELSE false END as access,
            core.menus.menu_id,
            core.menus.menu_code::text, 
            core.menu_locale.menu_text::text, 
            core.menus.url::text
        FROM core.menus
        INNER JOIN core.menu_locale
        ON core.menus.menu_id = core.menu_locale.menu_id
        LEFT JOIN policy.menu_access
        ON core.menus.menu_id = policy.menu_access.menu_id
        WHERE policy.menu_access.user_id = $1
        AND policy.menu_access.office_id = $2
        AND core.menu_locale.culture = $3
        ORDER BY core.menus.menu_id;

        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT
        row_number() OVER(ORDER BY core.menus.menu_id),
        CASE WHEN policy.menu_access.access_id IS NOT NULL THEN true ELSE false END as access,
        core.menus.menu_id,
        core.menus.menu_code::text, 
        core.menus.menu_text::text, 
        core.menus.url::text
    FROM core.menus
    LEFT JOIN policy.menu_access
    ON core.menus.menu_id = policy.menu_access.menu_id
    AND policy.menu_access.user_id = $1
    AND policy.menu_access.office_id = $2
    ORDER BY core.menus.menu_id;

    RETURN;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.is_transaction_restricted.sql --<--<--
DROP FUNCTION IF EXISTS policy.is_transaction_restricted
(
    _office_id      integer
);

CREATE FUNCTION policy.is_transaction_restricted
(
    _office_id      integer
)
RETURNS boolean
STABLE
AS
$$
BEGIN
    RETURN NOT allow_transaction_posting
    FROM office.offices
    WHERE office_id=$1;
END
$$
LANGUAGE plpgsql;

ALTER TABLE transactions.transaction_master
ADD CONSTRAINT transaction_master_office_id_chk
CHECK(NOT policy.is_transaction_restricted(office_id));

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/policy/policy.save_menu_policy.sql --<--<--
DROP FUNCTION IF EXISTS policy.save_menu_policy
(
    _user_id        integer,
    _office_id      integer,
    _menu_ids       int[]
);

CREATE FUNCTION policy.save_menu_policy
(
    _user_id        integer,
    _office_id      integer,
    _menu_ids       int[]
)
RETURNS void
VOLATILE AS
$$
BEGIN
    DELETE FROM policy.menu_access
    WHERE NOT policy.menu_access.menu_id = ANY(_menu_ids)
    AND user_id = _user_id
    AND office_id = _office_id;

    WITH menus
    AS
    (
        SELECT explode_array(_menu_ids) AS _menu_id
    )
    
    INSERT INTO policy.menu_access(user_id, office_id, menu_id)
    SELECT _user_id, _office_id, _menu_id
    FROM menus
    WHERE _menu_id NOT IN
    (
        SELECT menu_id
        FROM policy.menu_access
        WHERE policy.menu_access.user_id = _user_id
        AND policy.menu_access.office_id = _office_id
    );

    RETURN;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM policy.save_menu_policy(2, 2, string_to_array('1,2,3, 4', ',')::int[])

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/public/poco_get_table_function_definition.sql --<--<--
DROP FUNCTION IF EXISTS public.poco_get_table_function_definition
(
    _schema         text,
    _name           text
);

CREATE FUNCTION public.poco_get_table_function_definition
(
    _schema                 text,
    _name                   text
)
RETURNS TABLE
(
    column_name             text,
    is_nullable             text,
    udt_name                text,
    column_default          text
)
STABLE
AS
$$
    DECLARE _oid            oid;
    DECLARE _typoid         oid;
BEGIN
    SELECT 
        pg_proc.oid,
        pg_proc.prorettype
    INTO 
        _oid,
        _typoid
    FROM pg_proc
    INNER JOIN pg_namespace
    ON pg_proc.pronamespace = pg_namespace.oid
    WHERE pg_proc.proname=_name
    AND pg_namespace.nspname=_schema
    LIMIT 1;

    IF EXISTS
    (
        SELECT 1
        FROM information_schema.columns 
        WHERE table_schema=_schema 
        AND table_name=_name
    ) THEN
        RETURN QUERY
        SELECT 
            information_schema.columns.column_name::text, 
            information_schema.columns.is_nullable::text, 
            information_schema.columns.udt_name::text, 
            information_schema.columns.column_default::text
        FROM information_schema.columns 
        WHERE table_schema=_schema 
        AND table_name=_name;
        RETURN;
    END IF;

    IF EXISTS(SELECT * FROM pg_type WHERE oid = _typoid AND typtype='c') THEN
        --Composite Type
        RETURN QUERY
        SELECT 
            attname::text               AS column_name,
            'NO'::text                  AS is_nullable, 
            format_type(t.oid,NULL)     AS udt_name,
            ''::text                    AS column_default
        FROM pg_attribute att
        JOIN pg_type t ON t.oid=atttypid
        JOIN pg_namespace nsp ON t.typnamespace=nsp.oid
        LEFT OUTER JOIN pg_type b ON t.typelem=b.oid
        LEFT OUTER JOIN pg_collation c ON att.attcollation=c.oid
        LEFT OUTER JOIN pg_namespace nspc ON c.collnamespace=nspc.oid
        WHERE att.attrelid=(SELECT typrelid FROM pg_type WHERE pg_type.oid = _typoid)
        ORDER by attnum;
        RETURN;
    END IF;

    IF(_oid IS NOT NULL) THEN
        RETURN QUERY
        WITH procs
        AS
        (
            SELECT 
            explode_array(proargnames) as column_name,
            explode_array(proargmodes) as column_mode,
            explode_array(proallargtypes) as argument_type
            FROM pg_proc
            WHERE oid = _oid
        )
        SELECT 
            procs.column_name::text,
            'NO'::text AS is_nullable, 
            format_type(procs.argument_type, null) as udt_name,
            ''::text AS column_default
        FROM procs
        WHERE column_mode=ANY(ARRAY['t', 'o']);

        RETURN;
    END IF;

    RETURN QUERY
    SELECT 
        attname::text               AS column_name,
        'NO'::text                  AS is_nullable, 
        format_type(t.oid,NULL)     AS udt_name,
        ''::text                    AS column_default
    FROM pg_attribute att
    JOIN pg_type t ON t.oid=atttypid
    JOIN pg_namespace nsp ON t.typnamespace=nsp.oid
    LEFT OUTER JOIN pg_type b ON t.typelem=b.oid
    LEFT OUTER JOIN pg_collation c ON att.attcollation=c.oid
    LEFT OUTER JOIN pg_namespace nspc ON c.collnamespace=nspc.oid
    WHERE att.attrelid=
    (
        SELECT typrelid 
        FROM pg_type
        INNER JOIN pg_namespace
        ON pg_type.typnamespace = pg_namespace.oid
        WHERE typname=_name
        AND pg_namespace.nspname=_schema
    )
    ORDER by attnum;
END;
$$
LANGUAGE plpgsql;


--SELECT * from public.poco_get_table_function_definition('office', 'get_offices');

--SELECT * FROM public.poco_get_table_function_definition('transactions', 'opening_stock_type');

--SELECT * FROM public.poco_get_table_function_definition('core', 'item_types');

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.auto_verify.sql --<--<--
DROP FUNCTION IF EXISTS transactions.auto_verify
(
    _tran_id        bigint,
    _office_id      integer
) CASCADE;

CREATE FUNCTION transactions.auto_verify
(
    _tran_id        bigint,
    _office_id      integer
)
RETURNS VOID
VOLATILE
AS
$$
    DECLARE _transaction_master_id bigint;
    DECLARE _transaction_posted_by integer;
    DECLARE _verifier integer;
    DECLARE _status integer;
    DECLARE _reason national character varying(128);
    DECLARE _rejected smallint=-3;
    DECLARE _closed smallint=-2;
    DECLARE _withdrawn smallint=-1;
    DECLARE _unapproved smallint = 0;
    DECLARE _auto_approved smallint = 1;
    DECLARE _approved smallint=2;
    DECLARE _book text;
    DECLARE _auto_verify_sales boolean;
    DECLARE _sales_verification_limit money_strict2;
    DECLARE _auto_verify_purchase boolean;
    DECLARE _purchase_verification_limit money_strict2;
    DECLARE _auto_verify_gl boolean;
    DECLARE _gl_verification_limit money_strict2;
    DECLARE _posted_amount money_strict2;
    DECLARE _auto_verification boolean=true;
    DECLARE _has_policy boolean=false;
    DECLARE _voucher_date date;
    DECLARE _value_date date=transactions.get_value_date(_office_id);
BEGIN
    _transaction_master_id := $1;

    SELECT
        transactions.transaction_master.book,
        transactions.transaction_master.value_date,
        transactions.transaction_master.user_id
    INTO
        _book,
        _voucher_date,
        _transaction_posted_by  
    FROM
    transactions.transaction_master
    WHERE transactions.transaction_master.transaction_master_id=_transaction_master_id;

    IF(_voucher_date <> _value_date) THEN
        RETURN;
    END IF;

    _verifier := office.get_sys_user_id();
    _status := 2;
    _reason := 'Automatically verified by workflow.';

    SELECT
        SUM(amount_in_local_currency)
    INTO
        _posted_amount
    FROM
        transactions.transaction_details
    WHERE transactions.transaction_details.transaction_master_id = _transaction_master_id
    AND transactions.transaction_details.tran_type='Cr';


    SELECT
        true,
        verify_sales_transactions,
        sales_verification_limit,
        verify_purchase_transactions,
        purchase_verification_limit,
        verify_gl_transactions,
        gl_verification_limit
    INTO
        _has_policy,
        _auto_verify_sales,
        _sales_verification_limit,
        _auto_verify_purchase,
        _purchase_verification_limit,
        _auto_verify_gl,
        _gl_verification_limit
    FROM
    policy.auto_verification_policy
    WHERE user_id=_transaction_posted_by
    AND is_active=true
    AND now() >= effective_from
    AND now() <= ends_on;



    IF(lower(_book) LIKE 'sales%') THEN
        IF(_auto_verify_sales = false) THEN
            _auto_verification := false;
        END IF;
        IF(_auto_verify_sales = true) THEN
            IF(_posted_amount > _sales_verification_limit AND _sales_verification_limit > 0::money_strict2) THEN
                _auto_verification := false;
            END IF;
        END IF;         
    END IF;


    IF(lower(_book) LIKE 'purchase%') THEN
        IF(_auto_verify_purchase = false) THEN
            _auto_verification := false;
        END IF;
        IF(_auto_verify_purchase = true) THEN
            IF(_posted_amount > _purchase_verification_limit AND _purchase_verification_limit > 0::money_strict2) THEN
                _auto_verification := false;
            END IF;
        END IF;         
    END IF;


    IF(lower(_book) LIKE 'journal%') THEN
        IF(_auto_verify_gl = false) THEN
            _auto_verification := false;
        END IF;
        IF(_auto_verify_gl = true) THEN
            IF(_posted_amount > _gl_verification_limit AND _gl_verification_limit > 0::money_strict2) THEN
                _auto_verification := false;
            END IF;
        END IF;         
    END IF;

    IF(_has_policy=true) THEN
        IF(_auto_verification = true) THEN
            UPDATE transactions.transaction_master
            SET 
                last_verified_on = now(),
                verified_by_user_id=_verifier,
                verification_status_id=_status,
                verification_reason=_reason
            WHERE
                transactions.transaction_master.transaction_master_id=_transaction_master_id;
        END IF;
    ELSE
        RAISE NOTICE 'No auto verification policy found for this user.';
    END IF;
    RETURN;
END
$$
LANGUAGE plpgsql;



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/


DROP FUNCTION IF EXISTS unit_tests.auto_verify_sales_test1();

CREATE FUNCTION unit_tests.auto_verify_sales_test1()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE _book_name                              national character varying(12)='Sales.Direct';
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _cost_center_id                         integer;
    DECLARE _reference_number                       national character varying(24)='Plpgunit.fixture';
    DECLARE _statement_reference                    text='Plpgunit test was here.';
    DECLARE _is_credit                              boolean=false;
    DECLARE _payment_term_id                        integer;
    DECLARE _party_code                             national character varying(12);
    DECLARE _price_type_id                          integer;
    DECLARE _salesperson_id                         integer;
    DECLARE _shipper_id                             integer;
    DECLARE _shipping_address_code                  national character varying(12)='';
    DECLARE _store_id                               integer;
    DECLARE _is_non_taxable_sales                   boolean=true;
    DECLARE _details                                transactions.stock_detail_type[];
    DECLARE _attachments                            core.attachment_type[];
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);
    _value_date         := transactions.get_value_date(_office_id);
    _cost_center_id     := office.get_cost_center_id_by_cost_center_code('dummy-cs01');
    _payment_term_id    := core.get_payment_term_id_by_payment_term_code('dummy-pt01');
    _party_code         := 'dummy-pr01';
    _price_type_id      := core.get_price_type_id_by_price_type_code('dummy-pt01');
    _salesperson_id     := core.get_salesperson_id_by_salesperson_code('dummy-sp01');
    _shipper_id         := core.get_shipper_id_by_shipper_code('dummy-sh01');
    _store_id           := office.get_store_id_by_store_code('dummy-st01');

    
    _details            := ARRAY[
                             ROW(_store_id, 'dummy-it01', 1, 'Test Mock Unit',1800000, 0, 0, '', 0)::transactions.stock_detail_type,
                             ROW(_store_id, 'dummy-it02', 2, 'Test Mock Unit',1300000, 300, 0, '', 0)::transactions.stock_detail_type];
             
    
    PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 0, true, 0, true, 0, '1-1-2000', '1-1-2020', true);


    SELECT * FROM transactions.post_sales
    (
        _book_name,_office_id, _user_id, _login_id, _value_date, _cost_center_id, _reference_number, _statement_reference,
        _is_credit, _payment_term_id, _party_code, _price_type_id, _salesperson_id, _shipper_id,
        _shipping_address_code,
        _store_id,
        _is_non_taxable_sales,
        _details,
        _attachments
    ) INTO _tran_id;

    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id < 1) THEN
        SELECT assert.fail('This transaction should have been verified.') INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS unit_tests.auto_verify_sales_test2();

CREATE FUNCTION unit_tests.auto_verify_sales_test2()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE _book_name                              national character varying(12)='Sales.Direct';
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _cost_center_id                         integer;
    DECLARE _reference_number                       national character varying(24)='Plpgunit.fixture';
    DECLARE _statement_reference                    text='Plpgunit test was here.';
    DECLARE _is_credit                              boolean=false;
    DECLARE _payment_term_id                        integer;
    DECLARE _party_code                             national character varying(12);
    DECLARE _price_type_id                          integer;
    DECLARE _salesperson_id                         integer;
    DECLARE _shipper_id                             integer;
    DECLARE _shipping_address_code                  national character varying(12)='';
    DECLARE _store_id                               integer;
    DECLARE _is_non_taxable_sales                   boolean=true;
    DECLARE _details                                transactions.stock_detail_type[];
    DECLARE _attachments                            core.attachment_type[];
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);
    _value_date         := transactions.get_value_date(_office_id);
    _cost_center_id     := office.get_cost_center_id_by_cost_center_code('dummy-cs01');
    _payment_term_id    := core.get_payment_term_id_by_payment_term_code('dummy-pt01');
    _party_code         := 'dummy-pr01';
    _price_type_id      := core.get_price_type_id_by_price_type_code('dummy-pt01');
    _salesperson_id     := core.get_salesperson_id_by_salesperson_code('dummy-sp01');
    _shipper_id         := core.get_shipper_id_by_shipper_code('dummy-sh01');
    _store_id           := office.get_store_id_by_store_code('dummy-st01');

    
    _details            := ARRAY[
                             ROW(_store_id, 'dummy-it01', 1, 'Test Mock Unit',180000, 0, 0, '', 0)::transactions.stock_detail_type,
                             ROW(_store_id, 'dummy-it02', 2, 'Test Mock Unit',130000, 300, 0, '', 0)::transactions.stock_detail_type];

    PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 100, true, 0, true, 0, '1-1-2000', '1-1-2020', true);

    SELECT * FROM transactions.post_sales
    (
        _book_name,_office_id, _user_id, _login_id, _value_date, _cost_center_id, _reference_number, _statement_reference,
        _is_credit, _payment_term_id, _party_code, _price_type_id, _salesperson_id, _shipper_id,
        _shipping_address_code,
        _store_id,
        _is_non_taxable_sales,
        _details,
        _attachments
    ) INTO _tran_id;


    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id > 0) THEN
            SELECT assert.fail('This transaction should not have been verified.') INTO message;
            RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;






DROP FUNCTION IF EXISTS unit_tests.auto_verify_purchase_test1();

CREATE FUNCTION unit_tests.auto_verify_purchase_test1()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE _book_name                              national character varying(12)='Sales.Direct';
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _cost_center_id                         integer;
    DECLARE _reference_number                       national character varying(24)='Plpgunit.fixture';
    DECLARE _statement_reference                    text='Plpgunit test was here.';
    DECLARE _is_credit                              boolean=false;
    DECLARE _payment_term_id                        integer;
    DECLARE _party_code                             national character varying(12);
    DECLARE _price_type_id                          integer;
    DECLARE _shipper_id                             integer;
    DECLARE _store_id                               integer;
    DECLARE _is_non_taxable_sales                   boolean=true;
    DECLARE _tran_ids                               bigint[];
    DECLARE _details                                transactions.stock_detail_type[];
    DECLARE _attachments                            core.attachment_type[];
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);
    _value_date         := transactions.get_value_date(_office_id);
    _cost_center_id     := office.get_cost_center_id_by_cost_center_code('dummy-cs01');
    _party_code         := 'dummy-pr01';
    _price_type_id      := core.get_price_type_id_by_price_type_code('dummy-pt01');
    _shipper_id         := core.get_shipper_id_by_shipper_code('dummy-sh01');
    _store_id           := office.get_store_id_by_store_code('dummy-st01');

    
    _details            := ARRAY[
                             ROW(_store_id, 'dummy-it01', 1, 'Test Mock Unit',180000, 0, 0, '', 0)::transactions.stock_detail_type,
                             ROW(_store_id, 'dummy-it02', 2, 'Test Mock Unit',130000, 300, 0, '', 0)::transactions.stock_detail_type];

    PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 0, true, 0, true, 0, '1-1-2000', '1-1-2020', true);

    SELECT * FROM transactions.post_purchase
    (
        _book_name,_office_id, _user_id, _login_id, _value_date, _cost_center_id, _reference_number, _statement_reference,
        _is_credit, _party_code, _price_type_id, _shipper_id,
        _store_id, _tran_ids, _details, _attachments
    ) INTO _tran_id;


    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id < 1) THEN
            SELECT assert.fail('This transaction should have been verified.') INTO message;
            RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS unit_tests.auto_verify_purchase_test2();

CREATE FUNCTION unit_tests.auto_verify_purchase_test2()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE _book_name                              national character varying(12)='Sales.Direct';
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _cost_center_id                         integer;
    DECLARE _reference_number                       national character varying(24)='Plpgunit.fixture';
    DECLARE _statement_reference                    text='Plpgunit test was here.';
    DECLARE _is_credit                              boolean=false;
    DECLARE _payment_term_id                        integer;
    DECLARE _party_code                             national character varying(12);
    DECLARE _price_type_id                          integer;
    DECLARE _shipper_id                             integer;
    DECLARE _store_id                               integer;
    DECLARE _is_non_taxable_sales                   boolean=true;
    DECLARE _tran_ids                               bigint[];
    DECLARE _details                                transactions.stock_detail_type[];
    DECLARE _attachments                            core.attachment_type[];
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);
    _value_date         := transactions.get_value_date(_office_id);
    _cost_center_id     := office.get_cost_center_id_by_cost_center_code('dummy-cs01');
    _party_code         := 'dummy-pr01';
    _price_type_id      := core.get_price_type_id_by_price_type_code('dummy-pt01');
    _shipper_id         := core.get_shipper_id_by_shipper_code('dummy-sh01');
    _store_id           := office.get_store_id_by_store_code('dummy-st01');

    
    _details            := ARRAY[
                             ROW(_store_id, 'dummy-it01', 1, 'Test Mock Unit',180000, 0, 0, '', 0)::transactions.stock_detail_type,
                             ROW(_store_id, 'dummy-it02', 2, 'Test Mock Unit',130000, 300, 0, '', 0)::transactions.stock_detail_type];

    PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 0, true, 100, true, 0, '1-1-2000', '1-1-2000', true);


    SELECT * FROM transactions.post_purchase
    (
        _book_name,_office_id, _user_id, _login_id, _value_date, _cost_center_id, _reference_number, _statement_reference,
        _is_credit, _party_code, _price_type_id, _shipper_id,
        _store_id, _tran_ids, _details, _attachments
    ) INTO _tran_id;


    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id > 0) THEN
        SELECT assert.fail('This transaction should not have been verified.') INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS unit_tests.auto_verify_journal_test1();

CREATE FUNCTION unit_tests.auto_verify_journal_test1()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _value_date         := transactions.get_value_date(_office_id);
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);

    PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 0, true, 0, true, 0, '1-1-2000', '1-1-2020', true);

    _tran_id := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));

    INSERT INTO transactions.transaction_master
    (
        transaction_master_id, 
        transaction_counter, 
        transaction_code, 
        book, 
        value_date, 
        user_id, 
        login_id, 
        office_id, 
        reference_number, 
        statement_reference
    )
    SELECT 
        _tran_id, 
        transactions.get_new_transaction_counter(_value_date), 
        transactions.get_transaction_code(_value_date, _office_id, _user_id, 1),
        'Journal',
        _value_date,
        _user_id,
        _login_id,
        _office_id,
        'REF# TEST',
        'Thou art not able to see this.';



    INSERT INTO transactions.transaction_details
    (
        transaction_master_id, 
        value_date,
        tran_type, 
        account_id, 
        statement_reference, 
        currency_code, 
        amount_in_currency, 
        local_currency_code,    
        er, 
        amount_in_local_currency
    )

    SELECT _tran_id, _value_date, 'Cr', core.get_account_id_by_account_number('dummy-acc01'), '', 'NPR', 12000, 'NPR', 1, 12000 UNION ALL
    SELECT _tran_id, _value_date, 'Dr', core.get_account_id_by_account_number('dummy-acc02'), '', 'NPR', 3000, 'NPR', 1, 3000 UNION ALL
    SELECT _tran_id, _value_date, 'Dr', core.get_account_id_by_account_number('dummy-acc03'), '', 'NPR', 9000, 'NPR', 1, 9000;


    PERFORM transactions.auto_verify(currval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id')), office.get_office_id_by_office_code('dummy-off01'));

    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id < 1) THEN
            SELECT assert.fail('This transaction should have been verified.') INTO message;
            RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;



DROP FUNCTION IF EXISTS unit_tests.auto_verify_journal_test2();

CREATE FUNCTION unit_tests.auto_verify_journal_test2()
RETURNS public.test_result
AS
$$
    DECLARE _value_date                             date;
    DECLARE _office_id                              integer;
    DECLARE _user_id                                integer;
    DECLARE _login_id                               bigint;
    DECLARE _tran_id                                bigint;
    DECLARE _verification_status_id                 smallint;
    DECLARE message                                 test_result;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id          := office.get_office_id_by_office_code('dummy-off01');
    _value_date         := transactions.get_value_date(_office_id);
    _user_id            := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id           := office.get_login_id(_user_id);

     PERFORM unit_tests.create_dummy_auto_verification_policy(office.get_user_id_by_user_name('plpgunit-test-user-000001'), true, 0, true, 0, true, 100, '1-1-2000', '1-1-2020', true);
    _tran_id := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));

    INSERT INTO transactions.transaction_master
    (
        transaction_master_id, 
        transaction_counter, 
        transaction_code, 
        book, 
        value_date, 
        user_id, 
        login_id, 
        office_id, 
        reference_number, 
        statement_reference
    )
    SELECT 
        _tran_id, 
        transactions.get_new_transaction_counter(_value_date), 
        transactions.get_transaction_code(_value_date, _office_id, _user_id, 1),
        'Journal',
        _value_date,
        _user_id,
        _login_id,
        _office_id,
        'REF# TEST',
        'Thou art not able to see this.';



    INSERT INTO transactions.transaction_details
    (
        transaction_master_id,
        value_date,
        tran_type, 
        account_id, 
        statement_reference, 
        currency_code, 
        amount_in_currency, 
        local_currency_code,    
        er, 
        amount_in_local_currency
    )
    SELECT _tran_id, _value_date, 'Cr', core.get_account_id_by_account_number('dummy-acc01'), '', 'NPR', 12000, 'NPR', 1, 12000 UNION ALL
    SELECT _tran_id, _value_date, 'Dr', core.get_account_id_by_account_number('dummy-acc02'), '', 'NPR', 3000, 'NPR', 1, 3000 UNION ALL
    SELECT _tran_id, _value_date, 'Dr', core.get_account_id_by_account_number('dummy-acc03'), '', 'NPR', 9000, 'NPR', 1, 9000;


    PERFORM transactions.auto_verify(currval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id')), office.get_office_id_by_office_code('dummy-off01'));

    SELECT verification_status_id
    INTO _verification_status_id
    FROM transactions.transaction_master
    WHERE transaction_master_id = _tran_id;

    IF(_verification_status_id > 0) THEN
            SELECT assert.fail('This transaction should not have been verified.') INTO message;
            RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.create_routine.sql --<--<--
DROP FUNCTION IF EXISTS transactions.create_routine(_routine_code national character varying(12), _routine regproc, _order integer);

CREATE FUNCTION transactions.create_routine(_routine_code national character varying(12), _routine regproc, _order integer)
RETURNS void
AS
$$
BEGIN
   INSERT INTO transactions.routines(routine_code, routine_name, "order")
   SELECT $1, $2, $3;
   
   RETURN;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_account_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _account_id             bigint,
    _office_id              integer
);

CREATE FUNCTION transactions.get_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _account_id             bigint,
    _office_id              integer
)
RETURNS TABLE
(
    id                      integer,
    value_date              date,
    tran_code               text,
    statement_reference     text,
    debit                   decimal(24, 4),
    credit                  decimal(24, 4),
    balance                 decimal(24, 4),
    office                  text,
    book                    text,
    account_id              integer,
    account_number          text,
    account                 text,
    posted_on               TIMESTAMP WITH TIME ZONE,
    posted_by               text,
    approved_by             text,
    verification_status     integer,
    flag_bg                 text,
    flag_fg                 text
)
AS
$$
    DECLARE _normally_debit boolean;
BEGIN

    _normally_debit             := transactions.is_normally_debit(_account_id);

    DROP TABLE IF EXISTS temp_account_statement;
    CREATE TEMPORARY TABLE temp_account_statement
    (
        id                      SERIAL,
        value_date              date,
        tran_code               text,
        statement_reference     text,
        debit                   decimal(24, 4),
        credit                  decimal(24, 4),
        balance                 decimal(24, 4),
        office                  text,
        book                    text,
        account_id              integer,
        account_number          text,
        account                 text,
        posted_on               TIMESTAMP WITH TIME ZONE,
        posted_by               text,
        approved_by             text,
        verification_status     integer,
        flag_bg                 text,
        flag_fg                 text
    ) ON COMMIT DROP;


    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit, office, book, account_id, posted_on, posted_by, approved_by, verification_status)
    SELECT
        _value_date_from,
        NULL,
        'Opening Balance',
        NULL,
        SUM
        (
            CASE transactions.transaction_details.tran_type
            WHEN 'Cr' THEN amount_in_local_currency
            ELSE amount_in_local_currency * -1 
            END            
        ) as credit,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    FROM transactions.transaction_master
    INNER JOIN transactions.transaction_details
    ON transactions.transaction_master.transaction_master_id = transactions.transaction_details.transaction_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND
        transactions.transaction_master.value_date < _value_date_from
    AND
       transactions.transaction_master.office_id IN (SELECT * FROM office.get_office_ids(_office_id)) 
    AND
       transactions.transaction_details.account_id IN (SELECT * FROM core.get_account_ids(_account_id));

    DELETE FROM temp_account_statement
    WHERE COALESCE(temp_account_statement.debit, 0) = 0
    AND COALESCE(temp_account_statement.credit, 0) = 0;
    

    UPDATE temp_account_statement SET 
    debit = temp_account_statement.credit * -1,
    credit = 0
    WHERE temp_account_statement.credit < 0;
    

    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit, office, book, account_id, posted_on, posted_by, approved_by, verification_status)
    SELECT
        transactions.transaction_master.value_date,
        transactions.transaction_master. transaction_code,
        transactions.transaction_details.statement_reference,
        CASE transactions.transaction_details.tran_type
        WHEN 'Dr' THEN amount_in_local_currency
        ELSE NULL END,
        CASE transactions.transaction_details.tran_type
        WHEN 'Cr' THEN amount_in_local_currency
        ELSE NULL END,
        office.get_office_name_by_id(transactions.transaction_master.office_id),
        transactions.transaction_master.book,
        transactions.transaction_details.account_id,
        transactions.transaction_master.transaction_ts,
        office.get_user_name_by_user_id(COALESCE(transactions.transaction_master.user_id, transactions.transaction_master.sys_user_id)),
        office.get_user_name_by_user_id(transactions.transaction_master.verified_by_user_id),
        transactions.transaction_master.verification_status_id
    FROM transactions.transaction_master
    INNER JOIN transactions.transaction_details
    ON transactions.transaction_master.transaction_master_id = transactions.transaction_details.transaction_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND
        transactions.transaction_master.value_date >= _value_date_from
    AND
        transactions.transaction_master.value_date <= _value_date_to
    AND
       transactions.transaction_master.office_id IN (SELECT * FROM office.get_office_ids(_office_id)) 
    AND
       transactions.transaction_details.account_id IN (SELECT * FROM core.get_account_ids(_account_id))
    ORDER BY 
        transactions.transaction_master.value_date,
        transactions.transaction_master.last_verified_on;



    UPDATE temp_account_statement
    SET balance = c.balance
    FROM
    (
        SELECT
            temp_account_statement.id, 
            SUM(COALESCE(c.credit, 0)) 
            - 
            SUM(COALESCE(c.debit,0)) As balance
        FROM temp_account_statement
        LEFT JOIN temp_account_statement AS c 
            ON (c.id <= temp_account_statement.id)
        GROUP BY temp_account_statement.id
        ORDER BY temp_account_statement.id
    ) AS c
    WHERE temp_account_statement.id = c.id;


    UPDATE temp_account_statement SET 
        account_number = core.accounts.account_number,
        account = core.accounts.account_name
    FROM core.accounts
    WHERE temp_account_statement.account_id = core.accounts.account_id;


    UPDATE temp_account_statement SET
        flag_bg = core.get_flag_background_color(core.get_flag_type_id(_user_id, 'account_statement', 'transaction_code', temp_account_statement.tran_code::text)),
        flag_fg = core.get_flag_foreground_color(core.get_flag_type_id(_user_id, 'account_statement', 'transaction_code', temp_account_statement.tran_code::text));


    IF(_normally_debit) THEN
        UPDATE temp_account_statement SET balance = temp_account_statement.balance * -1;
    END IF;

    RETURN QUERY
    SELECT * FROM temp_account_statement;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_account_statement('1-1-2010','1-1-2020',1,1,1);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_accrued_interest-todo.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_accrued_interest(office_id integer, party_id bigint);

CREATE FUNCTION transactions.get_accrued_interest(office_id integer, party_id bigint)
RETURNS money_strict2
AS
$$
BEGIN
    RETURN NULL;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_average_party_transaction.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_average_party_transaction(party_id bigint);


CREATE FUNCTION transactions.get_average_party_transaction(party_id bigint)
RETURNS money_strict2
STABLE
AS
$$
    DECLARE _account_id bigint= 0;
    DECLARE _debit money_strict2 = 0;
    DECLARE _credit money_strict2 = 0;
BEGIN

    IF(COALESCE($1, 0) <= 0) THEN
        RAISE EXCEPTION 'Invalid party.'
        USING ERRCODE='P3050';
    END IF;

    _account_id := core.get_account_id_by_party_id($1);

    IF(COALESCE(_account_id, 0) <= 0) THEN
        RAISE EXCEPTION 'Invalid party.'
        USING ERRCODE='P3050';
    END IF;

    
    SELECT SUM(amount_in_local_currency)
    INTO _debit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id=_account_id
    AND tran_type='Dr';

    SELECT SUM(amount_in_local_currency)
    INTO _credit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id=_account_id
    AND tran_type='Cr';

    RETURN FLOOR( (COALESCE(_credit, '0') + COALESCE(_debit, '0')) /2 );
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS transactions.get_average_party_transaction(party_id bigint, office_id integer);


CREATE FUNCTION transactions.get_average_party_transaction(party_id bigint, office_id integer)
RETURNS money_strict2
STABLE
AS
$$
    DECLARE _account_id bigint = 0;
    DECLARE _debit money_strict2 = 0;
    DECLARE _credit money_strict2 = 0;
BEGIN
    IF(COALESCE($1, 0) <= 0) THEN
        RAISE EXCEPTION 'Invalid party.'
        USING ERRCODE='P3050';
    END IF;

    IF(COALESCE($2, 0) <= 0) THEN
        RAISE EXCEPTION 'Invalid office.'
        USING ERRCODE='P3011';
    END IF;

    _account_id := core.get_account_id_by_party_id($1);

    IF(COALESCE(_account_id, 0) <= 0) THEN
        RAISE EXCEPTION 'Invalid party.'
        USING ERRCODE='P3050';
    END IF;

    SELECT SUM(amount_in_local_currency)
    INTO _debit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id=_account_id
    AND transactions.verified_transaction_view.office_id=$2
    AND tran_type='Dr';

    SELECT SUM(amount_in_local_currency)
    INTO _credit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id=_account_id
    AND transactions.verified_transaction_view.office_id=$2
    AND tran_type='Cr';

    RETURN FLOOR( (COALESCE(_credit, '0') + COALESCE(_debit, '0')) /2 );
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_balance_sheet.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_balance_sheet
(
    _previous_period                date,
    _current_period                 date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer
);

CREATE FUNCTION transactions.get_balance_sheet
(
    _previous_period                date,
    _current_period                 date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer
)
RETURNS TABLE
(
    id                              bigint,
    item                            text,
    previous_period                 decimal(24, 4),
    current_period                  decimal(24, 4),
    account_id                      integer,
    account_number                  text,
    is_retained_earning             boolean
)
AS
$$
    DECLARE this                    RECORD;
    DECLARE _date_from              date;
BEGIN
    _date_from := core.get_fiscal_year_start_date(_office_id);

    IF(COALESCE(_factor, 0) = 0) THEN
        _factor := 1;
    END IF;

    DROP TABLE IF EXISTS bs_temp;
    CREATE TEMPORARY TABLE bs_temp
    (
        item_id                     int PRIMARY KEY,
        item                        text,
        account_number              text,
        account_id                  integer,
        child_accounts              integer[],
        parent_item_id              integer REFERENCES bs_temp(item_id),
        is_debit                    boolean DEFAULT(false),
        previous_period             decimal(24, 4) DEFAULT(0),
        current_period              decimal(24, 4) DEFAULT(0),
        sort                        int,
        skip                        boolean DEFAULT(false),
        is_retained_earning         boolean DEFAULT(false)
    ) ON COMMIT DROP;
    
    --BS structure setup start
    INSERT INTO bs_temp(item_id, item, parent_item_id)
    SELECT  1,       'Assets',                              NULL::numeric   UNION ALL
    SELECT  10100,   'Current Assets',                      1               UNION ALL
    SELECT  10101,   'Cash A/C',                            1               UNION ALL
    SELECT  10102,   'Bank A/C',                            1               UNION ALL
    SELECT  10110,   'Accounts Receivable',                 10100           UNION ALL
    SELECT  10200,   'Fixed Assets',                        1               UNION ALL
    SELECT  10201,   'Property, Plants, and Equipments',    10201           UNION ALL
    SELECT  10300,   'Other Assets',                        1               UNION ALL
    SELECT  14900,   'Liabilities & Shareholders'' Equity', NULL            UNION ALL
    SELECT  15000,   'Current Liabilities',                 14900           UNION ALL
    SELECT  15010,   'Accounts Payable',                    15000           UNION ALL
    SELECT  15011,   'Salary Payable',                      15000           UNION ALL
    SELECT  15100,   'Long-Term Liabilities',               14900           UNION ALL
    SELECT  15200,   'Shareholders'' Equity',               14900           UNION ALL
    SELECT  15300,   'Retained Earnings',                   15200;

    UPDATE bs_temp SET is_debit = true WHERE bs_temp.item_id <= 10300;
    UPDATE bs_temp SET is_retained_earning = true WHERE bs_temp.item_id = 15300;
    
    INSERT INTO bs_temp(item_id, account_id, account_number, parent_item_id, item, is_debit, child_accounts)
    SELECT 
        row_number() OVER(ORDER BY core.accounts.account_master_id) + (core.accounts.account_master_id * 100) AS id,
        core.accounts.account_id,
        core.accounts.account_number,
        core.accounts.account_master_id,
        core.accounts.account_name,
        core.account_masters.normally_debit,
        array_agg(agg)
    FROM core.accounts
    INNER JOIN core.account_masters
    ON core.accounts.account_master_id = core.account_masters.account_master_id,
    core.get_account_ids(core.accounts.account_id) as agg
    WHERE parent_account_id IN
    (
        SELECT core.accounts.account_id
        FROM core.accounts
        WHERE core.accounts.sys_type
        AND core.accounts.account_master_id BETWEEN 10100 AND 15200
    )
    AND core.accounts.account_master_id BETWEEN 10100 AND 15200
    GROUP BY core.accounts.account_id, core.account_masters.normally_debit
    ORDER BY account_master_id;


    --Updating credit balances of individual GL accounts.
    UPDATE bs_temp SET previous_period = tran.previous_period
    FROM
    (
        SELECT 
            bs_temp.account_id,         
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END) AS previous_period
        FROM bs_temp
        INNER JOIN transactions.verified_transaction_mat_view
        ON transactions.verified_transaction_mat_view.account_id = ANY(bs_temp.child_accounts)
        WHERE value_date <=_previous_period
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        GROUP BY bs_temp.account_id
    ) AS tran
    WHERE bs_temp.account_id = tran.account_id;

    --Updating credit balances of individual GL accounts.
    UPDATE bs_temp SET current_period = tran.current_period
    FROM
    (
        SELECT 
            bs_temp.account_id,         
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END) AS current_period
        FROM bs_temp
        INNER JOIN transactions.verified_transaction_mat_view
        ON transactions.verified_transaction_mat_view.account_id = ANY(bs_temp.child_accounts)
        WHERE value_date <=_current_period
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        GROUP BY bs_temp.account_id
    ) AS tran
    WHERE bs_temp.account_id = tran.account_id;


    --Dividing by the factor.
    UPDATE bs_temp SET 
        previous_period = bs_temp.previous_period / _factor,
        current_period = bs_temp.current_period / _factor;

    --Upading balance of retained earnings
    UPDATE bs_temp SET 
        previous_period = transactions.get_retained_earnings(_previous_period, _office_id, _factor),
        current_period = transactions.get_retained_earnings(_current_period, _office_id, _factor)
    WHERE bs_temp.item_id = 15300;

    --Reversing assets to debit balance.
    UPDATE bs_temp SET 
        previous_period=bs_temp.previous_period*-1,
        current_period=bs_temp.current_period*-1 
    WHERE bs_temp.is_debit;



    FOR this IN 
    SELECT * FROM bs_temp 
    WHERE COALESCE(bs_temp.previous_period, 0) + COALESCE(bs_temp.current_period, 0) != 0 
    AND bs_temp.account_id IS NOT NULL
    LOOP
        UPDATE bs_temp SET skip = true WHERE this.account_id = ANY(bs_temp.child_accounts)
        AND bs_temp.account_id != this.account_id;
    END LOOP;

    --Updating current period amount on GL parent item by the sum of their respective child balances.
    WITH running_totals AS
    (
        SELECT bs_temp.parent_item_id,
        SUM(COALESCE(bs_temp.previous_period, 0)) AS previous_period,
        SUM(COALESCE(bs_temp.current_period, 0)) AS current_period
        FROM bs_temp
        WHERE NOT skip
        AND parent_item_id IS NOT NULL
        GROUP BY bs_temp.parent_item_id
    )
    UPDATE bs_temp SET 
        previous_period = running_totals.previous_period,
        current_period = running_totals.current_period
    FROM running_totals
    WHERE running_totals.parent_item_id = bs_temp.item_id
    AND bs_temp.item_id
    IN
    (
        SELECT parent_item_id FROM running_totals
    );


    --Updating sum amount on parent item by the sum of their respective child balances.
    UPDATE bs_temp SET 
        previous_period = tran.previous_period,
        current_period = tran.current_period
    FROM 
    (
        SELECT bs_temp.parent_item_id,
        SUM(bs_temp.previous_period) AS previous_period,
        SUM(bs_temp.current_period) AS current_period
        FROM bs_temp
        WHERE bs_temp.parent_item_id IS NOT NULL
        GROUP BY bs_temp.parent_item_id
    ) 
    AS tran 
    WHERE tran.parent_item_id = bs_temp.item_id
    AND tran.parent_item_id IS NOT NULL;


    --Updating sum amount on grandparents.
    UPDATE bs_temp SET 
        previous_period = tran.previous_period,
        current_period = tran.current_period
    FROM 
    (
        SELECT bs_temp.parent_item_id,
        SUM(bs_temp.previous_period) AS previous_period,
        SUM(bs_temp.current_period) AS current_period
        FROM bs_temp
        WHERE bs_temp.parent_item_id IS NOT NULL
        GROUP BY bs_temp.parent_item_id
    ) 
    AS tran 
    WHERE tran.parent_item_id = bs_temp.item_id;

    --Removing ledgers having zero balances
    DELETE FROM bs_temp
    WHERE COALESCE(bs_temp.previous_period, 0) + COALESCE(bs_temp.current_period, 0) = 0
    AND bs_temp.account_id IS NOT NULL;

    --Converting 0's to NULLS.
    UPDATE bs_temp SET previous_period = CASE WHEN bs_temp.previous_period = 0 THEN NULL ELSE bs_temp.previous_period END;
    UPDATE bs_temp SET current_period = CASE WHEN bs_temp.current_period = 0 THEN NULL ELSE bs_temp.current_period END;
    
    UPDATE bs_temp SET sort = bs_temp.item_id WHERE bs_temp.item_id < 15400;
    UPDATE bs_temp SET sort = bs_temp.parent_item_id WHERE bs_temp.item_id >= 15400;

    RETURN QUERY
    SELECT
        row_number() OVER(order by bs_temp.sort, bs_temp.item_id) AS id,
        bs_temp.item,
        bs_temp.previous_period,
        bs_temp.current_period,
        bs_temp.account_id,
        bs_temp.account_number,
        bs_temp.is_retained_earning
    FROM bs_temp;
END;
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_balance_sheet('7/17/2014', '7/16/2015', 2, 2, 1000);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_cash_flow_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_cash_flow_statement
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer
);

CREATE FUNCTION transactions.get_cash_flow_statement
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer
)
RETURNS json
AS
$$
    DECLARE _sql                    text;
    DECLARE _periods                core.period[];
    DECLARE _json                   json;
    DECLARE this                    RECORD;
    DECLARE _balance                decimal(24, 4);
    DECLARE _is_periodic            boolean = office.is_periodic_inventory(_office_id);
BEGIN    
    --We cannot divide by zero.
    IF(COALESCE(_factor, 0) = 0) THEN
        _factor := 1;
    END IF;

    DROP TABLE IF EXISTS cf_temp;
    CREATE TEMPORARY TABLE cf_temp
    (
        item_id                     integer PRIMARY KEY,
        item                        text,
        account_master_id           integer,
        parent_item_id              integer REFERENCES cf_temp(item_id),
        is_summation                boolean DEFAULT(false),
        is_debit                    boolean DEFAULT(false),
        is_sales                    boolean DEFAULT(false),
        is_purchase                 boolean DEFAULT(false)
    ) ON COMMIT DROP;


    _periods            := core.get_periods(_date_from, _date_to);

    IF(_periods IS NULL) THEN
        RAISE EXCEPTION 'Invalid period specified.'
        USING ERRCODE='P3009';
    END IF;

    /**************************************************************************************************************************************************************************************
        CREATING PERIODS
    **************************************************************************************************************************************************************************************/
    SELECT string_agg(dynamic, '') FROM
    (
            SELECT 'ALTER TABLE cf_temp ADD COLUMN "' || period_name || '" decimal(24, 4) DEFAULT(0);' as dynamic
            FROM explode_array(_periods)
         
    ) periods
    INTO _sql;
    
    EXECUTE _sql;

    /**************************************************************************************************************************************************************************************
        CASHFLOW TABLE STRUCTURE START
    **************************************************************************************************************************************************************************************/
    INSERT INTO cf_temp(item_id, item, is_summation, is_debit)
    SELECT  10000,  'Cash and cash equivalents, beginning of period',   false,  true    UNION ALL    
    SELECT  20000,  'Cash flows from operating activities',             true,   false   UNION ALL    
    SELECT  30000,  'Cash flows from investing activities',             true,   false   UNION ALL
    SELECT  40000,  'Cash flows from financing acticities',             true,   false   UNION ALL    
    SELECT  50000,  'Net increase in cash and cash equivalents',        false,  false   UNION ALL    
    SELECT  60000,  'Cash and cash equivalents, end of period',         false,  true;    

    INSERT INTO cf_temp(item_id, item, parent_item_id, is_debit, is_sales, is_purchase)
    SELECT  cash_flow_heading_id,   cash_flow_heading_name, 20000,  is_debit,   is_sales,   is_purchase FROM core.cash_flow_headings WHERE cash_flow_heading_type = 'O' UNION ALL
    SELECT  cash_flow_heading_id,   cash_flow_heading_name, 30000,  is_debit,   is_sales,   is_purchase FROM core.cash_flow_headings WHERE cash_flow_heading_type = 'I' UNION ALL 
    SELECT  cash_flow_heading_id,   cash_flow_heading_name, 40000,  is_debit,   is_sales,   is_purchase FROM core.cash_flow_headings WHERE cash_flow_heading_type = 'F';

    INSERT INTO cf_temp(item_id, item, parent_item_id, is_debit, account_master_id)
    SELECT core.account_masters.account_master_id + 50000, core.account_masters.account_master_name,  core.cash_flow_setup.cash_flow_heading_id, core.cash_flow_headings.is_debit, core.account_masters.account_master_id
    FROM core.cash_flow_setup
    INNER JOIN core.account_masters
    ON core.cash_flow_setup.account_master_id = core.account_masters.account_master_id
    INNER JOIN core.cash_flow_headings
    ON core.cash_flow_setup.cash_flow_heading_id = core.cash_flow_headings.cash_flow_heading_id;

    /**************************************************************************************************************************************************************************************
        CASHFLOW TABLE STRUCTURE END
    **************************************************************************************************************************************************************************************/


    /**************************************************************************************************************************************************************************************
        ITERATING THROUGH PERIODS TO UPDATE TRANSACTION BALANCES
    **************************************************************************************************************************************************************************************/
    FOR this IN SELECT * FROM explode_array(_periods) ORDER BY date_from ASC
    LOOP
        --
        --
        --Opening cash balance.
        --
        --
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"=
            (
                SELECT
                SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) - 
                SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) AS total_amount
            FROM transactions.verified_cash_transaction_mat_view
            WHERE account_master_id IN(10101, 10102) 
            AND value_date <''' || this.date_from::text ||
            ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
            )
        WHERE cf_temp.item_id = 10000;';

        EXECUTE _sql;

        --
        --
        --Updating debit balances of mapped account master heads.
        --
        --
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"=tran.total_amount
        FROM
        (
            SELECT transactions.verified_cash_transaction_mat_view.account_master_id,
            SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) - 
            SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) AS total_amount
        FROM transactions.verified_cash_transaction_mat_view
        WHERE transactions.verified_cash_transaction_mat_view.book NOT IN (''Sales.Direct'', ''Sales.Receipt'', ''Sales.Delivery'', ''Purchase.Direct'', ''Purchase.Receipt'')
        AND NOT account_master_id IN(10101, 10102) 
        AND value_date >=''' || this.date_from::text || ''' AND value_date <=''' || this.date_to::text ||
        ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
        GROUP BY transactions.verified_cash_transaction_mat_view.account_master_id
        ) AS tran
        WHERE tran.account_master_id = cf_temp.account_master_id';
        EXECUTE _sql;

        --
        --
        --Updating cash paid to suppliers.
        --
        --
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"=
        
        (
            SELECT
            SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) - 
            SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) 
        FROM transactions.verified_cash_transaction_mat_view
        WHERE transactions.verified_cash_transaction_mat_view.book IN (''Purchase.Direct'', ''Purchase.Receipt'')
        AND NOT account_master_id IN(10101, 10102) 
        AND value_date >=''' || this.date_from::text || ''' AND value_date <=''' || this.date_to::text ||
        ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
        )
        WHERE cf_temp.is_purchase;';
        EXECUTE _sql;

        --
        --
        --Updating cash received from customers.
        --
        --
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"=
        
        (
            SELECT
            SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) - 
            SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) 
        FROM transactions.verified_cash_transaction_mat_view
        WHERE transactions.verified_cash_transaction_mat_view.book IN (''Sales.Direct'', ''Sales.Receipt'', ''Sales.Delivery'')
        AND account_master_id IN(10101, 10102) 
        AND value_date >=''' || this.date_from::text || ''' AND value_date <=''' || this.date_to::text ||
        ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
        )
        WHERE cf_temp.is_sales;';
        RAISE NOTICE '%', _SQL;
        EXECUTE _sql;

        --Closing cash balance.
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"
        =
        (
            SELECT
            SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) - 
            SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) AS total_amount
        FROM transactions.verified_cash_transaction_mat_view
        WHERE account_master_id IN(10101, 10102) 
        AND value_date <''' || this.date_to::text ||
        ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
        ) 
        WHERE cf_temp.item_id = 60000;';

        EXECUTE _sql;

        --Reversing to debit balance for associated headings.
        _sql := 'UPDATE cf_temp SET "' || this.period_name || '"="' || this.period_name || '"*-1 WHERE is_debit=true;';
        EXECUTE _sql;
    END LOOP;



    --Updating periodic balances on parent item by the sum of their respective child balances.
    SELECT 'UPDATE cf_temp SET ' || array_to_string(array_agg('"' || period_name || '"' || '=cf_temp."' || period_name || '" + tran."' || period_name || '"'), ',') || 
    ' FROM 
    (
        SELECT parent_item_id, '
        || array_to_string(array_agg('SUM("' || period_name || '") AS "' || period_name || '"'), ',') || '
         FROM cf_temp
        GROUP BY parent_item_id
    ) 
    AS tran
        WHERE tran.parent_item_id = cf_temp.item_id
        AND cf_temp.item_id NOT IN (10000, 60000);'
    INTO _sql
    FROM explode_array(_periods);

        RAISE NOTICE '%', _SQL;
    EXECUTE _sql;


    SELECT 'UPDATE cf_temp SET ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT
            cf_temp.parent_item_id,'
        || array_to_string(array_agg('SUM(CASE is_debit WHEN true THEN "' || period_name || '" ELSE "' || period_name || '" *-1 END) AS "' || period_name || '"'), ',') ||
    '
         FROM cf_temp
         GROUP BY cf_temp.parent_item_id
    ) 
    AS tran
    WHERE cf_temp.item_id = tran.parent_item_id
    AND cf_temp.parent_item_id IS NULL;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;


    --Dividing by the factor.
    SELECT 'UPDATE cf_temp SET ' || array_to_string(array_agg('"' || period_name || '"="' || period_name || '"/' || _factor::text), ',') || ';'
    INTO _sql
    FROM explode_array(_periods);
    EXECUTE _sql;


    --Converting 0's to NULLS.
    SELECT 'UPDATE cf_temp SET ' || array_to_string(array_agg('"' || period_name || '"= CASE WHEN "' || period_name || '" = 0 THEN NULL ELSE "' || period_name || '" END'), ',') || ';'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    SELECT 
    'SELECT array_to_json(array_agg(row_to_json(report)))
    FROM
    (
        SELECT item, '
        || array_to_string(array_agg('"' || period_name || '"'), ',') ||
        ', is_summation FROM cf_temp
        WHERE account_master_id IS NULL
        ORDER BY item_id
    ) AS report;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql INTO _json ;

    RETURN _json;
END
$$
LANGUAGE plpgsql;

--SELECT transactions.get_cash_flow_statement('1-1-2000','1-15-2020', 2, 2, 1)

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_cash_repository_balance.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_cash_repository_balance(_cash_repository_id integer, _currency_code national character varying(12));
CREATE FUNCTION transactions.get_cash_repository_balance(_cash_repository_id integer, _currency_code national character varying(12))
RETURNS money_strict2
AS
$$
    DECLARE _debit money_strict2;
    DECLARE _credit money_strict2;
BEGIN
    SELECT COALESCE(SUM(amount_in_currency), 0::money_strict2) INTO _debit
    FROM transactions.verified_transaction_view
    WHERE cash_repository_id=$1
    AND currency_code=$2
    AND tran_type='Dr';

    SELECT COALESCE(SUM(amount_in_currency), 0::money_strict2) INTO _credit
    FROM transactions.verified_transaction_view
    WHERE cash_repository_id=$1
    AND currency_code=$2
    AND tran_type='Cr';

    RETURN _debit - _credit;
END
$$
LANGUAGE plpgsql;


DROP FUNCTION IF EXISTS transactions.get_cash_repository_balance(_cash_repository_id integer);
CREATE FUNCTION transactions.get_cash_repository_balance(_cash_repository_id integer)
RETURNS money_strict2
AS
$$
    DECLARE _local_currency_code national character varying(12) = transactions.get_default_currency_code($1);
    DECLARE _debit money_strict2;
    DECLARE _credit money_strict2;
BEGIN
    SELECT COALESCE(SUM(amount_in_currency), 0::money_strict2) INTO _debit
    FROM transactions.verified_transaction_view
    WHERE cash_repository_id=$1
    AND currency_code=_local_currency_code
    AND tran_type='Dr';

    SELECT COALESCE(SUM(amount_in_currency), 0::money_strict2) INTO _credit
    FROM transactions.verified_transaction_view
    WHERE cash_repository_id=$1
    AND currency_code=_local_currency_code
    AND tran_type='Cr';

    RETURN _debit - _credit;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_closing_stock.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_closing_stock
(
    _on_date            date,
    _office_id          integer
);

CREATE FUNCTION transactions.get_closing_stock
(
    _on_date            date,
    _office_id          integer
)
RETURNS decimal(24, 4)
AS
$$
BEGIN
    RETURN 0;--TODO
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_cost_of_goods_sold.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_cost_of_goods_sold(_item_id integer, _unit_id integer, _store_id integer, _quantity integer);

CREATE FUNCTION transactions.get_cost_of_goods_sold(_item_id integer, _unit_id integer, _store_id integer, _quantity integer)
RETURNS money_strict
AS
$$
    DECLARE _base_quantity decimal;
    DECLARE _base_unit_id integer;
    DECLARE _base_unit_cost money_strict;
    DECLARE _total_sold integer;
    DECLARE _office_id integer      = office.get_office_id_by_store_id($3);
    DECLARE _method text            = office.get_cost_of_good_method(_office_id);
BEGIN
    _base_quantity   = core.get_base_quantity_by_unit_id($2, $4);
    _base_unit_id    = core.get_root_unit_id($2);


    IF(_method = 'MAVCO') THEN
            --RAISE NOTICE '% % % %',_item_id, _store_id, _base_quantity, 1.00;
            RETURN transactions.get_mavcogs(_item_id, _store_id, _base_quantity, 1.00);
    END IF;


    DROP TABLE IF EXISTS temp_cost_of_goods_sold;
    CREATE TEMPORARY TABLE temp_cost_of_goods_sold
    (
            id                     BIGSERIAL,
            stock_detail_id        bigint,
            audit_ts               TIMESTAMP WITH TIME ZONE,
            value_date             date,
            price                  money_strict,
            tran_type              text
                    
    ) ON COMMIT DROP;

    WITH stock_cte AS
    (
        SELECT
            stock_detail_id, 
            audit_ts,
            value_date,
            generate_series(1, base_quantity::integer) AS series,
            (price * quantity) / base_quantity AS price,
            tran_type
        FROM transactions.verified_stock_details_view
        WHERE item_id = $1
        AND store_id = $3
    )
    
    INSERT INTO temp_cost_of_goods_sold(stock_detail_id, audit_ts, value_date, price, tran_type)
    SELECT stock_detail_id, audit_ts, value_date, price, tran_type FROM stock_cte
    ORDER BY value_date, audit_ts, stock_detail_id;

    SELECT COUNT(*) INTO _total_sold 
    FROM temp_cost_of_goods_sold
    WHERE tran_type='Cr';

    IF(_method = 'LIFO') THEN
        SELECT SUM(price) INTO _base_unit_cost
        FROM 
        (
                SELECT price
                FROM temp_cost_of_goods_sold
                WHERE tran_type ='Dr'
                ORDER BY id DESC
                OFFSET _total_sold
                LIMIT _base_quantity
        ) S;
    ELSIF (_method = 'FIFO') THEN
        SELECT SUM(price) INTO _base_unit_cost
        FROM 
        (
                SELECT price
                FROM temp_cost_of_goods_sold
                WHERE tran_type ='Dr'
                ORDER BY id
                OFFSET _total_sold
                LIMIT _base_quantity
        ) S;
    ELSIF (_method != 'MAVCO') THEN
        RAISE EXCEPTION 'Invalid configuration: COGS method.'
        USING ERRCODE='P6010';
    END IF;

    RETURN _base_unit_cost;
END
$$
LANGUAGE PLPGSQL;

-- UPDATE office.configuration
-- SET value = 'MAVCO'
-- WHERE config_id = 2;
-- 
-- 
--SELECT * FROM transactions.get_cost_of_goods_sold(1, 1, 1, 1);


-- 
-- 
-- 
--SELECT * FROM transactions.get_cost_of_goods_sold(1, 7, 1, 1);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_income_expenditure_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_income_expenditure_statement
(
    _date_from              date,
    _date_to                date,
    _user_id                integer,
    _office_id              integer,
    _compact                boolean
);

CREATE FUNCTION transactions.get_income_expenditure_statement
(
    _date_from              date,
    _date_to                date,
    _user_id                integer,
    _office_id              integer,
    _compact                boolean
)
RETURNS TABLE
(
    id                      integer,
    account_id              integer,
    account_number          text,
    account                 text,
    previous_debit          decimal(24, 4),
    previous_credit         decimal(24, 4),
    previous_balance        decimal(24, 4),
    debit                   decimal(24, 4),
    credit                  decimal(24, 4),
    balance                 decimal(24, 4),
    closing_debit           decimal(24, 4),
    closing_credit          decimal(24, 4),
    closing_balance         decimal(24, 4)
)
AS
$$
    DECLARE _account_master_id  integer;
BEGIN
    IF(_date_from = 'infinity') THEN
        RAISE EXCEPTION '%', 'Invalid date.'
        USING ERRCODE='P3008';
    END IF;

    IF NOT EXISTS
    (
        SELECT 0 FROM office.offices
        WHERE office_id IN 
        (
            SELECT * FROM office.get_office_ids(1)
        )
        HAVING count(DISTINCT currency_code) = 1
   ) THEN
        RAISE EXCEPTION 'Cannot produce P/L statement of office(s) having different base currencies.'
        USING ERRCODE='P8001';
   END IF;

   SELECT 
    account_master_id 
   INTO 
    _account_master_id
   FROM core.account_masters
   WHERE core.account_masters.account_master_code = 'PLA';


    DROP TABLE IF EXISTS temp_income_expenditure_statement;
    CREATE TEMPORARY TABLE temp_income_expenditure_statement
    (
        id                      integer,
        account_id              integer,
        account_number          text,
        account                 text,
        previous_debit          decimal(24, 4) DEFAULT(0),
        previous_credit         decimal(24, 4) DEFAULT(0),
        previous_balance        decimal(24, 4) DEFAULT(0),
        debit                   decimal(24, 4) DEFAULT(0),
        credit                  decimal(24, 4) DEFAULT(0),
        balance                 decimal(24, 4) DEFAULT(0),
        closing_debit           decimal(24, 4) DEFAULT(0),
        closing_credit          decimal(24, 4) DEFAULT(0),
        closing_balance         decimal(24, 4) DEFAULT(0),
        root_account_id         integer,
        normally_debit          boolean
    ) ON COMMIT DROP;

    INSERT INTO temp_income_expenditure_statement(account_id, previous_debit, previous_credit)    
    SELECT 
        verified_transaction_mat_view.account_id, 
        SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
        SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
    FROM transactions.verified_transaction_mat_view
    WHERE value_date < _date_from
    AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
    AND account_master_id = _account_master_id
    GROUP BY verified_transaction_mat_view.account_id;



    IF(_date_to = 'infinity') THEN
        INSERT INTO temp_income_expenditure_statement(account_id, debit, credit)    
        SELECT 
            verified_transaction_mat_view.account_id, 
            SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
        FROM transactions.verified_transaction_mat_view
        WHERE value_date > _date_from
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        AND account_master_id = _account_master_id
        GROUP BY verified_transaction_mat_view.account_id;
    ELSE
        INSERT INTO temp_income_expenditure_statement(account_id, debit, credit)    
        SELECT 
            verified_transaction_mat_view.account_id, 
            SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
        FROM transactions.verified_transaction_mat_view
        WHERE value_date >= _date_from AND value_date <= _date_to
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        AND account_master_id = _account_master_id
        GROUP BY verified_transaction_mat_view.account_id;    
    END IF;

    UPDATE temp_income_expenditure_statement SET root_account_id = core.get_second_root_account_id(temp_income_expenditure_statement.account_id);


    DROP TABLE IF EXISTS temp_income_expenditure_statement2;
    
    IF(_compact) THEN
        CREATE TEMPORARY TABLE temp_income_expenditure_statement2
        ON COMMIT DROP
        AS
        SELECT
            temp_income_expenditure_statement.root_account_id AS account_id,
            ''::text as account_number,
            ''::text as account,
            SUM(temp_income_expenditure_statement.previous_debit) AS previous_debit,
            SUM(temp_income_expenditure_statement.previous_credit) AS previous_credit,
            0::decimal(24, 4) AS previous_balance,
            SUM(temp_income_expenditure_statement.debit) AS debit,
            SUM(temp_income_expenditure_statement.credit) as credit,
            0::decimal(24, 4) AS balance,
            SUM(temp_income_expenditure_statement.closing_debit) AS closing_debit,
            SUM(temp_income_expenditure_statement.closing_credit) AS closing_credit,
            0::decimal(24, 4) AS closing_balance,
            temp_income_expenditure_statement.normally_debit
        FROM temp_income_expenditure_statement
        GROUP BY 
            temp_income_expenditure_statement.root_account_id,
            temp_income_expenditure_statement.normally_debit;
    ELSE
        CREATE TEMPORARY TABLE temp_income_expenditure_statement2
        ON COMMIT DROP
        AS
        SELECT
            temp_income_expenditure_statement.account_id,
            ''::text as account_number,
            ''::text as account,
            SUM(temp_income_expenditure_statement.previous_debit) AS previous_debit,
            SUM(temp_income_expenditure_statement.previous_credit) AS previous_credit,
            0::decimal(24, 4) AS previous_balance,
            SUM(temp_income_expenditure_statement.debit) AS debit,
            SUM(temp_income_expenditure_statement.credit) as credit,
            0::decimal(24, 4) AS balance,
            SUM(temp_income_expenditure_statement.closing_debit) AS closing_debit,
            SUM(temp_income_expenditure_statement.closing_credit) AS closing_credit,
            0::decimal(24, 4) AS closing_balance,
            temp_income_expenditure_statement.normally_debit
        FROM temp_income_expenditure_statement
        GROUP BY 
            temp_income_expenditure_statement.account_id,
            temp_income_expenditure_statement.normally_debit;
    END IF;
    
    UPDATE temp_income_expenditure_statement2 SET
        account_number = core.accounts.account_number,
        account = core.accounts.account_name,
        normally_debit = core.account_masters.normally_debit
    FROM core.accounts
    INNER JOIN core.account_masters
    ON core.accounts.account_master_id = core.account_masters.account_master_id
    WHERE temp_income_expenditure_statement2.account_id = core.accounts.account_id;

    UPDATE temp_income_expenditure_statement2 SET 
        previous_balance = temp_income_expenditure_statement2.previous_credit - temp_income_expenditure_statement2.previous_debit,
        balance = temp_income_expenditure_statement2.credit - temp_income_expenditure_statement2.debit,
        closing_debit = temp_income_expenditure_statement2.previous_debit + temp_income_expenditure_statement2.debit,
        closing_credit = temp_income_expenditure_statement2.previous_credit + temp_income_expenditure_statement2.credit,
        closing_balance = temp_income_expenditure_statement2.previous_credit + temp_income_expenditure_statement2.credit - (temp_income_expenditure_statement2.previous_debit + temp_income_expenditure_statement2.debit);


    UPDATE temp_income_expenditure_statement2 SET 
        previous_balance = temp_income_expenditure_statement2.previous_balance * -1,
        balance = temp_income_expenditure_statement2.balance * -1,
        closing_balance = temp_income_expenditure_statement2.closing_balance * -1
    WHERE temp_income_expenditure_statement2.normally_debit;

    UPDATE temp_income_expenditure_statement2 SET previous_debit   = NULL WHERE temp_income_expenditure_statement2.previous_debit     = 0;
    UPDATE temp_income_expenditure_statement2 SET previous_credit  = NULL WHERE temp_income_expenditure_statement2.previous_credit    = 0;
    UPDATE temp_income_expenditure_statement2 SET previous_balance = NULL WHERE temp_income_expenditure_statement2.previous_balance   = 0;
    UPDATE temp_income_expenditure_statement2 SET debit            = NULL WHERE temp_income_expenditure_statement2.debit              = 0;
    UPDATE temp_income_expenditure_statement2 SET credit           = NULL WHERE temp_income_expenditure_statement2.credit             = 0;
    UPDATE temp_income_expenditure_statement2 SET balance          = NULL WHERE temp_income_expenditure_statement2.balance            = 0;
    UPDATE temp_income_expenditure_statement2 SET closing_debit    = NULL WHERE temp_income_expenditure_statement2.closing_debit      = 0;
    UPDATE temp_income_expenditure_statement2 SET closing_credit   = NULL WHERE temp_income_expenditure_statement2.closing_credit     = 0;
    UPDATE temp_income_expenditure_statement2 SET closing_balance  = NULL WHERE temp_income_expenditure_statement2.closing_balance    = 0;


    DELETE FROM temp_income_expenditure_statement2 WHERE temp_income_expenditure_statement2.closing_balance = 0;
   
    RETURN QUERY
    SELECT
        row_number() OVER(ORDER BY temp_income_expenditure_statement2.account_id)::integer AS id,
        temp_income_expenditure_statement2.account_id,
        temp_income_expenditure_statement2.account_number,
        temp_income_expenditure_statement2.account,
        temp_income_expenditure_statement2.previous_debit,
        temp_income_expenditure_statement2.previous_credit,
        temp_income_expenditure_statement2.previous_balance,
        temp_income_expenditure_statement2.debit,
        temp_income_expenditure_statement2.credit,
        temp_income_expenditure_statement2.balance,
        temp_income_expenditure_statement2.closing_debit,
        temp_income_expenditure_statement2.closing_credit,
        temp_income_expenditure_statement2.closing_balance
    FROM temp_income_expenditure_statement2;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_income_expenditure_statement('1-1-2010','1-1-2020',1,1, true);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_journal_view.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_journal_view
(
    _user_id                        integer,
    _office_id                      integer,
    _from                           date,
    _to                             date,
    _tran_id                        bigint,
    _tran_code                      national character varying(50),
    _book                           national character varying(50),
    _reference_number               national character varying(50),
    _statement_reference            national character varying(50),
    _posted_by                      national character varying(50),
    _office                         national character varying(50),
    _status                         national character varying(12),
    _verified_by                    national character varying(50),
    _reason                         national character varying(128)
);

CREATE FUNCTION transactions.get_journal_view
(
    _user_id                        integer,
    _office_id                      integer,
    _from                           date,
    _to                             date,
    _tran_id                        bigint,
    _tran_code                      national character varying(50),
    _book                           national character varying(50),
    _reference_number               national character varying(50),
    _statement_reference            national character varying(50),
    _posted_by                      national character varying(50),
    _office                         national character varying(50),
    _status                         national character varying(12),
    _verified_by                    national character varying(50),
    _reason                         national character varying(128)
)
RETURNS TABLE
(
    transaction_master_id           bigint,
    transaction_code                national character varying(50),
    book                            national character varying(50),
    value_date                      date,
    reference_number                national character varying(24),
    statement_reference             text,
    posted_by                       text,
    office                          text,
    status                          text,
    verified_by                     text,
    verified_on                     TIMESTAMP WITH TIME ZONE,
    reason                          national character varying(128),
    transaction_ts                  TIMESTAMP WITH TIME ZONE,
    flag_bg                         text,
    flag_fg                         text
)
AS
$$
BEGIN
    RETURN QUERY
    WITH RECURSIVE office_cte(office_id) AS 
    (
        SELECT _office_id
        UNION ALL
        SELECT
            c.office_id
        FROM 
        office_cte AS p, 
        office.offices AS c 
        WHERE 
        parent_office_id = p.office_id
    )

    SELECT 
        transactions.transaction_master.transaction_master_id, 
        transactions.transaction_master.transaction_code,
        transactions.transaction_master.book,
        transactions.transaction_master.value_date,
        transactions.transaction_master.reference_number,
        transactions.transaction_master.statement_reference,
        office.get_user_name_by_user_id(transactions.transaction_master.user_id) as posted_by,
        office.get_office_name_by_id(transactions.transaction_master.office_id) as office,
        core.get_verification_status_name_by_verification_status_id(transactions.transaction_master.verification_status_id) as status,
        office.get_user_name_by_user_id(transactions.transaction_master.verified_by_user_id) as verified_by,
        transactions.transaction_master.last_verified_on AS verified_on,
        transactions.transaction_master.verification_reason AS reason,    
        transactions.transaction_master.transaction_ts,
        core.get_flag_background_color(core.get_flag_type_id(_user_id, 'transactions.transaction_master', 'transaction_master_id', transactions.transaction_master.transaction_master_id::text)) AS flag_bg,
        core.get_flag_foreground_color(core.get_flag_type_id(_user_id, 'transactions.transaction_master', 'transaction_master_id', transactions.transaction_master.transaction_master_id::text)) AS flag_fg
    FROM transactions.transaction_master
    WHERE 1 = 1
    AND transactions.transaction_master.value_date BETWEEN _from AND _to
    AND office_id IN (SELECT office_id FROM office_cte)
    AND (_tran_id = 0 OR _tran_id  = transactions.transaction_master.transaction_master_id)
    AND lower(transactions.transaction_master.transaction_code) LIKE '%' || lower(_tran_code) || '%' 
    AND lower(transactions.transaction_master.book) LIKE '%' || lower(_book) || '%' 
    AND COALESCE(lower(transactions.transaction_master.reference_number), '') LIKE '%' || lower(_reference_number) || '%' 
    AND COALESCE(lower(transactions.transaction_master.statement_reference), '') LIKE '%' || lower(_statement_reference) || '%' 
    AND COALESCE(lower(transactions.transaction_master.verification_reason), '') LIKE '%' || lower(_reason) || '%' 
    AND lower(office.get_user_name_by_user_id(transactions.transaction_master.user_id)) LIKE '%' || lower(_posted_by) || '%' 
    AND lower(office.get_office_name_by_id(transactions.transaction_master.office_id)) LIKE '%' || lower(_office) || '%' 
    AND COALESCE(lower(core.get_verification_status_name_by_verification_status_id(transactions.transaction_master.verification_status_id)), '') LIKE '%' || lower(_status) || '%' 
    AND COALESCE(lower(office.get_user_name_by_user_id(transactions.transaction_master.verified_by_user_id)), '') LIKE '%' || lower(_verified_by) || '%'    
    ORDER BY value_date ASC, verification_status_id DESC;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_journal_view(2,1,'1-1-2000','1-1-2020',0,'', 'Jou', '', '','', '','','', '');


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_last_receipt_date.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_last_receipt_date(office_id integer, party_id bigint);
CREATE FUNCTION transactions.get_last_receipt_date(office_id integer, party_id bigint)
RETURNS date
AS
$$
BEGIN
    RETURN
    (
        SELECT MAX(transactions.verified_transaction_view.value_date)
        FROM transactions.verified_transaction_view
        INNER JOIN transactions.customer_receipts
        ON transactions.verified_transaction_view.transaction_master_id = transactions.customer_receipts.transaction_master_id
        WHERE transactions.verified_transaction_view.office_id=$1
        AND transactions.customer_receipts.party_id = $2
    );
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_mavcogs.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_mavcogs(_item_id integer, _store_id integer, _base_quantity decimal, _factor decimal(24, 4));

CREATE FUNCTION transactions.get_mavcogs(_item_id integer, _store_id integer, _base_quantity decimal, _factor decimal(24, 4))
RETURNS decimal(24, 4)
AS
$$
        DECLARE _base_unit_cost money_strict;
BEGIN
        CREATE TEMPORARY TABLE temp_staging
        (
                id              SERIAL NOT NULL,
                value_date      date,
                audit_ts        TIMESTAMP WITH TIME ZONE,
                base_quantity   decimal,
                price           decimal
                
        ) ON COMMIT DROP;


        INSERT INTO temp_staging(value_date, audit_ts, base_quantity, price)
        SELECT value_date, audit_ts, 
        CASE WHEN tran_type = 'Dr' THEN
        base_quantity ELSE base_quantity  * -1 END, 
        CASE WHEN tran_type = 'Dr' THEN
        (price * quantity/base_quantity)
        ELSE
        0
        END
        FROM transactions.verified_stock_details_view
        WHERE item_id = $1
        AND store_id=$2
        order by value_date, audit_ts, stock_detail_id;




        WITH RECURSIVE stock_transaction(id, base_quantity, price, sum_m, sum_base_quantity, last_id) AS 
        (
          SELECT id, base_quantity, price, base_quantity * price, base_quantity, id
          FROM temp_staging WHERE id = 1
          UNION ALL
          SELECT child.id, child.base_quantity, 
                 CASE WHEN child.base_quantity < 0 then parent.sum_m / parent.sum_base_quantity ELSE child.price END, 
                 parent.sum_m + CASE WHEN child.base_quantity < 0 then parent.sum_m / parent.sum_base_quantity ELSE child.price END * child.base_quantity,
                 parent.sum_base_quantity + child.base_quantity,
                 child.id 
          FROM temp_staging child JOIN stock_transaction parent on child.id = parent.last_id + 1
        )

        SELECT 
                --base_quantity,                                                        --left for debuging purpose
                --price,                                                                --left for debuging purpose
                --base_quantity * price AS amount,                                      --left for debuging purpose
                --SUM(base_quantity * price) OVER(ORDER BY id) AS cv_amount,            --left for debuging purpose
                --SUM(base_quantity) OVER(ORDER BY id) AS cv_quantity,                  --left for debuging purpose
                SUM(base_quantity * price) OVER(ORDER BY id)  / SUM(base_quantity) OVER(ORDER BY id) INTO _base_unit_cost
        FROM stock_transaction
        ORDER BY id DESC
        LIMIT 1;

        RETURN _base_unit_cost * _factor * _base_quantity;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_non_gl_product_view.sql --<--<--

DROP FUNCTION IF EXISTS transactions.get_non_gl_product_view
(   
    user_id_                integer,
    book_                   text,
    office_id_              integer,
    date_from_              date, 
    date_to_                date, 
    office_                 national character varying(12),
    party_                  text,   
    price_type_             text,
    user_                   national character varying(50),
    reference_number_           national character varying(24),
    statement_reference_            text
 );

CREATE FUNCTION transactions.get_non_gl_product_view
(
    user_id_                integer,
    book_                   text,
    office_id_              integer,
    date_from_              date, 
    date_to_                date, 
    office_                 national character varying(12),
    party_                  text,   
    price_type_             text,
    user_                   national character varying(50),
    reference_number_           national character varying(24),
    statement_reference_            text
 )
RETURNS TABLE
(
    id                  bigint,
    value_date              date,
    office                  national character varying(12),
    party                   text,
    price_type              text,
    amount                      decimal(24, 4),
    transaction_ts              TIMESTAMP WITH TIME ZONE,
    "user"                  national character varying(50),
    reference_number            national character varying(24),
    statement_reference         text,
    book                            text,
    flag_background_color           text,
    flag_foreground_color           text
)
AS
$$
BEGIN
    RETURN QUERY 
    WITH RECURSIVE office_cte(office_id) AS 
    (
        SELECT office_id_
        UNION ALL
        SELECT
            c.office_id
        FROM 
        office_cte AS p, 
        office.offices AS c 
        WHERE 
        parent_office_id = p.office_id
    )

    SELECT
        transactions.non_gl_stock_master.non_gl_stock_master_id AS id,
        transactions.non_gl_stock_master.value_date,
        office.offices.office_code AS office,
        core.parties.party_code || ' (' || core.parties.party_name || ')' AS party,
        core.price_types.price_type_code || ' (' || core.price_types.price_type_name || ')' AS price_type,
        SUM(transactions.non_gl_stock_details.price * transactions.non_gl_stock_details.quantity + tax - discount)::decimal(24, 4) AS amount,
        transactions.non_gl_stock_master.transaction_ts,
        office.users.user_name AS user,
        transactions.non_gl_stock_master.reference_number,
        transactions.non_gl_stock_master.statement_reference,
        transactions.non_gl_stock_master.book::text,
        core.get_flag_background_color(core.get_flag_type_id(user_id_, 'transactions.non_gl_stock_master', 'non_gl_stock_master_id', transactions.non_gl_stock_master.non_gl_stock_master_id::text)) AS flag_bg,
        core.get_flag_foreground_color(core.get_flag_type_id(user_id_, 'transactions.non_gl_stock_master', 'non_gl_stock_master_id', transactions.non_gl_stock_master.non_gl_stock_master_id::text)) AS flag_fg
    FROM transactions.non_gl_stock_master
    INNER JOIN transactions.non_gl_stock_details
    ON transactions.non_gl_stock_master.non_gl_stock_master_id = transactions.non_gl_stock_details.non_gl_stock_master_id
    INNER JOIN core.parties
    ON transactions.non_gl_stock_master.party_id = core.parties.party_id
    INNER JOIN office.users
    ON transactions.non_gl_stock_master.user_id = office.users.user_id
    INNER JOIN office.offices
    ON transactions.non_gl_stock_master.office_id = office.offices.office_id
    LEFT OUTER JOIN core.price_types
    ON transactions.non_gl_stock_master.price_type_id = core.price_types.price_type_id
    WHERE transactions.non_gl_stock_master.book = book_
    AND transactions.non_gl_stock_master.value_date BETWEEN date_from_ AND date_to_
    AND 
    lower
    (
        core.parties.party_code || ' (' || core.parties.party_name || ')'
    ) LIKE '%' || lower(party_) || '%'
    AND
    lower
    (
        COALESCE(core.price_types.price_type_code, '') || ' (' || COALESCE(core.price_types.price_type_name, '') || ')'
    ) LIKE '%' || lower(price_type_) || '%'
    AND 
    lower
    (
        office.users.user_name
    )  LIKE '%' || lower(user_) || '%'
    AND 
    lower
    (
        COALESCE(transactions.non_gl_stock_master.reference_number, '')
    ) LIKE '%' || lower(reference_number_) || '%'
    AND 
    lower
    (
        COALESCE(transactions.non_gl_stock_master.statement_reference, '')
    ) LIKE '%' || lower(statement_reference_) || '%'    
    AND lower
    (
        office.offices.office_code
    ) LIKE '%' || lower(office_) || '%' 
    AND office.offices.office_id IN (SELECT office_id FROM office_cte)
    GROUP BY 
        transactions.non_gl_stock_master.non_gl_stock_master_id,
        transactions.non_gl_stock_master.value_date,
        office.offices.office_code,
        core.parties.party_code,
        core.parties.party_name,
        core.price_types.price_type_code,
        core.price_types.price_type_name,
        transactions.non_gl_stock_master.transaction_ts,
        office.users.user_name,
        transactions.non_gl_stock_master.reference_number,
        transactions.non_gl_stock_master.statement_reference,
        transactions.non_gl_stock_master.book
    LIMIT 100;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_non_gl_product_view(1,'Purchase.Order',1, '1-1-2000', '1-1-2050', '', '', '', '', '', '');




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_party_transaction_summary.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_party_transaction_summary
(
    office_id integer, 
    party_id bigint
);

CREATE FUNCTION transactions.get_party_transaction_summary
(
    office_id integer, 
    party_id bigint, 
    OUT currency_code text, 
    OUT currency_symbol text, 
    OUT total_due_amount decimal(24, 4), 
    OUT office_due_amount decimal(24, 4), 
    OUT accrued_interest decimal(24, 4), 
    OUT last_receipt_date date, 
    OUT transaction_value decimal(24, 4)
)
AS
$$
    DECLARE root_office_id integer = 0;
BEGIN
    currency_code := core.get_currency_code_by_party_id(party_id);

    SELECT core.currencies.currency_symbol into $4
    FROM core.currencies
    WHERE core.currencies.currency_code = $3;

    SELECT office.offices.office_id INTO root_office_id
    FROM office.offices
    WHERE parent_office_id IS NULL;

    total_due_amount := transactions.get_total_due(root_office_id, party_id);

    office_due_amount := transactions.get_total_due(office_id, party_id);


    accrued_interest := transactions.get_accrued_interest(office_id, party_id);

    last_receipt_date := transactions.get_last_receipt_date(office_id, party_id);

    transaction_value := transactions.get_average_party_transaction(party_id, office_id);


    RETURN;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_product_view.sql --<--<--

DROP FUNCTION IF EXISTS transactions.get_product_view
(   
    user_id_                integer,
    book_                   text,
    office_id_              integer,
    date_from_              date, 
    date_to_                date, 
    office_                 national character varying(12),
    party_                  text,   
    price_type_             text,
    user_                   national character varying(50),
    reference_number_           national character varying(24),
    statement_reference_            text
 );

CREATE FUNCTION transactions.get_product_view
(
    user_id_                integer,
    book_                   text,
    office_id_              integer,
    date_from_              date, 
    date_to_                date, 
    office_                 national character varying(12),
    party_                  text,   
    price_type_             text,
    user_                   national character varying(50),
    reference_number_           national character varying(24),
    statement_reference_            text
 )
RETURNS TABLE
(
    id                      bigint,
    value_date              date,
    office                  national character varying(12),
    party                   text,
    price_type              text,
    amount                  decimal(24, 4),
    transaction_ts          TIMESTAMP WITH TIME ZONE,
    "user"                  national character varying(50),
    reference_number        national character varying(24),
    statement_reference     text,
    book                    text,
    salesperson             text,
    is_credit               boolean,
    shipper                 text,
    shipping_address_code   text,
    store                   text,   
    flag_background_color   text,
    flag_foreground_color   text
)
AS
$$
BEGIN
        CREATE TEMPORARY TABLE IF NOT EXISTS temp_book(book text) ON COMMIT DROP;

    RETURN QUERY
    WITH RECURSIVE office_cte(office_id) AS 
    (
        SELECT office_id_
        UNION ALL
        SELECT
            c.office_id
        FROM 
        office_cte AS p, 
        office.offices AS c 
        WHERE 
        parent_office_id = p.office_id
    )

    SELECT
        transactions.stock_master.transaction_master_id AS id,
        transactions.transaction_master.value_date,
        office.offices.office_code AS office,
        core.parties.party_code || ' (' || core.parties.party_name || ')' AS party,
        core.price_types.price_type_code || ' (' || core.price_types.price_type_name || ')' AS price_type,
        SUM(transactions.stock_details.price * transactions.stock_details.quantity + tax - discount)::decimal(24, 4) AS amount,
        transactions.transaction_master.transaction_ts,
        office.users.user_name AS user,
        transactions.transaction_master.reference_number,
        transactions.transaction_master.statement_reference,
                transactions.transaction_master.book::text,
        core.get_salesperson_name_by_salesperson_id(transactions.stock_master.salesperson_id),
        transactions.stock_master.is_credit,
        core.get_shipper_name_by_shipper_id(transactions.stock_master.shipper_id),
        core.get_shipping_address_code_by_shipping_address_id(transactions.stock_master.shipping_address_id),
        office.get_store_name_by_store_id(transactions.stock_master.store_id),
        core.get_flag_background_color(core.get_flag_type_id(user_id_, 'transactions.transaction_master', 'transaction_master_id', transactions.stock_master.transaction_master_id::text)) AS flag_bg,
        core.get_flag_foreground_color(core.get_flag_type_id(user_id_, 'transactions.transaction_master', 'transaction_master_id', transactions.stock_master.transaction_master_id::text)) AS flag_fg
    FROM transactions.stock_master
    INNER JOIN transactions.stock_details
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    LEFT OUTER JOIN core.parties
    ON transactions.stock_master.party_id = core.parties.party_id
    INNER JOIN transactions.transaction_master
    ON transactions.transaction_master.transaction_master_id=transactions.stock_master.transaction_master_id
    INNER JOIN office.users
    ON transactions.transaction_master.user_id = office.users.user_id
    INNER JOIN office.offices
    ON transactions.transaction_master.office_id = office.offices.office_id
    LEFT OUTER JOIN core.price_types
    ON transactions.stock_master.price_type_id = core.price_types.price_type_id
    WHERE transactions.transaction_master.book = book_
    AND transactions.transaction_master.verification_status_id > 0
    AND transactions.transaction_master.value_date BETWEEN date_from_ AND date_to_
    AND 
    lower
    (
        COALESCE(core.parties.party_code || ' (' || core.parties.party_name || ')', '')
    ) LIKE '%' || lower(party_) || '%'
    AND
    lower
    (
        COALESCE(core.price_types.price_type_code, '') || ' (' || COALESCE(core.price_types.price_type_name, '') || ')'
    ) LIKE '%' || lower(price_type_) || '%'
    AND 
    lower
    (
        office.users.user_name
    )  LIKE '%' || lower(user_) || '%'
    AND 
    lower
    (
        transactions.transaction_master.reference_number
    ) LIKE '%' || lower(reference_number_) || '%'
    AND 
    lower
    (
        transactions.transaction_master.statement_reference
    ) LIKE '%' || lower(statement_reference_) || '%'    
    AND lower
    (
        office.offices.office_code
    ) LIKE '%' || lower(office_) || '%' 
    AND office.offices.office_id IN (SELECT office_id FROM office_cte)
    GROUP BY 
        transactions.stock_master.stock_master_id,
        transactions.transaction_master.value_date,
        office.offices.office_code,
        core.parties.party_code,
        core.parties.party_name,
        core.price_types.price_type_code,
        core.price_types.price_type_name,
        transactions.transaction_master.transaction_ts,
        office.users.user_name,
        transactions.transaction_master.reference_number,
        transactions.transaction_master.statement_reference,
        transactions.transaction_master.book    
    LIMIT 100;
END
$$
LANGUAGE plpgsql;

--select * from transactions.get_product_view(1, 'Inventory.Transfer', 1, '1-1-2000',  '1-1-2020', '', '', '', '', '', '');



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_profit_and_loss_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_profit_and_loss_statement
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer,
    _compact                        boolean
);

CREATE FUNCTION transactions.get_profit_and_loss_statement
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _factor                         integer,
    _compact                        boolean DEFAULT(true)
)
RETURNS json
AS
$$
    DECLARE _sql                    text;
    DECLARE _periods                core.period[];
    DECLARE _json                   json;
    DECLARE this                    RECORD;
    DECLARE _balance                decimal(24, 4);
    DECLARE _is_periodic            boolean = office.is_periodic_inventory(_office_id);
BEGIN    
    DROP TABLE IF EXISTS pl_temp;
    CREATE TEMPORARY TABLE pl_temp
    (
        item_id                     integer PRIMARY KEY,
        item                        text,
        account_id                  integer,
        parent_item_id              integer REFERENCES pl_temp(item_id),
        is_profit                   boolean DEFAULT(false),
        is_summation                boolean DEFAULT(false),
        is_debit                    boolean DEFAULT(false),
        amount                      decimal(24, 4) DEFAULT(0)
    ) ON COMMIT DROP;

    IF(COALESCE(_factor, 0) = 0) THEN
        _factor := 1;
    END IF;

    _periods            := core.get_periods(_date_from, _date_to);

    IF(_periods IS NULL) THEN
        RAISE EXCEPTION 'Invalid period specified.'
        USING ERRCODE='P3009';
    END IF;

    SELECT string_agg(dynamic, '') FROM
    (
            SELECT 'ALTER TABLE pl_temp ADD COLUMN "' || period_name || '" decimal(24, 4) DEFAULT(0);' as dynamic
            FROM explode_array(_periods)
         
    ) periods
    INTO _sql;
    
    EXECUTE _sql;

    --PL structure setup start
    INSERT INTO pl_temp(item_id, item, is_summation, parent_item_id)
    SELECT 1000,   'Revenue',                      true,   NULL::integer   UNION ALL
    SELECT 2000,   'Cost of Sales',                true,   NULL::integer   UNION ALL
    SELECT 2001,   'Opening Stock',                false,  1000            UNION ALL
    SELECT 3000,   'Purchases',                    false,  1000            UNION ALL
    SELECT 4000,   'Closing Stock',                false,  1000            UNION ALL
    SELECT 5000,   'Direct Costs',                 true,   NULL::integer   UNION ALL
    SELECT 6000,   'Gross Profit',                 false,  NULL::integer   UNION ALL
    SELECT 7000,   'Operating Expenses',           true,   NULL::integer   UNION ALL
    SELECT 8000,   'Operating Profit',             false,  NULL::integer   UNION ALL
    SELECT 9000,   'Nonoperating Incomes',         true,   NULL::integer   UNION ALL
    SELECT 10000,  'Financial Incomes',            true,   NULL::integer   UNION ALL
    SELECT 11000,  'Financial Expenses',           true,   NULL::integer   UNION ALL
    SELECT 11100,  'Interest Expenses',            true,   11000           UNION ALL
    SELECT 12000,  'Profit Before Income Taxes',   false,  NULL::integer   UNION ALL
    SELECT 13000,  'Income Taxes',                 true,   NULL::integer   UNION ALL
    SELECT 13001,  'Income Tax Provison',          false,  13000            UNION ALL
    SELECT 14000,  'Net Profit',                   true,   NULL::integer;

    UPDATE pl_temp SET is_debit = true WHERE item_id IN(2001, 3000, 4000);
    UPDATE pl_temp SET is_profit = true WHERE item_id IN(6000,8000, 12000, 14000);
    
    INSERT INTO pl_temp(item_id, account_id, item, parent_item_id, is_debit)
    SELECT id, account_id, account_name, 1000 as parent_item_id, false as is_debit FROM core.get_account_view_by_account_master_id(20100, 1000) UNION ALL--Sales Accounts
    SELECT id, account_id, account_name, 2000 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20400, 2001) UNION ALL--COGS Accounts
    SELECT id, account_id, account_name, 5000 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20500, 5000) UNION ALL--Direct Cost
    SELECT id, account_id, account_name, 7000 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20600, 7000) UNION ALL--Operating Expenses
    SELECT id, account_id, account_name, 9000 as parent_item_id, false as is_debit FROM core.get_account_view_by_account_master_id(20200, 9000) UNION ALL--Nonoperating Incomes
    SELECT id, account_id, account_name, 10000 as parent_item_id, false as is_debit FROM core.get_account_view_by_account_master_id(20300, 10000) UNION ALL--Financial Incomes
    SELECT id, account_id, account_name, 11000 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20700, 11000) UNION ALL--Financial Expenses
    SELECT id, account_id, account_name, 11100 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20701, 11100) UNION ALL--Interest Expenses
    SELECT id, account_id, account_name, 13000 as parent_item_id, true as is_debit FROM core.get_account_view_by_account_master_id(20800, 13001);--Income Tax Expenses

    IF(NOT _is_periodic) THEN
        DELETE FROM pl_temp WHERE item_id IN(2001, 3000, 4000);
    END IF;
    --PL structure setup end


    FOR this IN SELECT * FROM explode_array(_periods) ORDER BY date_from ASC
    LOOP
        --Updating credit balances of individual GL accounts.
        _sql := 'UPDATE pl_temp SET "' || this.period_name || '"=tran.total_amount
        FROM
        (
            SELECT transactions.verified_transaction_mat_view.account_id,
            SUM(CASE tran_type WHEN ''Cr'' THEN amount_in_local_currency ELSE 0 END) - 
            SUM(CASE tran_type WHEN ''Dr'' THEN amount_in_local_currency ELSE 0 END) AS total_amount
        FROM transactions.verified_transaction_mat_view
        WHERE value_date >=''' || this.date_from::text || ''' AND value_date <=''' || this.date_to::text ||
        ''' AND office_id IN (SELECT * FROM office.get_office_ids(' || _office_id::text || '))
        GROUP BY transactions.verified_transaction_mat_view.account_id
        ) AS tran
        WHERE tran.account_id = pl_temp.account_id';
        EXECUTE _sql;

        --Reversing to debit balance for expense headings.
        _sql := 'UPDATE pl_temp SET "' || this.period_name || '"="' || this.period_name || '"*-1 WHERE is_debit;';
        EXECUTE _sql;

        --Getting purchase and stock balances if this is a periodic inventory system.
        --In perpetual accounting system, one would not need to include these headings 
        --because the COGS A/C would be automatically updated on each transaction.
        IF(_is_periodic) THEN
            _sql := 'UPDATE pl_temp SET "' || this.period_name || '"=transactions.get_closing_stock(''' || (this.date_from::TIMESTAMP - INTERVAL '1 day')::text ||  ''', ' || _office_id::text || ') WHERE item_id=2001;';
            EXECUTE _sql;

            _sql := 'UPDATE pl_temp SET "' || this.period_name || '"=transactions.get_purchase(''' || this.date_from::text ||  ''', ''' || this.date_to::text || ''', ' || _office_id::text || ') *-1 WHERE item_id=3000;';
            EXECUTE _sql;

            _sql := 'UPDATE pl_temp SET "' || this.period_name || '"=transactions.get_closing_stock(''' || this.date_from::text ||  ''', ' || _office_id::text || ') WHERE item_id=4000;';
            EXECUTE _sql;
        END IF;
    END LOOP;

    --Updating the column "amount" on each row by the sum of all periods.
    SELECT 'UPDATE pl_temp SET amount = ' || array_to_string(array_agg('COALESCE("' || period_name || '", 0)'), ' +') || ';'::text INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    --Updating amount and periodic balances on parent item by the sum of their respective child balances.
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') || 
    ' FROM 
    (
        SELECT parent_item_id,
        SUM(amount) AS amount, '
        || array_to_string(array_agg('SUM("' || period_name || '") AS "' || period_name || '"'), ',') || '
         FROM pl_temp
        GROUP BY parent_item_id
    ) 
    AS tran
        WHERE tran.parent_item_id = pl_temp.item_id;'
    INTO _sql
    FROM explode_array(_periods);
    EXECUTE _sql;

    --Updating Gross Profit.
    --Gross Profit = Revenue - (Cost of Sales + Direct Costs)
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT
        SUM(CASE item_id WHEN 1000 THEN amount ELSE amount * -1 END) AS amount, '
        || array_to_string(array_agg('SUM(CASE item_id WHEN 1000 THEN "' || period_name || '" ELSE "' || period_name || '" *-1 END) AS "' || period_name || '"'), ',') ||
    '
         FROM pl_temp
         WHERE item_id IN
         (
             1000,2000,5000
         )
    ) 
    AS tran
    WHERE item_id = 6000;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;


    --Updating Operating Profit.
    --Operating Profit = Gross Profit - Operating Expenses
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT
        SUM(CASE item_id WHEN 6000 THEN amount ELSE amount * -1 END) AS amount, '
        || array_to_string(array_agg('SUM(CASE item_id WHEN 6000 THEN "' || period_name || '" ELSE "' || period_name || '" *-1 END) AS "' || period_name || '"'), ',') ||
    '
         FROM pl_temp
         WHERE item_id IN
         (
             6000, 7000
         )
    ) 
    AS tran
    WHERE item_id = 8000;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    --Updating Profit Before Income Taxes.
    --Profit Before Income Taxes = Operating Profit + Nonoperating Incomes + Financial Incomes - Financial Expenses
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT
        SUM(CASE WHEN item_id IN(11000, 11100) THEN amount *-1 ELSE amount END) AS amount, '
        || array_to_string(array_agg('SUM(CASE WHEN item_id IN(11000, 11100) THEN "' || period_name || '"*-1  ELSE "' || period_name || '" END) AS "' || period_name || '"'), ',') ||
    '
         FROM pl_temp
         WHERE item_id IN
         (
             8000, 9000, 10000, 11000, 11100
         )
    ) 
    AS tran
    WHERE item_id = 12000;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    --Updating Income Tax Provison.
    --Income Tax Provison = Profit Before Income Taxes * Income Tax Rate - Paid Income Taxes
    SELECT * INTO this FROM pl_temp WHERE item_id = 12000;
    
    _sql := 'UPDATE pl_temp SET amount = core.get_income_tax_provison_amount(' || _office_id::text || ',' || this.amount::text || ',(SELECT amount FROM pl_temp WHERE item_id = 13000)), ' 
    || array_to_string(array_agg('"' || period_name || '"=core.get_income_tax_provison_amount(' || _office_id::text || ',' || core.get_field(hstore(this.*), period_name) || ', (SELECT "' || period_name || '" FROM pl_temp WHERE item_id = 13000))'), ',')
            || ' WHERE item_id = 13001;'
    FROM explode_array(_periods);

    EXECUTE _sql;

    --Updating amount and periodic balances on parent item by the sum of their respective child balances, once again to add the Income Tax Provison to Income Tax Expenses.
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT parent_item_id,
        SUM(amount) AS amount, '
        || array_to_string(array_agg('SUM("' || period_name || '") AS "' || period_name || '"'), ',') ||
    '
         FROM pl_temp
        GROUP BY parent_item_id
    ) 
    AS tran
        WHERE tran.parent_item_id = pl_temp.item_id;'
    INTO _sql
    FROM explode_array(_periods);
    EXECUTE _sql;


    --Updating Net Profit.
    --Net Profit = Profit Before Income Taxes - Income Tax Expenses
    SELECT 'UPDATE pl_temp SET amount = tran.amount, ' || array_to_string(array_agg('"' || period_name || '"=tran."' || period_name || '"'), ',') 
    || ' FROM 
    (
        SELECT
        SUM(CASE item_id WHEN 13000 THEN amount *-1 ELSE amount END) AS amount, '
        || array_to_string(array_agg('SUM(CASE item_id WHEN 13000 THEN "' || period_name || '"*-1  ELSE "' || period_name || '" END) AS "' || period_name || '"'), ',') ||
    '
         FROM pl_temp
         WHERE item_id IN
         (
             12000, 13000
         )
    ) 
    AS tran
    WHERE item_id = 14000;'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    --Removing ledgers having zero balances
    DELETE FROM pl_temp
    WHERE COALESCE(amount, 0) = 0
    AND account_id IS NOT NULL;


    --Dividing by the factor.
    SELECT 'UPDATE pl_temp SET amount = amount /' || _factor::text || ',' || array_to_string(array_agg('"' || period_name || '"="' || period_name || '"/' || _factor::text), ',') || ';'
    INTO _sql
    FROM explode_array(_periods);
    EXECUTE _sql;


    --Converting 0's to NULLS.
    SELECT 'UPDATE pl_temp SET amount = CASE WHEN amount = 0 THEN NULL ELSE amount END,' || array_to_string(array_agg('"' || period_name || '"= CASE WHEN "' || period_name || '" = 0 THEN NULL ELSE "' || period_name || '" END'), ',') || ';'
    INTO _sql
    FROM explode_array(_periods);

    EXECUTE _sql;

    IF(_compact) THEN
        SELECT array_to_json(array_agg(row_to_json(report)))
        INTO _json
        FROM
        (
            SELECT item, amount, is_profit, is_summation
            FROM pl_temp
            ORDER BY item_id
        ) AS report;
    ELSE
        SELECT 
        'SELECT array_to_json(array_agg(row_to_json(report)))
        FROM
        (
            SELECT item, amount,'
            || array_to_string(array_agg('"' || period_name || '"'), ',') ||
            ', is_profit, is_summation FROM pl_temp
            ORDER BY item_id
        ) AS report;'
        INTO _sql
        FROM explode_array(_periods);

        EXECUTE _sql INTO _json ;
    END IF;    

    RETURN _json;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_net_profit
(
    _date_from                      date,
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer,
    _no_provison                    boolean
);

CREATE FUNCTION transactions.get_net_profit
(
    _date_from                      date,
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer,
    _no_provison                    boolean DEFAULT false
)
RETURNS decimal(24, 4)
AS
$$
    DECLARE _incomes                decimal(24, 4) = 0;
    DECLARE _expenses               decimal(24, 4) = 0;
    DECLARE _profit_before_tax      decimal(24, 4) = 0;
    DECLARE _tax_paid               decimal(24, 4) = 0;
    DECLARE _tax_provison           decimal(24, 4) = 0;
BEGIN
    SELECT SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END)
    INTO _incomes
    FROM transactions.verified_transaction_mat_view
    WHERE value_date >= _date_from AND value_date <= _date_to
    AND account_master_id >=20100
    AND account_master_id <= 20300;
    
    SELECT SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END)
    INTO _expenses
    FROM transactions.verified_transaction_mat_view
    WHERE value_date >= _date_from AND value_date <= _date_to
    AND account_master_id >=20400
    AND account_master_id <= 20701;
    
    SELECT SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END)
    INTO _tax_paid
    FROM transactions.verified_transaction_mat_view
    WHERE value_date >= _date_from AND value_date <= _date_to
    AND account_master_id =20800;
    
    _profit_before_tax := COALESCE(_incomes, 0) - COALESCE(_expenses, 0);

    IF(_no_provison) THEN
        RETURN (_profit_before_tax - COALESCE(_tax_paid, 0)) / _factor;
    END IF;
    
    _tax_provison      := core.get_income_tax_provison_amount(_office_id, _profit_before_tax, COALESCE(_tax_paid, 0));
    
    RETURN (_profit_before_tax - (COALESCE(_tax_provison, 0) + COALESCE(_tax_paid, 0))) / _factor;
END
$$
LANGUAGE plpgsql;



--SELECT transactions.get_profit_and_loss_statement('1-1-2000','1-15-2020', 2, 2, 1000,false), transactions.get_net_profit('1-1-2000','1-15-2020', 2, 1000);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_purchase.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_purchase
(
    _date_from          date,
    _date_to            date,
    _office_id          integer
);

CREATE FUNCTION transactions.get_purchase
(
    _date_from          date,
    _date_to            date,
    _office_id          integer
)
RETURNS decimal(24, 4)
AS
$$
BEGIN
    RETURN 0;--TODO
END
$$
LANGUAGE plpgsql;

SELECT transactions.get_purchase('2-3-30', '1-1-10', 2);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_receipt_view.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_receipt_view
(
    _user_id                integer,
    _office_id              integer,
    _date_from              date, 
    _date_to                date, 
    _office                 national character varying(12),
    _party                  text,   
    _user                   national character varying(50),
    _reference_number           national character varying(24),
    _statement_reference            text
);

CREATE FUNCTION transactions.get_receipt_view
(
    _user_id                integer,
    _office_id              integer,
    _date_from              date, 
    _date_to                date, 
    _office                 national character varying(12),
    _party                  text,   
    _user                   national character varying(50),
    _reference_number           national character varying(24),
    _statement_reference            text
)
RETURNS TABLE
(
        id                                      bigint,
        value_date                              date,
        reference_number                        text,
        statement_reference                     text,
        office                                  text,
        party                                   text,
        "user"                                    text,
        currency_code                           text,
        amount                                  money_strict,
    transaction_ts              TIMESTAMP WITH TIME ZONE,
    flag_background_color           text,
    flag_foreground_color           text
)
AS
$$
BEGIN
    RETURN QUERY 
        SELECT
                transactions.transaction_master.transaction_master_id,
                transactions.transaction_master.value_date,
                transactions.transaction_master.reference_number::text,
                transactions.transaction_master.statement_reference::text,
                office.offices.office_code || ' (' || office.offices.office_name || ')' as office,
                core.parties.party_code || ' (' || core.parties.party_name || ')' as party,
                office.users.user_name::text,
                transactions.customer_receipts.currency_code::text,
                transactions.customer_receipts.amount,
        transactions.transaction_master.transaction_ts,
        core.get_flag_background_color(core.get_flag_type_id(_user_id, 'transactions.transaction_master', 'transaction_master_id', transactions.transaction_master.transaction_master_id::text)) AS flag_bg,
        core.get_flag_foreground_color(core.get_flag_type_id(_user_id, 'transactions.transaction_master', 'transaction_master_id', transactions.transaction_master.transaction_master_id::text)) AS flag_fg                
        FROM transactions.customer_receipts
        INNER JOIN core.parties
        ON transactions.customer_receipts.party_id = core.parties.party_id
        INNER JOIN transactions.transaction_master
        ON transactions.customer_receipts.transaction_master_id = transactions.transaction_master.transaction_master_id
        INNER JOIN office.offices
        ON transactions.transaction_master.office_id = office.offices.office_id
        INNER JOIN office.users
        ON transactions.transaction_master.user_id = office.users.user_id
        WHERE transactions.transaction_master.verification_status_id > 0
        AND transactions.transaction_master.office_id IN (SELECT * FROM office.get_office_ids(_office_id))
    AND transactions.transaction_master.value_date BETWEEN _date_from AND _date_to
        AND
    lower
    (
        core.parties.party_code || ' (' || core.parties.party_name || ')'
    ) LIKE '%' || lower(_party) || '%'
    AND 
    lower
    (
        office.users.user_name
    )  LIKE '%' || lower(_user) || '%'
    AND 
    lower
    (
        transactions.transaction_master.reference_number
    ) LIKE '%' || lower(_reference_number) || '%'
    AND 
    lower
    (
        transactions.transaction_master.statement_reference
    ) LIKE '%' || lower(_statement_reference) || '%'    
    AND lower
    (
        office.offices.office_code
    ) LIKE '%' || lower(_office) || '%'
    LIMIT 100;
END
$$
LANGUAGE plpgsql;




--SELECT * FROM transactions.get_receipt_view(1, 1,'1-1-2000','1-1-2020','','','','','');



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_reorder_view_function.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_reorder_view_function(office_id integer);

CREATE FUNCTION transactions.get_reorder_view_function(office_id integer)
RETURNS TABLE
(
        item_id                 integer,
        item_code               national character varying(12),
        item_name               national character varying(150),
        unit_id                 integer,
        unit                    text,
        quantity_on_hand        numeric,
        reorder_level           integer,
        reorder_quantity        integer,
        preferred_supplier_id   bigint,
        preferred_supplier      text,
        price                   money_strict2,
        tax                     national character varying(24)
)
AS
$$
BEGIN
        RETURN QUERY
        SELECT 
                core.items.item_id,
                core.items.item_code,
                core.items.item_name,
                core.items.reorder_unit_id,
                core.units.unit_name::text AS unit,
                floor(office.count_item_in_stock(core.items.item_id, core.items.reorder_unit_id, $1)) AS quantity_on_hand,
                core.items.reorder_level,
                core.items.reorder_quantity,
                core.items.preferred_supplier_id,
                core.parties.party_code || ' (' || core.parties.party_name || ')'::text AS party,
                core.get_item_cost_price(core.items.item_id, core.items.reorder_unit_id, core.items.preferred_supplier_id),
                core.get_sales_tax_code_by_sales_tax_id(core.items.sales_tax_id) as tax
        FROM core.items
        INNER JOIN core.parties
        ON core.items.preferred_supplier_id = core.parties.party_id
        INNER JOIN core.units
        ON core.items.reorder_unit_id = core.units.unit_id
        WHERE 
        floor
        (
                office.count_item_in_stock(core.items.item_id, core.items.reorder_unit_id, $1)
                +
                core.get_ordered_quantity(core.items.item_id, core.items.reorder_unit_id, $1)
        ) 

        < core.items.reorder_level
        AND core.items.reorder_quantity > 0;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_reorder_view_function(2);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_retained_earnings.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_retained_earnings
(
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer
);

CREATE FUNCTION transactions.get_retained_earnings
(
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer
)
RETURNS decimal(24, 4)
AS
$$
    DECLARE     _date_from              date;
    DECLARE     _net_profit             decimal(24, 4);
    DECLARE     _paid_dividends         decimal(24, 4);
BEGIN
    IF(COALESCE(_factor, 0) = 0) THEN
        _factor := 1;
    END IF;
    _date_from              := core.get_fiscal_year_start_date(_office_id);    
    _net_profit             := transactions.get_net_profit(_date_from, _date_to, _office_id, _factor, true);

    SELECT 
        COALESCE(SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE amount_in_local_currency * -1 END) / _factor, 0)
    INTO 
        _paid_dividends
    FROM transactions.verified_transaction_mat_view
    WHERE value_date <=_date_to
    AND account_master_id BETWEEN 15300 AND 15400
    AND office_id IN (SELECT * FROM office.get_office_ids(_office_id));
    
    RETURN _net_profit - _paid_dividends;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_retained_earnings_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_retained_earnings_statement
(
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer    
);

CREATE FUNCTION transactions.get_retained_earnings_statement
(
    _date_to                        date,
    _office_id                      integer,
    _factor                         integer    
)
RETURNS TABLE
(
    id                              integer,
    value_date                      date,
    tran_code                       text,
    statement_reference             text,
    debit                           decimal(24, 4),
    credit                          decimal(24, 4),
    balance                         decimal(24, 4),
    office                          text,
    book                            text,
    account_id                      integer,
    account_number                  text,
    account                         text,
    posted_on                       TIMESTAMP WITH TIME ZONE,
    posted_by                       text,
    approved_by                     text,
    verification_status             integer
)
AS
$$
    DECLARE _accounts               integer[];
    DECLARE _date_from              date;
    DECLARE _net_profit             decimal(24, 4)  = 0;
    DECLARE _income_tax_rate        real            = 0;
    DECLARE _itp                    decimal(24, 4)  = 0;
BEGIN
    _date_from                      := core.get_fiscal_year_start_date(_office_id);
    _net_profit                     := transactions.get_net_profit(_date_from, _date_to, _office_id, _factor);
    _income_tax_rate                := core.get_income_tax_rate(_office_id);

    IF(COALESCE(_factor , 0) = 0) THEN
        _factor                         := 1;
    END IF; 

    IF(_income_tax_rate != 0) THEN
        _itp                            := (_net_profit * _income_tax_rate) / (100 - _income_tax_rate);
    END IF;

    DROP TABLE IF EXISTS temp_account_statement;
    CREATE TEMPORARY TABLE temp_account_statement
    (
        id                          SERIAL,
        value_date                  date,
        tran_code                   text,
        statement_reference         text,
        debit                       decimal(24, 4),
        credit                      decimal(24, 4),
        balance                     decimal(24, 4),
        office                      text,
        book                        text,
        account_id                  integer,
        account_number              text,
        account                     text,
        posted_on                   TIMESTAMP WITH TIME ZONE,
        posted_by                   text,
        approved_by                 text,
        verification_status         integer
    ) ON COMMIT DROP;

    SELECT array_agg(core.accounts.account_id) INTO _accounts
    FROM core.accounts
    WHERE core.accounts.account_master_id BETWEEN 15300 AND 15400;

    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit, office, book, account_id, posted_on, posted_by, approved_by, verification_status)
    SELECT
        _date_from,
        NULL,
        'Beginning balance on this fiscal year.',
        NULL,
        SUM
        (
            CASE transactions.transaction_details.tran_type
            WHEN 'Cr' THEN amount_in_local_currency
            ELSE amount_in_local_currency * -1 
            END            
        ) as credit,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    FROM transactions.transaction_master
    INNER JOIN transactions.transaction_details
    ON transactions.transaction_master.transaction_master_id = transactions.transaction_details.transaction_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND
        transactions.transaction_master.value_date < _date_from
    AND
       transactions.transaction_master.office_id IN (SELECT * FROM office.get_office_ids(_office_id)) 
    AND
       transactions.transaction_details.account_id = ANY(_accounts);

    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit)
    SELECT _date_to, '', format('Add: Net Profit as on %1$s.', _date_to::text), 0, _net_profit;

    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit)
    SELECT _date_to, '', 'Add: Income Tax provison.', 0, _itp;

--     DELETE FROM temp_account_statement
--     WHERE COALESCE(temp_account_statement.debit, 0) = 0
--     AND COALESCE(temp_account_statement.credit, 0) = 0;
    

    UPDATE temp_account_statement SET 
    debit = temp_account_statement.credit * -1,
    credit = 0
    WHERE temp_account_statement.credit < 0;


    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit, office, book, account_id, posted_on, posted_by, approved_by, verification_status)
    SELECT
        transactions.transaction_master.value_date,
        transactions.transaction_master. transaction_code,
        transactions.transaction_details.statement_reference,
        CASE transactions.transaction_details.tran_type
        WHEN 'Dr' THEN amount_in_local_currency / _factor
        ELSE NULL END,
        CASE transactions.transaction_details.tran_type
        WHEN 'Cr' THEN amount_in_local_currency / _factor
        ELSE NULL END,
        office.get_office_name_by_id(transactions.transaction_master.office_id),
        transactions.transaction_master.book,
        transactions.transaction_details.account_id,
        transactions.transaction_master.transaction_ts,
        office.get_user_name_by_user_id(COALESCE(transactions.transaction_master.user_id, transactions.transaction_master.sys_user_id)),
        office.get_user_name_by_user_id(transactions.transaction_master.verified_by_user_id),
        transactions.transaction_master.verification_status_id
    FROM transactions.transaction_master
    INNER JOIN transactions.transaction_details
    ON transactions.transaction_master.transaction_master_id = transactions.transaction_details.transaction_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND
        transactions.transaction_master.value_date >= _date_from
    AND
        transactions.transaction_master.value_date <= _date_to
    AND
       transactions.transaction_master.office_id IN (SELECT * FROM office.get_office_ids(_office_id)) 
    AND
       transactions.transaction_details.account_id = ANY(_accounts)
    ORDER BY 
        transactions.transaction_master.value_date,
        transactions.transaction_master.last_verified_on;


    UPDATE temp_account_statement
    SET balance = c.balance
    FROM
    (
        SELECT
            temp_account_statement.id, 
            SUM(COALESCE(c.credit, 0)) 
            - 
            SUM(COALESCE(c.debit,0)) As balance
        FROM temp_account_statement
        LEFT JOIN temp_account_statement AS c 
            ON (c.id <= temp_account_statement.id)
        GROUP BY temp_account_statement.id
        ORDER BY temp_account_statement.id
    ) AS c
    WHERE temp_account_statement.id = c.id;

    UPDATE temp_account_statement SET 
        account_number = core.accounts.account_number,
        account = core.accounts.account_name
    FROM core.accounts
    WHERE temp_account_statement.account_id = core.accounts.account_id;


    UPDATE temp_account_statement SET debit = NULL WHERE temp_account_statement.debit = 0;
    UPDATE temp_account_statement SET credit = NULL WHERE temp_account_statement.credit = 0;

    RETURN QUERY
    SELECT * FROM temp_account_statement
    ORDER BY id;    
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_retained_earnings_statement('7/16/2015', 2, 1000);

--SELECT * FROM transactions.get_retained_earnings('7/16/2015', 2, 100);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_sales_by_offices.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_sales_by_offices(office_id integer, divide_by integer);

CREATE FUNCTION transactions.get_sales_by_offices(office_id integer, divide_by integer)
RETURNS TABLE
(
  office text,
  jan numeric,
  feb numeric,
  mar numeric,
  apr numeric,
  may numeric,
  jun numeric,
  jul numeric,
  aug numeric,
  sep numeric,
  oct numeric,
  nov numeric,
  "dec" numeric
)
AS
$$
BEGIN
        IF divide_by <= 0 THEN
                divide_by := 1;
        END IF;
        
        RETURN QUERY
        SELECT * FROM crosstab
        (
                '
                SELECT 
                office.get_office_code_by_id(office_id) AS office,
                date_part(''month'', value_date) AS month_id,
                SUM((price * quantity) - discount + tax)/' || divide_by::text || '::integer AS total
                FROM transactions.verified_stock_transaction_view
                WHERE book IN (''Sales.Direct'', ''Sales.Delivery'')
                AND office_id IN (SELECT * FROM office.get_office_ids(' || quote_literal($1::text) || '))
                GROUP BY office_id,
                date_part(''month'', value_date),
                date_trunc(''month'',value_date)
                ',
                'select m from generate_series(1,12) m'
        )as (
          office text,
          "Jan" numeric,
          "Feb" numeric,
          "Mar" numeric,
          "Apr" numeric,
          "May" numeric,
          "Jun" numeric,
          "Jul" numeric,
          "Aug" numeric,
          "Sep" numeric,
          "Oct" numeric,
          "Nov" numeric,
          "Dec" numeric
        ) ;

END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_sales_by_offices(divide_by integer);

CREATE FUNCTION transactions.get_sales_by_offices(divide_by integer)
RETURNS TABLE
(
  office text,
  jan numeric,
  feb numeric,
  mar numeric,
  apr numeric,
  may numeric,
  jun numeric,
  jul numeric,
  aug numeric,
  sep numeric,
  oct numeric,
  nov numeric,
  "dec" numeric
)
AS
$$
    DECLARE root_office_id integer = 0;
BEGIN
    SELECT office.offices.office_id INTO root_office_id
    FROM office.offices
    WHERE parent_office_id IS NULL
    LIMIT 1;

        IF divide_by <= 0 THEN
                divide_by := 1;
        END IF;
        
        RETURN QUERY
        SELECT * FROM transactions.get_sales_by_offices(root_office_id, divide_by);
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_sales_by_offices(1, 1);
--SELECT * FROM transactions.get_sales_by_offices(1000);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_sales_tax.sql --<--<--
DROP TYPE IF EXISTS transactions.sales_tax_type CASCADE;

CREATE TYPE transactions.sales_tax_type AS
(
    id                          integer,
    sales_tax_detail_id         integer,
    sales_tax_id                integer,
    sales_tax_detail_code       text,
    sales_tax_detail_name       text,
    is_use_tax                  boolean,
    account_id                  integer,
    price                       money_strict,
    quantity                    integer_strict,
    discount                    money_strict2,
    shipping_charge             money_strict2,
    taxable_amount              money_strict2,
    state_sales_tax_id          integer,
    county_sales_tax_id         integer,
    rate                        decimal_strict2,
    base_amount_type            text,
    rate_type                   text,
    rounding_type               text,
    rounding_places             integer,
    tax                         money_strict2
);

DROP FUNCTION IF EXISTS transactions.get_sales_tax
(
    _tran_book                  national character varying(12),
    _store_id                   integer,
    _party_code                 national character varying(12), 
    _shipping_address_code      national character varying(12),
    _price_type_id              integer,
    _item_code                  national character varying(12),
    _price                      money_strict2,
    _quantity                   integer_strict2,
    _discount                   money_strict2,
    _shipping_charge            money_strict2,
    _sales_tax_id               integer
);

CREATE FUNCTION transactions.get_sales_tax
(
    _tran_book                  national character varying(12),
    _store_id                   integer,
    _party_code                 national character varying(12), 
    _shipping_address_code      national character varying(12),
    _price_type_id              integer,
    _item_code                  national character varying(12),
    _price                      money_strict2,
    _quantity                   integer_strict2,
    _discount                   money_strict2,
    _shipping_charge            money_strict2,
    _sales_tax_id               integer
)
RETURNS SETOF transactions.sales_tax_type
AS
$$
    DECLARE _has_nexus                      boolean=false;
    DECLARE _party_id                       bigint;
    DECLARE _state_id                       integer;
    DECLARE _state_sales_tax_id             integer;
    DECLARE _state_sales_tax_rate           decimal_strict2;
    DECLARE _tax_base_amount_type_code      text;
    DECLARE _tax                            money_strict2=0;
    DECLARE _cumulative_tax                 money_strict2=0;
    DECLARE _taxable_amount                 money_strict2=0;
    DECLARE this                            RECORD;
BEGIN

    DROP TABLE IF EXISTS temp_sales_tax;
    
    CREATE TEMPORARY TABLE temp_sales_tax
    (
        id                          SERIAL,
        sales_tax_detail_id         integer,
        sales_tax_id                integer,
        sales_tax_detail_code       text,
        sales_tax_detail_name       text,
        is_use_tax                  boolean,
        account_id                  integer,
        price                       money_strict,
        quantity                    integer_strict,
        discount                    money_strict2,
        shipping_charge             money_strict2,
        taxable_amount              money_strict2,
        state_sales_tax_id          integer,
        county_sales_tax_id         integer,
        rate                        decimal_strict2,
        base_amount_type            text,
        rate_type                   text,
        rounding_type               text,
        rounding_places             integer,
        tax                         money_strict2
    ) ON COMMIT DROP;

    IF(COALESCE(_tran_book, '') = '') THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;

    IF(COALESCE(_store_id, 0) = 0) THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;

    IF(COALESCE(_party_code, '') = '') THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;
    
    IF(COALESCE(_price, 0) = 0) THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;
    
    IF(COALESCE(_quantity, 0) = 0) THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;
    
    IF(COALESCE(_sales_tax_id, 0) = 0) THEN
        RETURN QUERY SELECT * FROM temp_sales_tax;
    END IF;

    IF(TRIM(COALESCE(_shipping_address_code, '')) = '') THEN
        _has_nexus                  := false;        
    ELSE
        _state_id                   := core.get_state_id_by_shipping_address_code(_shipping_address_code, _party_id);
        _has_nexus                  := transactions.has_nexus(_state_id);
    END IF;

    IF(_has_nexus) THEN
        SELECT 
            state_sales_tax_id,
            rate
        INTO
            _state_sales_tax_id         
            _state_sales_tax_rate      
        FROM
        core.state_sales_taxes;

    END IF;

    IF(COALESCE(_state_sales_tax_id) = 0) THEN
        _has_nexus                  := false;
    END IF;


    SELECT tax_base_amount_type_code INTO _tax_base_amount_type_code
    FROM core.sales_taxes
    WHERE sales_tax_id=_sales_tax_id;
    


    INSERT INTO temp_sales_tax
    (
        sales_tax_detail_id, 
        sales_tax_id, 
        sales_tax_detail_code, 
        sales_tax_detail_name, 
        price, 
        quantity, 
        discount, 
        shipping_charge, 
        taxable_amount,
        is_use_tax,        
        account_id,
        state_sales_tax_id,
        county_sales_tax_id,
        rate,
        base_amount_type,
        rate_type,
        rounding_type,
        rounding_places,
        tax

    )
    SELECT 
        sales_tax_detail_id, 
        sales_tax_id, 
        sales_tax_detail_code, 
        sales_tax_detail_name,
        _price,
        _quantity,
        _discount,
        _shipping_charge,

        (_price * _quantity) 
        + 
        CASE 
            WHEN applied_on_shipping_charge 
            THEN _shipping_charge 
        ELSE 0 
        END
        - 
        _discount,
        CASE 
            WHEN state_sales_tax_id IS NOT NULL AND based_on_shipping_address AND check_nexus AND _has_nexus
            THEN true
            ELSE false
        END,
        CASE 
            WHEN based_on_shipping_address AND check_nexus AND _has_nexus AND use_tax_collecting_account_id IS NOT NULL
            THEN use_tax_collecting_account_id
            ELSE collecting_account_id
        END,
        CASE 
            WHEN based_on_shipping_address AND check_nexus AND _has_nexus
            THEN _state_sales_tax_id
            ELSE state_sales_tax_id
        END,
        county_sales_tax_id,
        CASE 
            WHEN state_sales_tax_id IS NOT NULL 
            THEN 
                CASE WHEN based_on_shipping_address AND check_nexus AND _has_nexus
                THEN _state_sales_tax_rate
                ELSE
                    core.get_state_sales_tax_rate(state_sales_tax_id)
                END
            WHEN county_sales_tax_id IS NOT NULL
            THEN 
                core.get_county_sales_tax_rate(county_sales_tax_id)
            ELSE
                rate
        END,
        _tax_base_amount_type_code,
        tax_rate_type_code,
        rounding_method_code,
        rounding_decimal_places,
        CASE WHEN state_sales_tax_id IS NULL AND county_sales_tax_id IS NULL AND tax_rate_type_code = 'F'
        THEN
            rate
        ELSE
            NULL
        END
    FROM core.sales_tax_details
    WHERE sales_tax_id=_sales_tax_id;


    IF(_tax_base_amount_type_code = 'L') THEN
        FOR this IN SELECT * FROM temp_sales_tax ORDER BY id
        LOOP
            _taxable_amount     := this.taxable_amount + _cumulative_tax;
            _tax                := 0;
            
            IF(this.rounding_type = 'R') THEN
                _tax            := ROUND((_taxable_amount * this.rate)/100, this.rounding_places);
            ELSIF(this.rounding_type = 'F') THEN
                _tax            := FLOOR((_taxable_amount * this.rate)/100);
            ELSIF(this.rounding_type = 'C') THEN
                _tax            := CEILING((_taxable_amount * this.rate)/100);
            END IF;

            _cumulative_tax     := _cumulative_tax + _tax;

            UPDATE temp_sales_tax SET 
            tax = _tax,
            taxable_amount = _taxable_amount
            WHERE id = this.id;
            
        END LOOP;
    ELSE
        UPDATE temp_sales_tax
        SET tax = 
        CASE WHEN rounding_type = 'R'
        THEN ROUND((taxable_amount * rate)/100, rounding_places)
        WHEN rounding_type = 'F'
        THEN FLOOR((taxable_amount * rate)/100)
        WHEN rounding_type = 'C'
        THEN CEILING((taxable_amount * rate)/100)
        END;
    END IF;


    
    RETURN QUERY SELECT * FROM temp_sales_tax;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_sales_tax('Sales', 1, 'JASMI-0002', 'None', 1, 'RMBP', 225000, 1, 0, 0, 3);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_sales_tax_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_sales_tax_id
(
    _tran_book                  national character varying(12),
    _store_id                   integer,
    _party_code                 national character varying(12),
    _shipping_address_code      national character varying(12),
    _price_type_id              integer,
    _item_code                  national character varying(12),
    _unit_id                    integer,
    _price                      money_strict
);

CREATE FUNCTION transactions.get_sales_tax_id
(
    _tran_book                  national character varying(12),
    _store_id                   integer,
    _party_code                 national character varying(12),
    _shipping_address_code      national character varying(12),
    _price_type_id              integer,
    _item_code                  national character varying(12),
    _unit_id                    integer,--todo
    _price                      money_strict
)
RETURNS integer
AS
$$
    DECLARE _item_id                    integer;
    DECLARE _party_id                   bigint;
    DECLARE _party_type_id              integer;
    DECLARE _value_date                 date;
    DECLARE _sales_tax_id               integer;
    DECLARE _item_group_id              integer;
    DECLARE _entity_id                  integer;
    DECLARE _industry_id                integer;
    DECLARE _office_id                  integer;
BEGIN
    IF(COALESCE(_tran_book, '') = '') THEN
        RETURN 0;
    END IF;

    IF(COALESCE(_store_id, 0) = 0) THEN
        RETURN 0;
    END IF;

    IF(COALESCE(_party_code, '') = '') THEN
        RETURN 0;
    END IF;

    IF(COALESCE(_price, 0) = 0 ) THEN
        RETURN 0;
    END IF;

    _office_id      := office.get_office_id_by_store_id(_store_id);
    _item_id        := core.get_item_id_by_item_code(_item_code);
    _party_id       := core.get_party_id_by_party_code(_party_code);
    _party_type_id  := core.get_party_type_id_by_party_id(_party_id);
    _value_date     := transactions.get_value_date(_office_id);
    _item_group_id  := core.get_item_group_id_by_item_id(_item_id);
    _entity_id      := core.get_entity_id_by_party_id(_party_id);
    _industry_id    := core.get_industry_id_by_party_id(_party_id);
       
    --Exempt by item
    SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
    FROM core.sales_tax_exempts
    INNER JOIN core.sales_tax_exempt_details
    ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
    WHERE (item_id = _item_id)
    AND store_id = _store_id
    AND price_from <= _price AND price_to >= _price
    AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

    IF(_sales_tax_id IS NOT NULL) THEN
        RETURN _sales_tax_id;
    END IF;

    --Exempt by item group
    SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
    FROM core.sales_tax_exempts
    INNER JOIN core.sales_tax_exempt_details
    ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
    WHERE (item_group_id = _item_group_id)
    AND store_id = _store_id
    AND price_from <= _price AND price_to >= _price
    AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

    IF(_sales_tax_id IS NOT NULL) THEN
        RETURN _sales_tax_id;
    END IF;

    --Exempt by party
    SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
    FROM core.sales_tax_exempts
    INNER JOIN core.sales_tax_exempt_details
    ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
    WHERE (party_id = _party_id)
    AND store_id = _store_id
    AND price_from <= _price AND price_to >= _price
    AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

    --Exempt by party type
    SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
    FROM core.sales_tax_exempts
    INNER JOIN core.sales_tax_exempt_details
    ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
    WHERE (party_type_id = _party_type_id)
    AND store_id = _store_id
    AND price_from <= _price AND price_to >= _price
    AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

    IF(_sales_tax_id IS NOT NULL) THEN
        RETURN _sales_tax_id;
    END IF;

    --Exempt by entity
    IF(_entity_id IS NOT NULL) THEN
        SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
        FROM core.sales_tax_exempts
        INNER JOIN core.sales_tax_exempt_details
        ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
        WHERE (entity_id = _entity_id)
        AND store_id = _store_id
        AND price_from <= _price AND price_to >= _price
        AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

        IF(_sales_tax_id IS NOT NULL) THEN
            RETURN _sales_tax_id;
        END IF;
    END IF;

    --Exempt by industry
    IF(_industry_id IS NOT NULL) THEN
        SELECT core.sales_tax_exempts.sales_tax_id INTO _sales_tax_id
        FROM core.sales_tax_exempts
        INNER JOIN core.sales_tax_exempt_details
        ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
        WHERE (industry_id = _industry_id)
        AND store_id = _store_id
        AND price_from <= _price AND price_to >= _price
        AND core.sales_tax_exempts.valid_from <= _value_date AND core.sales_tax_exempts.valid_till >= _value_date;

        IF(_sales_tax_id IS NOT NULL) THEN
            RETURN _sales_tax_id;
        END IF;
    END IF;
    

    --Get default tax from store
    SELECT sales_tax_id INTO _sales_tax_id FROM office.stores WHERE store_id=_store_id;    
    IF(_sales_tax_id IS NOT NULL) THEN
        RETURN _sales_tax_id;
    END IF;

    --Fallback to item sales tax

    RETURN
        sales_tax_id
    FROM
        core.items
    WHERE
        item_id=_item_id;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_sales_tax_id('Purchase', 1, 'JASMI-0002', '', 1, 'RMBP', 1, 30000);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_stock_account_statement.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_stock_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _item_id                integer,
    _store_id               integer
);

CREATE FUNCTION transactions.get_stock_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _item_id                integer,
    _store_id               integer
)
RETURNS TABLE
(
    id                      integer,
    value_date              date,
    tran_code               text,
    statement_reference     text,
    debit                   decimal(24, 4),
    credit                  decimal(24, 4),
    balance                 decimal(24, 4),
    book                    text,
    item_id                 integer,
    item_code               text,
    item_name               text,
    posted_on               TIMESTAMP WITH TIME ZONE,
    posted_by               text,
    approved_by             text,
    verification_status     integer,
    flag_bg                 text,
    flag_fg                 text
)
VOLATILE AS
$$
BEGIN

    DROP TABLE IF EXISTS temp_account_statement;
    CREATE TEMPORARY TABLE temp_account_statement
    (
        id                      SERIAL,
        value_date              date,
        tran_code               text,
        statement_reference     text,
        debit                   decimal(24, 4),
        credit                  decimal(24, 4),
        balance                 decimal(24, 4),
        book                    text,
        item_id                 integer,
        item_code               text,
        item_name               text,
        posted_on               TIMESTAMP WITH TIME ZONE,
        posted_by               text,
        approved_by             text,
        verification_status     integer,
        flag_bg                 text,
        flag_fg                 text
    ) ON COMMIT DROP;

    INSERT INTO temp_account_statement(value_date, statement_reference, debit, item_id)
    SELECT 
        _value_date_from, 
        'Opening Balance', 
        SUM
        (
            CASE transactions.stock_details.tran_type
            WHEN 'Dr' THEN base_quantity
            ELSE base_quantity * -1 
            END            
        ) as debit,
        _item_id
    FROM transactions.stock_details
    INNER JOIN transactions.stock_master
    ON transactions.stock_details.stock_master_id = transactions.stock_master.stock_master_id
    INNER JOIN transactions.transaction_master
    ON transactions.stock_master.transaction_master_id = transactions.transaction_master.transaction_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND 
        transactions.transaction_master.value_date < _value_date_from
    AND 
        transactions.stock_details.store_id = _store_id
    AND
        transactions.stock_details.item_id = _item_id;

    DELETE FROM temp_account_statement
    WHERE COALESCE(temp_account_statement.debit, 0) = 0
    AND COALESCE(temp_account_statement.credit, 0) = 0;

    UPDATE temp_account_statement SET 
    debit = temp_account_statement.credit * -1,
    credit = 0
    WHERE temp_account_statement.credit < 0;

    INSERT INTO temp_account_statement(value_date, tran_code, statement_reference, debit, credit, book, item_id, posted_on, posted_by, approved_by, verification_status)
    SELECT
        transactions.transaction_master.value_date,
        transactions.transaction_master.transaction_code,
        transactions.transaction_master.statement_reference,
        CASE transactions.stock_details.tran_type
        WHEN 'Dr' THEN base_quantity
        ELSE 0 END AS debit,
        CASE transactions.stock_details.tran_type
        WHEN 'Cr' THEN base_quantity
        ELSE 0 END AS credit,
        transactions.transaction_master.book,
        transactions.stock_details.item_id,
        transactions.transaction_master.transaction_ts AS posted_on,
        office.get_user_name_by_user_id(COALESCE(transactions.transaction_master.user_id, transactions.transaction_master.sys_user_id)),
        office.get_user_name_by_user_id(transactions.transaction_master.verified_by_user_id),
        transactions.transaction_master.verification_status_id
    FROM transactions.transaction_master
    INNER JOIN transactions.stock_master
    ON transactions.transaction_master.transaction_master_id = transactions.stock_master.transaction_master_Id
    INNER JOIN transactions.stock_details
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    WHERE
        transactions.transaction_master.verification_status_id > 0
    AND
        transactions.transaction_master.value_date >= _value_date_from
    AND
        transactions.transaction_master.value_date <= _value_date_to
    AND
       transactions.stock_details.store_id = _store_id 
    AND
       transactions.stock_details.item_id = _item_id
    ORDER BY 
        transactions.transaction_master.value_date,
        transactions.transaction_master.last_verified_on;
    
    UPDATE temp_account_statement
    SET balance = c.balance
    FROM
    (
        SELECT
            temp_account_statement.id, 
            SUM(COALESCE(c.debit, 0)) 
            - 
            SUM(COALESCE(c.credit,0)) As balance
        FROM temp_account_statement
        LEFT JOIN temp_account_statement AS c 
            ON (c.id <= temp_account_statement.id)
        GROUP BY temp_account_statement.id
        ORDER BY temp_account_statement.id
    ) AS c
    WHERE temp_account_statement.id = c.id;

    UPDATE temp_account_statement SET 
        item_code = core.items.item_code,
        item_name = core.items.item_name
    FROM core.items
    WHERE temp_account_statement.item_id = core.items.item_id;

    UPDATE temp_account_statement SET
        flag_bg = core.get_flag_background_color(core.get_flag_type_id(_user_id, 'account_statement', 'transaction_code', temp_account_statement.tran_code::text)),
        flag_fg = core.get_flag_foreground_color(core.get_flag_type_id(_user_id, 'account_statement', 'transaction_code', temp_account_statement.tran_code::text));

        
    RETURN QUERY
    SELECT * FROM temp_account_statement;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_stock_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _item_code              text,
    _store_id               integer
);

CREATE FUNCTION transactions.get_stock_account_statement
(
    _value_date_from        date,
    _value_date_to          date,
    _user_id                integer,
    _item_code              text,
    _store_id               integer
)
RETURNS TABLE
(
    id                      integer,
    value_date              date,
    tran_code               text,
    statement_reference     text,
    debit                   decimal(24, 4),
    credit                  decimal(24, 4),
    balance                 decimal(24, 4),
    book                    text,
    item_id                 integer,
    item_code               text,
    item_name               text,
    posted_on               TIMESTAMP WITH TIME ZONE,
    posted_by               text,
    approved_by             text,
    verification_status     integer,
    flag_bg                 text,
    flag_fg                 text
)
VOLATILE AS
$$
    DECLARE _item_id        integer;
BEGIN

    SELECT core.items.item_id INTO _item_id
    FROM core.items
    WHERE core.items.item_code = _item_code;

    RETURN QUERY
    SELECT * FROM transactions.get_stock_account_statement(_value_date_from, _value_date_to, _user_id, _item_id, _store_id);
END
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_stock_account_statement('1-1-2010', '1-1-2020', 2, 'RMBP', 1);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_top_selling_products_by_office.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_top_selling_products_by_office(_office_id integer, top integer);

CREATE FUNCTION transactions.get_top_selling_products_by_office(_office_id integer, top integer)
RETURNS TABLE
(
        id              integer,
        office_id       integer,
        office_code     text,
        office_name     text,
        item_id         integer,
        item_code       text,
        item_name       text,
        total_sales     numeric
)
AS
$$
BEGIN
        CREATE TEMPORARY TABLE top_selling_products
        (
                item_id integer
        ) ON COMMIT DROP;

        INSERT INTO top_selling_products
        SELECT t.item_id FROM transactions.get_top_selling_products_of_all_time(top) AS t;


        CREATE TEMPORARY TABLE top_selling_products_by_office
        (
                id              SERIAL,
                office_id       integer,
                office_code     text,
                office_name     text,
                item_id         integer,
                item_code       text,
                item_name       text,
                total_sales     numeric
        ) ON COMMIT DROP;


        INSERT INTO top_selling_products_by_office(office_id, item_id, total_sales)
        SELECT
                transactions.verified_stock_transaction_view.office_id,
                transactions.verified_stock_transaction_view.item_id, 
                SUM((price * quantity) - discount + tax) AS sales_amount
        FROM transactions.verified_stock_transaction_view
        WHERE transactions.verified_stock_transaction_view.item_id IN (SELECT top_selling_products.item_id FROM top_selling_products)
        AND transactions.verified_stock_transaction_view.office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        GROUP BY 
                transactions.verified_stock_transaction_view.office_id, 
                transactions.verified_stock_transaction_view.item_id
        ORDER BY sales_amount DESC, item_id ASC;


        UPDATE top_selling_products_by_office AS t
        SET 
                item_code = core.items.item_code,
                item_name = core.items.item_name
        FROM core.items
        WHERE t.item_id = core.items.item_id;


        UPDATE top_selling_products_by_office AS t
        SET 
                office_code = office.offices.office_code,
                office_name= office.offices.office_name
        FROM office.offices
        WHERE t.office_id = office.offices.office_id;


        RETURN QUERY 
        SELECT * FROM top_selling_products_by_office;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_top_selling_products_by_office();

CREATE FUNCTION transactions.get_top_selling_products_by_office()
RETURNS TABLE
(
        id              integer,
        office_id       integer,
        office_code     text,
        office_name     text,
        item_id         integer,
        item_code       text,
        item_name       text,
        total_sales     numeric
)
AS
$$
    DECLARE root_office_id integer = 0;
BEGIN
    SELECT office.offices.office_id INTO root_office_id
    FROM office.offices
    WHERE parent_office_id IS NULL
    LIMIT 1;

        RETURN QUERY 
        SELECT * FROM transactions.get_top_selling_products_by_office(root_office_id, 5);
END
$$
LANGUAGE plpgsql;


--SELECT  id, office_code, item_name, total_sales FROM transactions.get_top_selling_products_by_office()


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_top_selling_products_of_all_time.sql --<--<--

DROP FUNCTION IF EXISTS transactions.get_top_selling_products_of_all_time(top int);

CREATE FUNCTION transactions.get_top_selling_products_of_all_time(top int)
RETURNS TABLE
(
        id              integer,
        item_id         integer,
        item_code       text,
        item_name       text,
        total_sales     numeric
)
AS
$$
BEGIN
        CREATE TEMPORARY TABLE IF NOT EXISTS top_selling_products_of_all_time
        (
                id              integer,
                item_id         integer,
                item_code       text,
                item_name       text,
                total_sales     numeric
        ) ON COMMIT DROP;

        INSERT INTO top_selling_products_of_all_time(id, item_id, total_sales)
        SELECT ROW_NUMBER() OVER(), *
        FROM
        (
                SELECT         
                        transactions.verified_stock_transaction_view.item_id, 
                        SUM((price * quantity) - discount + tax) AS sales_amount
                FROM transactions.verified_stock_transaction_view
                GROUP BY transactions.verified_stock_transaction_view.item_id
                ORDER BY 2 DESC
                LIMIT $1
        ) t;

        UPDATE top_selling_products_of_all_time AS t
        SET 
                item_code = core.items.item_code,
                item_name = core.items.item_name
        FROM core.items
        WHERE t.item_id = core.items.item_id;
        

        RETURN QUERY
        SELECT * FROM top_selling_products_of_all_time;
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_top_selling_products_of_all_time();

CREATE FUNCTION transactions.get_top_selling_products_of_all_time()
RETURNS TABLE
(
        id              integer,
        item_id         integer,
        item_code       text,
        item_name       text,
        total_sales     numeric
)
AS
$$
BEGIN
        RETURN QUERY
        SELECT * FROM transactions.get_top_selling_products_of_all_time(5);
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_top_selling_products_of_all_time();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_total_due.sql --<--<--
CREATE FUNCTION transactions.get_total_due(office_id integer, party_id bigint)
RETURNS DECIMAL(24, 4)
AS
$$
    DECLARE _accrued_interest DECIMAL(24, 4)= transactions.get_accrued_interest($1, $2);
    DECLARE _account_id bigint= core.get_account_id_by_party_id($2);
    DECLARE _debit DECIMAL(24, 4) = 0;
    DECLARE _credit DECIMAL(24, 4) = 0;
    DECLARE _local_currency_code national character varying(12) = core.get_currency_code_by_office_id($1); 
    DECLARE _base_currency_code  national character varying(12) = core.get_currency_code_by_party_id($2);
    DECLARE _amount_in_local_currency DECIMAL(24, 4)= 0;
    DECLARE _amount_in_base_currency DECIMAL(24, 4)= 0;
    DECLARE _er decimal_strict2 = 0;
BEGIN

    SELECT SUM(amount_in_local_currency)
    INTO _debit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id IN (SELECT * FROM core.get_account_ids(_account_id))
    AND transactions.verified_transaction_view.office_id IN (SELECT * FROM office.get_office_ids($1))
    AND tran_type='Dr';

    SELECT SUM(amount_in_local_currency)
    INTO _credit
    FROM transactions.verified_transaction_view
    WHERE transactions.verified_transaction_view.account_id IN (SELECT * FROM core.get_account_ids(_account_id))
    AND transactions.verified_transaction_view.office_id IN (SELECT * FROM office.get_office_ids($1))
    AND tran_type='Cr';

    _er := COALESCE(transactions.get_exchange_rate($1, _local_currency_code, _base_currency_code), 0);

    IF(_er = 0) THEN
        RAISE EXCEPTION 'Exchange rate between % and % was not found.', _local_currency_code, _base_currency_code
        USING ERRCODE='P4010';
    END IF;


    _amount_in_local_currency = COALESCE(_credit, 0) - COALESCE(_debit, 0) - COALESCE(_accrued_interest, 0);


    _amount_in_base_currency = _amount_in_local_currency * _er; 

    RETURN _amount_in_base_currency;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_trial_balance.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_trial_balance
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _compact                        boolean,
    _factor                         decimal(24, 4),
    _change_side_when_negative      boolean,
    _include_zero_balance_accounts  boolean
);

CREATE FUNCTION transactions.get_trial_balance
(
    _date_from                      date,
    _date_to                        date,
    _user_id                        integer,
    _office_id                      integer,
    _compact                        boolean,
    _factor                         decimal(24, 4),
    _change_side_when_negative      boolean DEFAULT(true),
    _include_zero_balance_accounts  boolean DEFAULT(true)
)
RETURNS TABLE
(
    id                      integer,
    account_id              integer,
    account_number          text,
    account                 text,
    previous_debit          decimal(24, 4),
    previous_credit         decimal(24, 4),
    debit                   decimal(24, 4),
    credit                  decimal(24, 4),
    closing_debit           decimal(24, 4),
    closing_credit          decimal(24, 4)
)
AS
$$
BEGIN
    IF(_date_from = 'infinity') THEN
        RAISE EXCEPTION 'Invalid date.'
        USING ERRCODE='P3008';
    END IF;

    IF NOT EXISTS
    (
        SELECT 0 FROM office.offices
        WHERE office_id IN 
        (
            SELECT * FROM office.get_office_ids(1)
        )
        HAVING count(DISTINCT currency_code) = 1
   ) THEN
        RAISE EXCEPTION 'Cannot produce trial balance of office(s) having different base currencies.'
        USING ERRCODE='P8002';
   END IF;


    DROP TABLE IF EXISTS temp_trial_balance;
    CREATE TEMPORARY TABLE temp_trial_balance
    (
        id                      integer,
        account_id              integer,
        account_number          text,
        account                 text,
        previous_debit          decimal(24, 4),
        previous_credit         decimal(24, 4),
        debit                   decimal(24, 4),
        credit                  decimal(24, 4),
        closing_debit           decimal(24, 4),
        closing_credit          decimal(24, 4),
        root_account_id         integer,
        normally_debit          boolean
    ) ON COMMIT DROP;

    INSERT INTO temp_trial_balance(account_id, previous_debit, previous_credit)    
    SELECT 
        verified_transaction_mat_view.account_id, 
        SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
        SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
    FROM transactions.verified_transaction_mat_view
    WHERE value_date < _date_from
    AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
    GROUP BY verified_transaction_mat_view.account_id;

    IF(_date_to = 'infinity') THEN
        INSERT INTO temp_trial_balance(account_id, debit, credit)    
        SELECT 
            verified_transaction_mat_view.account_id, 
            SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
        FROM transactions.verified_transaction_mat_view
        WHERE value_date > _date_from
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        GROUP BY verified_transaction_mat_view.account_id;
    ELSE
        INSERT INTO temp_trial_balance(account_id, debit, credit)    
        SELECT 
            verified_transaction_mat_view.account_id, 
            SUM(CASE tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE 0 END),
            SUM(CASE tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE 0 END)        
        FROM transactions.verified_transaction_mat_view
        WHERE value_date >= _date_from AND value_date <= _date_to
        AND office_id IN (SELECT * FROM office.get_office_ids(_office_id))
        GROUP BY verified_transaction_mat_view.account_id;    
    END IF;

    UPDATE temp_trial_balance SET root_account_id = core.get_second_root_account_id(temp_trial_balance.account_id);


    DROP TABLE IF EXISTS temp_trial_balance2;
    
    IF(_compact) THEN
        CREATE TEMPORARY TABLE temp_trial_balance2
        ON COMMIT DROP
        AS
        SELECT
            temp_trial_balance.root_account_id AS account_id,
            ''::text as account_number,
            ''::text as account,
            SUM(temp_trial_balance.previous_debit) AS previous_debit,
            SUM(temp_trial_balance.previous_credit) AS previous_credit,
            SUM(temp_trial_balance.debit) AS debit,
            SUM(temp_trial_balance.credit) as credit,
            SUM(temp_trial_balance.closing_debit) AS closing_debit,
            SUM(temp_trial_balance.closing_credit) AS closing_credit,
            temp_trial_balance.normally_debit
        FROM temp_trial_balance
        GROUP BY 
            temp_trial_balance.root_account_id,
            temp_trial_balance.normally_debit
        ORDER BY temp_trial_balance.normally_debit;
    ELSE
        CREATE TEMPORARY TABLE temp_trial_balance2
        ON COMMIT DROP
        AS
        SELECT
            temp_trial_balance.account_id,
            ''::text as account_number,
            ''::text as account,
            SUM(temp_trial_balance.previous_debit) AS previous_debit,
            SUM(temp_trial_balance.previous_credit) AS previous_credit,
            SUM(temp_trial_balance.debit) AS debit,
            SUM(temp_trial_balance.credit) as credit,
            SUM(temp_trial_balance.closing_debit) AS closing_debit,
            SUM(temp_trial_balance.closing_credit) AS closing_credit,
            temp_trial_balance.normally_debit
        FROM temp_trial_balance
        GROUP BY 
            temp_trial_balance.account_id,
            temp_trial_balance.normally_debit
        ORDER BY temp_trial_balance.normally_debit;
    END IF;
    
    UPDATE temp_trial_balance2 SET
        account_number = core.accounts.account_number,
        account = core.accounts.account_name,
        normally_debit = core.account_masters.normally_debit
    FROM core.accounts
    INNER JOIN core.account_masters
    ON core.accounts.account_master_id = core.account_masters.account_master_id
    WHERE temp_trial_balance2.account_id = core.accounts.account_id;

    UPDATE temp_trial_balance2 SET 
        closing_debit = COALESCE(temp_trial_balance2.previous_debit, 0) + COALESCE(temp_trial_balance2.debit, 0),
        closing_credit = COALESCE(temp_trial_balance2.previous_credit, 0) + COALESCE(temp_trial_balance2.credit, 0);
        


     UPDATE temp_trial_balance2 SET previous_debit = COALESCE(temp_trial_balance2.previous_debit, 0) - COALESCE(temp_trial_balance2.previous_credit, 0), previous_credit = NULL WHERE normally_debit;
     UPDATE temp_trial_balance2 SET previous_credit = COALESCE(temp_trial_balance2.previous_credit, 0) - COALESCE(temp_trial_balance2.previous_debit, 0), previous_debit = NULL WHERE NOT normally_debit;
 
     UPDATE temp_trial_balance2 SET debit = COALESCE(temp_trial_balance2.debit, 0) - COALESCE(temp_trial_balance2.credit, 0), credit = NULL WHERE normally_debit;
     UPDATE temp_trial_balance2 SET credit = COALESCE(temp_trial_balance2.credit, 0) - COALESCE(temp_trial_balance2.debit, 0), debit = NULL WHERE NOT normally_debit;
 
     UPDATE temp_trial_balance2 SET closing_debit = COALESCE(temp_trial_balance2.closing_debit, 0) - COALESCE(temp_trial_balance2.closing_credit, 0), closing_credit = NULL WHERE normally_debit;
     UPDATE temp_trial_balance2 SET closing_credit = COALESCE(temp_trial_balance2.closing_credit, 0) - COALESCE(temp_trial_balance2.closing_debit, 0), closing_debit = NULL WHERE NOT normally_debit;


    IF(NOT _include_zero_balance_accounts) THEN
        DELETE FROM temp_trial_balance2 WHERE COALESCE(temp_trial_balance2.closing_debit) + COALESCE(temp_trial_balance2.closing_credit) = 0;
    END IF;
    
    IF(_factor > 0) THEN
        UPDATE temp_trial_balance2 SET previous_debit   = temp_trial_balance2.previous_debit/_factor;
        UPDATE temp_trial_balance2 SET previous_credit  = temp_trial_balance2.previous_credit/_factor;
        UPDATE temp_trial_balance2 SET debit            = temp_trial_balance2.debit/_factor;
        UPDATE temp_trial_balance2 SET credit           = temp_trial_balance2.credit/_factor;
        UPDATE temp_trial_balance2 SET closing_debit    = temp_trial_balance2.closing_debit/_factor;
        UPDATE temp_trial_balance2 SET closing_credit   = temp_trial_balance2.closing_credit/_factor;
    END IF;

    --Remove Zeros
    UPDATE temp_trial_balance2 SET previous_debit = NULL WHERE temp_trial_balance2.previous_debit = 0;
    UPDATE temp_trial_balance2 SET previous_credit = NULL WHERE temp_trial_balance2.previous_credit = 0;
    UPDATE temp_trial_balance2 SET debit = NULL WHERE temp_trial_balance2.debit = 0;
    UPDATE temp_trial_balance2 SET credit = NULL WHERE temp_trial_balance2.credit = 0;
    UPDATE temp_trial_balance2 SET closing_debit = NULL WHERE temp_trial_balance2.closing_debit = 0;
    UPDATE temp_trial_balance2 SET closing_debit = NULL WHERE temp_trial_balance2.closing_credit = 0;

    IF(_change_side_when_negative) THEN
        UPDATE temp_trial_balance2 SET previous_debit = temp_trial_balance2.previous_credit * -1, previous_credit = NULL WHERE temp_trial_balance2.previous_credit < 0;
        UPDATE temp_trial_balance2 SET previous_credit = temp_trial_balance2.previous_debit * -1, previous_debit = NULL WHERE temp_trial_balance2.previous_debit < 0;

        UPDATE temp_trial_balance2 SET debit = temp_trial_balance2.credit * -1, credit = NULL WHERE temp_trial_balance2.credit < 0;
        UPDATE temp_trial_balance2 SET credit = temp_trial_balance2.debit * -1, debit = NULL WHERE temp_trial_balance2.debit < 0;

        UPDATE temp_trial_balance2 SET closing_debit = temp_trial_balance2.closing_credit * -1, closing_credit = NULL WHERE temp_trial_balance2.closing_credit < 0;
        UPDATE temp_trial_balance2 SET closing_credit = temp_trial_balance2.closing_debit * -1, closing_debit = NULL WHERE temp_trial_balance2.closing_debit < 0;
    END IF;
    
    RETURN QUERY
    SELECT
        row_number() OVER(ORDER BY temp_trial_balance2.normally_debit DESC, temp_trial_balance2.account_id)::integer AS id,
        temp_trial_balance2.account_id,
        temp_trial_balance2.account_number,
        temp_trial_balance2.account,
        temp_trial_balance2.previous_debit,
        temp_trial_balance2.previous_credit,
        temp_trial_balance2.debit,
        temp_trial_balance2.credit,
        temp_trial_balance2.closing_debit,
        temp_trial_balance2.closing_credit
    FROM temp_trial_balance2;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.get_trial_balance('12-1-2014','12-31-2014',1,1, false, 1000, false, false);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_value_date.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_value_date(_office_id integer);

CREATE FUNCTION transactions.get_value_date(_office_id integer)
RETURNS date
AS
$$
    DECLARE this            RECORD;
    DECLARE _value_date     date=NOW();
BEGIN
    SELECT * FROM transactions.day_operation
    WHERE office_id = _office_id
    AND value_date =
    (
        SELECT MAX(value_date)
        FROM transactions.day_operation
        WHERE office_id = _office_id
    ) INTO this;

    IF(this.day_id IS NOT NULL) THEN
        IF(this.completed) THEN
            _value_date  := this.value_date + interval '1' day;
        ELSE
            _value_date  := this.value_date;    
        END IF;
    END IF;
    
    RETURN _value_date;
END
$$
LANGUAGE plpgsql;


--select transactions.get_value_date(2);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.get_write_off_cost_of_goods_sold.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_write_off_cost_of_goods_sold(_stock_master_id bigint, _item_id integer, _unit_id integer, _quantity integer);

CREATE FUNCTION transactions.get_write_off_cost_of_goods_sold(_stock_master_id bigint, _item_id integer, _unit_id integer, _quantity integer)
RETURNS money_strict2
AS
$$
    DECLARE _base_unit_id integer;
    DECLARE _factor decimal;
BEGIN
    _base_unit_id    = core.get_root_unit_id(_unit_id);
    _factor          = core.convert_unit(_unit_id, _base_unit_id);

    RAISE NOTICE 'Item Id ->%, Unit ID->%, Quantity->%', _item_id, _unit_id, _quantity;

    RETURN
        SUM((cost_of_goods_sold / base_quantity) * _factor * _quantity)     
         FROM transactions.stock_details        
    WHERE stock_master_id = _stock_master_id
    AND item_id = _item_id;    
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.get_write_off_cost_of_goods_sold(7, 3, 1, 1);



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.initialize_eod_operation.sql --<--<--
DROP FUNCTION IF EXISTS transactions.initialize_eod_operation(_user_id integer, _office_id integer, _value_date date);

CREATE FUNCTION transactions.initialize_eod_operation(_user_id integer, _office_id integer, _value_date date)
RETURNS void
AS
$$
    DECLARE this            RECORD;    
BEGIN
    IF(_value_date IS NULL) THEN
        RAISE EXCEPTION 'Invalid date.'
        USING ERRCODE='P3008';        
    END IF;

    IF(NOT policy.is_elevated_user(_user_id)) THEN
        RAISE EXCEPTION 'Access is denied.'
        USING ERRCODE='P9010';
    END IF;

    IF(_value_date != transactions.get_value_date(_office_id)) THEN
        RAISE EXCEPTION 'Invalid value date.'
        USING ERRCODE='P3007';
    END IF;

    SELECT * FROM transactions.day_operation
    WHERE value_date=_value_date 
    AND office_id = _office_id INTO this;

    IF(this IS NULL) THEN
        INSERT INTO transactions.day_operation(office_id, value_date, started_on, started_by)
        SELECT _office_id, _value_date, NOW(), _user_id;
    ELSE    
        RAISE EXCEPTION 'EOD operation was already initialized.'
        USING ERRCODE='P8101';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.is_eod_initialized.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_eod_initialized(_office_id integer, _value_date date);

CREATE FUNCTION transactions.is_eod_initialized(_office_id integer, _value_date date)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT * FROM transactions.day_operation
        WHERE office_id = _office_id
        AND value_date = _value_date
        AND completed = false
    ) then
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.list_closing_stock.sql --<--<--
DROP FUNCTION IF EXISTS transactions.list_closing_stock
(
    _store_id               integer
);

CREATE FUNCTION transactions.list_closing_stock
(
    _store_id               integer
)
RETURNS
TABLE
(
    item_id                 integer,
    item_code               text,
    item_name               text,
    unit_id                 integer,
    unit_name               text,
    quantity                integer
)
AS
$$
BEGIN
    DROP TABLE IF EXISTS temp_closing_stock;

    CREATE TEMPORARY TABLE temp_closing_stock
    (
        item_id             integer,
        item_code           text,
        item_name           text,
        unit_id             integer,
        unit_name           text,
        quantity            integer,
        maintain_stock      boolean
    ) ON COMMIT DROP;

    INSERT INTO temp_closing_stock(item_id, unit_id, quantity)
    SELECT 
        transactions.verified_stock_details_view.item_id, 
        transactions.verified_stock_details_view.base_unit_id,
        SUM(CASE WHEN transactions.verified_stock_details_view.tran_type='Dr' THEN transactions.verified_stock_details_view.base_quantity ELSE transactions.verified_stock_details_view.base_quantity * -1 END)
    FROM transactions.verified_stock_details_view
    WHERE transactions.verified_stock_details_view.store_id = _store_id
    GROUP BY transactions.verified_stock_details_view.item_id, transactions.verified_stock_details_view.store_id, transactions.verified_stock_details_view.base_unit_id;

    UPDATE temp_closing_stock SET 
        item_code = core.items.item_code,
        item_name = core.items.item_name,
        maintain_stock = core.items.maintain_stock
    FROM core.items
    WHERE temp_closing_stock.item_id = core.items.item_id;

    DELETE FROM temp_closing_stock WHERE NOT temp_closing_stock.maintain_stock;

    UPDATE temp_closing_stock SET 
        unit_name = core.units.unit_name
    FROM core.units
    WHERE temp_closing_stock.unit_id = core.units.unit_id;

    RETURN QUERY
    SELECT 
        temp_closing_stock.item_id, 
        temp_closing_stock.item_code, 
        temp_closing_stock.item_name, 
        temp_closing_stock.unit_id, 
        temp_closing_stock.unit_name, 
        temp_closing_stock.quantity
    FROM temp_closing_stock
    ORDER BY item_id;
END;
$$
LANGUAGE plpgsql;

COMMENT ON FUNCTION transactions.list_closing_stock(integer) 
IS 'Lists stock items, their respective base units, and closing stock quantity.';

--SELECT * FROM transactions.list_closing_stock(1);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.opening_inventory_exists.sql --<--<--
DROP FUNCTION IF EXISTS transactions.opening_inventory_exists
(
    _office_id          integer
);

CREATE FUNCTION transactions.opening_inventory_exists
(
    _office_id          integer
)
RETURNS boolean
STABLE
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 1
        FROM transactions.transaction_master
        WHERE book = 'Opening.Inventory'
        AND office_id = _office_id
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.perform_eod_operation.sql --<--<--
DROP FUNCTION IF EXISTS transactions.perform_eod_operation(_user_id integer, _office_id integer, _value_date date);

CREATE FUNCTION transactions.perform_eod_operation(_user_id integer, _office_id integer, _value_date date)
RETURNS boolean
AS
$$
    DECLARE _routine            regproc;
    DECLARE _routine_id         integer;
    DECLARE this                RECORD;
    DECLARE _sql                text;
    DECLARE _is_error           boolean=false;
    DECLARE _notice             text;
    DECLARE _office_code        text;
BEGIN
    IF(_value_date IS NULL) THEN
        RAISE EXCEPTION 'Invalid date.'
        USING ERRCODE='P3008';
    END IF;

    IF(NOT policy.is_elevated_user(_user_id)) THEN
        RAISE EXCEPTION 'Access is denied.'
        USING ERRCODE='P9001';
    END IF;

    IF(_value_date != transactions.get_value_date(_office_id)) THEN
        RAISE EXCEPTION 'Invalid value date.'
        USING ERRCODE='P3007';
    END IF;

    SELECT * FROM transactions.day_operation
    WHERE value_date=_value_date 
    AND office_id = _office_id INTO this;

    IF(this IS NULL) THEN
        RAISE EXCEPTION 'Invalid value date.'
        USING ERRCODE='P3007';
    ELSE    
        IF(this.completed OR this.completed_on IS NOT NULL) THEN
            RAISE WARNING 'EOD operation was already performed.';
            _is_error        := true;
        END IF;
    END IF;
    
    IF(NOT _is_error) THEN
        _office_code        := office.get_office_code_by_id(_office_id);
        _notice             := 'EOD started.'::text;
        RAISE INFO  '%', _notice;

        FOR this IN
        SELECT routine_id, routine_name 
        FROM transactions.routines 
        WHERE status 
        ORDER BY "order" ASC
        LOOP
            _routine_id             := this.routine_id;
            _routine                := this.routine_name;
            _sql                    := format('SELECT * FROM %1$s($1);', _routine);

            RAISE NOTICE '%', _sql;

            _notice             := 'Performing ' || _routine::text || '.';
            RAISE INFO '%', _notice;

            PERFORM pg_sleep(5);
            EXECUTE _sql USING _office_id;

            _notice             := 'Completed  ' || _routine::text || '.';
            RAISE INFO '%', _notice;
            
            PERFORM pg_sleep(5);            
        END LOOP;


        UPDATE transactions.day_operation SET 
            completed_on = NOW(), 
            completed_by = _user_id,
            completed = true
        WHERE value_date=_value_date
        AND office_id = _office_id;

        _notice             := 'EOD of ' || _office_code || ' for ' || _value_date::text || ' completed without errors.'::text;
        RAISE INFO '%', _notice;

        _notice             := 'OK'::text;
        RAISE INFO '%', _notice;

        RETURN true;
    END IF;

    RETURN false;    
END;
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.perform_eod_operation(_login_id bigint);

CREATE FUNCTION transactions.perform_eod_operation(_login_id bigint)
RETURNS boolean
AS
$$
    DECLARE _user_id    integer;
    DECLARE _office_id integer;
    DECLARE _value_date date;
BEGIN
    SELECT 
        user_id,
        office_id,
        transactions.get_value_date(office_id)
    INTO
        _user_id,
        _office_id,
        _value_date
    FROM audit.logins
    WHERE login_id=$1;

    RETURN transactions.perform_eod_operation(_user_id, _office_id, _value_date);
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_non_gl_transaction.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_non_gl_transaction
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _is_non_taxable_sales                   boolean,
    _salesperson_id                        integer,
    _shipper_id                             integer,
    _shipping_address_code                  national character varying(12),
    _store_id                               integer,
    _tran_ids                               bigint[],
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]

);


CREATE FUNCTION transactions.post_non_gl_transaction
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _is_non_taxable_sales                   boolean,
    _salesperson_id                        integer,
    _shipper_id                             integer,
    _shipping_address_code                  national character varying(12),
    _store_id                               integer,
    _tran_ids                               bigint[],
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]

)
RETURNS bigint
AS
$$
    DECLARE _party_id                       bigint;
    DECLARE _non_gl_stock_master_id         bigint;
    DECLARE _non_gl_stock_detail_id         bigint;
    DECLARE _shipping_address_id            bigint;
    DECLARE _shipping_charge                money_strict2;
    DECLARE _tran_type                      transaction_type;
    DECLARE this                            RECORD;
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    _party_id                               := core.get_party_id_by_party_code(_party_code);
    _shipping_address_id                    := core.get_shipping_address_id_by_shipping_address_code(_shipping_address_code, _party_id);

    DROP TABLE IF EXISTS temp_stock_details CASCADE;

    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        non_gl_stock_master_id          bigint, 
        tran_type                       transaction_type, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict,
        cost_of_goods_sold              money_strict2 DEFAULT(0),
        discount                        money_strict2,
        shipping_charge                 money_strict2,
        tax_form                        text,
        sales_tax_id                    integer,
        tax                             money_strict2
    ) ON COMMIT DROP;


    DROP TABLE IF EXISTS temp_stock_tax_details;
    
    CREATE TEMPORARY TABLE temp_stock_tax_details
    (
        id                                      SERIAL,
        temp_stock_detail_id                    integer REFERENCES temp_stock_details(id),
        sales_tax_detail_code                   text,
        stock_detail_id                         bigint,
        sales_tax_detail_id                     integer,
        state_sales_tax_id                      integer,
        county_sales_tax_id                     integer,
        account_id                              integer,
        principal                               money_strict,
        rate                                    decimal_strict,
        tax                                     money_strict
    ) ON COMMIT DROP;

    INSERT INTO temp_stock_details(store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax)
    SELECT store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax
    FROM explode_array(_details);

    UPDATE temp_stock_details 
    SET
        tran_type                   = _tran_type,
        sales_tax_id                = core.get_sales_tax_id_by_sales_tax_code(tax_form),
        item_id                     = core.get_item_id_by_item_code(item_code),
        unit_id                     = core.get_unit_id_by_unit_name(unit_name),
        base_quantity               = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                = core.get_base_unit_id_by_unit_name(unit_name);

    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    SELECT SUM(COALESCE(shipping_charge, 0))                    INTO _shipping_charge FROM temp_stock_details;

    IF(_is_non_taxable_sales) THEN
        IF EXISTS(SELECT * FROM temp_stock_details WHERE sales_tax_id IS NOT NULL LIMIT 1) THEN
            RAISE EXCEPTION 'You cannot provide sales tax information for non taxable sales.'
            USING ERRCODE='P5110';
        END IF;
    END IF;


    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        INSERT INTO temp_stock_tax_details
        (
            temp_stock_detail_id,
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            principal, 
            rate, 
            tax
        )
        SELECT 
            this.id, 
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            taxable_amount, 
            rate, 
            tax
        FROM transactions.get_sales_tax('Sales', _store_id, _party_code, _shipping_address_code, _price_type_id, this.item_code, this.price, this.quantity, this.discount, this.shipping_charge, this.sales_tax_id);
    END LOOP;

    UPDATE temp_stock_details
    SET tax =
    (SELECT SUM(COALESCE(temp_stock_tax_details.tax, 0)) FROM temp_stock_tax_details
    WHERE temp_stock_tax_details.temp_stock_detail_id = temp_stock_details.id);

    _non_gl_stock_master_id          := nextval(pg_get_serial_sequence('transactions.non_gl_stock_master', 'non_gl_stock_master_id'));

    UPDATE temp_stock_details SET non_gl_stock_master_id = _non_gl_stock_master_id;
    
    INSERT INTO transactions.non_gl_stock_master(non_gl_stock_master_id, value_date, book, party_id, price_type_id, login_id, user_id, office_id, reference_number, statement_reference, non_taxable, salesperson_id, shipper_id, shipping_address_id, shipping_charge, store_id) 
    SELECT _non_gl_stock_master_id, _value_date, _book_name, _party_id, _price_type_id, _login_id, _user_id, _office_id, _reference_number, _statement_reference, _is_non_taxable_sales, _salesperson_id, _shipper_id, _shipping_address_id, _shipping_charge, _store_id;


    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        _non_gl_stock_detail_id        := nextval(pg_get_serial_sequence('transactions.non_gl_stock_details', 'non_gl_stock_detail_id'));

        INSERT INTO transactions.non_gl_stock_details(non_gl_stock_detail_id, non_gl_stock_master_id, value_date, item_id, quantity, unit_id, base_quantity, base_unit_id, price, discount, shipping_charge, sales_tax_id, tax)    
        SELECT _non_gl_stock_detail_id, non_gl_stock_master_id, _value_date, item_id, quantity, unit_id, base_quantity, base_unit_id, price, discount, shipping_charge, sales_tax_id, COALESCE(this.tax, 0) 
        FROM temp_stock_details
        WHERE id = this.id;


        INSERT INTO transactions.non_gl_stock_tax_details(non_gl_stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax)
        SELECT _non_gl_stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax
        FROM temp_stock_tax_details
        WHERE temp_stock_detail_id = this.id;
        
    END LOOP;

    IF(array_length(_tran_ids, 1) > 0 AND _tran_ids != ARRAY[NULL::bigint]) THEN
        INSERT INTO transactions.non_gl_stock_master_relations(order_non_gl_stock_master_id, quotation_non_gl_stock_master_id)
        SELECT _non_gl_stock_master_id, explode_array(_tran_ids);
    END IF;

    IF(array_length(_attachments, 1) > 0 AND _attachments != ARRAY[NULL::core.attachment_type]) THEN
        INSERT INTO core.attachments(user_id, resource, resource_key, resource_id, original_file_name, file_extension, file_path, comment)
        SELECT _user_id, 'transactions.non_gl_stock_master', 'non_gl_stock_master_id', _non_gl_stock_master_id, original_file_name, file_extension, file_path, comment 
        FROM explode_array(_attachments);
    END IF;

    
    RETURN _non_gl_stock_master_id;
END;
$$
LANGUAGE plpgsql;

-- SELECT * FROM transactions.post_non_gl_transaction('Sales.Order', 2, 2, 5, '1-1-2020', '1', 'asdf', 'JASMI-0002', 1, false, 1, 1, '',  1, null::bigint[],
-- ARRAY[
--            ROW(1, 'RMBP', 1, 'Piece',180000, 0, 200, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--            ROW(1, '13MBA', 1, 'Dozen',130000, 300, 30, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--            ROW(1, '11MBA', 1, 'Piece',110000, 5000, 50, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type], 
-- ARRAY[NULL::core.attachment_type]);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_opening_inventory.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_opening_inventory
(
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _details                                transactions.opening_stock_type[]    
);

CREATE FUNCTION transactions.post_opening_inventory
(
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _details                                transactions.opening_stock_type[]    
)
RETURNS bigint
VOLATILE
AS
$$
    DECLARE _book_name                      text = 'Opening.Inventory';
    DECLARE _transaction_master_id          bigint;
    DECLARE _stock_master_id                bigint;
    DECLARE _tran_counter                   integer;
    DECLARE _transaction_code               text;
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    DROP TABLE IF EXISTS temp_stock_details;
    
    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        tran_type                       transaction_type,
        store_name                      text, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict
    ) ON COMMIT DROP;

    INSERT INTO temp_stock_details(store_name, item_code, quantity, unit_name, price)
    SELECT store_name, item_code, quantity, unit_name, amount
    FROM explode_array(_details);

    UPDATE temp_stock_details 
    SET
        tran_type                       = 'Dr',
        store_id                        = office.get_store_id_by_store_name(store_name),
        item_id                         = core.get_item_id_by_item_code(item_code),
        unit_id                         = core.get_unit_id_by_unit_name(unit_name),
        base_quantity                   = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                    = core.get_base_unit_id_by_unit_name(unit_name);

    IF EXISTS
    (
        SELECT * FROM temp_stock_details
        WHERE store_id IS NULL
        OR item_id IS NULL
        OR unit_id IS NULL
    ) THEN
        RAISE EXCEPTION 'Access is denied. Invalid values supplied.'
        USING ERRCODE='P9011';
    END IF;

    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    
    _transaction_master_id  := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id        := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));
    _tran_counter           := transactions.get_new_transaction_counter(_value_date);
    _transaction_code       := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);

    INSERT INTO transactions.transaction_master(transaction_master_id, transaction_counter, transaction_code, book, value_date, user_id, login_id, office_id, reference_number, statement_reference) 
    SELECT _transaction_master_id, _tran_counter, _transaction_code, _book_name, _value_date, _user_id, _login_id, _office_id, _reference_number, _statement_reference;

    INSERT INTO transactions.stock_master(value_date, stock_master_id, transaction_master_id)
    SELECT _value_date, _stock_master_id, _transaction_master_id;

    INSERT INTO transactions.stock_details(value_date, stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price)
    SELECT _value_date, _stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price
    FROM temp_stock_details;
    
    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);    
    RETURN _transaction_master_id;
END;
$$
LANGUAGE plpgsql;


-- SELECT * FROM transactions.post_opening_inventory
-- (
--     2,
--     2,
--     5,
--     transactions.get_value_date(2),
--     '3424',
--     'ASDF',
--     ARRAY[
--          ROW('Store 1', 'RMBP', 1, 'Box',180000)::transactions.opening_stock_type,
--          ROW('Store 1', '13MBA', 1, 'Dozen',130000)::transactions.opening_stock_type,
--          ROW('Store 1', '11MBA', 1, 'Piece',110000)::transactions.opening_stock_type]);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_purchase.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_purchase
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _cost_center_id                         integer,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _is_credit                              boolean,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _shipper_id                             integer,
    _store_id                               integer,
    _tran_ids                               bigint[],
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]
);


CREATE FUNCTION transactions.post_purchase
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _cost_center_id                         integer,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _is_credit                              boolean,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _shipper_id                             integer,
    _store_id                               integer,
    _tran_ids                               bigint[],
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _party_id                       bigint;
    DECLARE _transaction_master_id          bigint;
    DECLARE _stock_master_id                bigint;
    DECLARE _stock_detail_id                bigint;
    DECLARE _shipping_address_id            integer;
    DECLARE _grand_total                    money_strict;
    DECLARE _discount_total                 money_strict2;
    DECLARE _tax_total                      money_strict2;
    DECLARE _payable                        money_strict2;
    DECLARE _default_currency_code          national character varying(12);
    DECLARE _is_periodic                    boolean = office.is_periodic_inventory(_office_id);
    DECLARE _tran_counter                   integer;
    DECLARE _transaction_code               text;
    DECLARE _shipping_charge                money_strict2;
    DECLARE _tax                            RECORD;
    DECLARE _cash_repository_id             integer;
    DECLARE _cash_account_id                bigint;
    DECLARE _is_cash                        boolean;
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    _party_id                               := core.get_party_id_by_party_code(_party_code);
    _default_currency_code                  := transactions.get_default_currency_code_by_office_id(_office_id);
    _cash_account_id                        := core.get_cash_account_id_by_store_id(_store_id);
    _cash_repository_id                     := core.get_cash_repository_id_by_store_id(_store_id);
    _is_cash                                := core.is_cash_account_id(_cash_account_id);

    IF(NOT _is_cash) THEN
        _cash_repository_id                 := NULL;
    END IF;

    DROP TABLE IF EXISTS temp_stock_details CASCADE;
    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        stock_master_id                 bigint, 
        tran_type                       transaction_type, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict,
        cost_of_goods_sold              money_strict2,
        discount                        money_strict2,
        shipping_charge                 money_strict2,
        tax_form                        text,
        sales_tax_id                    integer,
        tax                             money_strict2,
        purchase_account_id             integer, 
        purchase_discount_account_id    integer, 
        inventory_account_id            integer
    ) ON COMMIT DROP;


    DROP TABLE IF EXISTS temp_stock_tax_details;
    CREATE TEMPORARY TABLE temp_stock_tax_details
    (
        id                                      SERIAL,
        temp_stock_detail_id                    integer REFERENCES temp_stock_details(id),
        sales_tax_detail_code                   text,
        stock_detail_id                         bigint,
        sales_tax_detail_id                     integer,
        state_sales_tax_id                      integer,
        county_sales_tax_id                     integer,
        account_id                              integer,
        principal                               money_strict,
        rate                                    decimal_strict,
        tax                                     money_strict
    ) ON COMMIT DROP;
    

    INSERT INTO temp_stock_details(store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax)
    SELECT store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax
    FROM explode_array(_details);

    UPDATE temp_stock_details 
    SET
        tran_type                       = 'Dr',
        sales_tax_id                    = core.get_sales_tax_id_by_sales_tax_code(tax_form),
        item_id                         = core.get_item_id_by_item_code(item_code),
        unit_id                         = core.get_unit_id_by_unit_name(unit_name),
        base_quantity                   = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                    = core.get_base_unit_id_by_unit_name(unit_name);

    UPDATE temp_stock_details
    SET
        purchase_account_id             = core.get_purchase_account_id(item_id),
        purchase_discount_account_id    = core.get_purchase_discount_account_id(item_id),
        inventory_account_id            = core.get_inventory_account_id(item_id);

    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    FOR _tax IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        INSERT INTO temp_stock_tax_details
        (
            temp_stock_detail_id,
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id,            
            principal, 
            rate, 
            tax
        )
        SELECT 
            _tax.id, 
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            taxable_amount, 
            rate, 
            tax
        FROM transactions.get_sales_tax('Sales', _store_id, _party_code, NULL, _price_type_id, _tax.item_code, _tax.price, _tax.quantity, _tax.discount, _tax.shipping_charge, _tax.sales_tax_id);
    END LOOP;

    UPDATE temp_stock_details
    SET tax =
    (SELECT SUM(COALESCE(temp_stock_tax_details.tax, 0)) FROM temp_stock_tax_details
    WHERE temp_stock_tax_details.temp_stock_detail_id = temp_stock_tax_details.id);

    SELECT SUM(COALESCE(tax,0))                                     INTO _tax_total FROM temp_stock_details;
    SELECT SUM(COALESCE(discount, 0))                               INTO _discount_total FROM temp_stock_details;
    SELECT SUM(COALESCE(price, 0) * COALESCE(quantity, 0))          INTO _grand_total FROM temp_stock_details;
    SELECT SUM(COALESCE(shipping_charge, 0))                        INTO _shipping_charge FROM temp_stock_details;

    _payable                                := _grand_total - COALESCE(_discount_total, 0) + COALESCE(_tax_total, 0) + COALESCE(_shipping_charge, 0);

    DROP TABLE IF EXISTS temp_transaction_details;
    CREATE TEMPORARY TABLE temp_transaction_details
    (
        transaction_master_id       BIGINT, 
        tran_type                   transaction_type, 
        account_id                  integer, 
        statement_reference         text, 
        cash_repository_id          integer, 
        currency_code               national character varying(12), 
        amount_in_currency          money_strict, 
        local_currency_code         national character varying(12), 
        er                          decimal_strict, 
        amount_in_local_currency    money_strict
    ) ON COMMIT DROP;


    IF(_is_periodic = true) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', purchase_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), 1, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
        FROM temp_stock_details
        GROUP BY purchase_account_id;
    ELSE
        --Perpetutal Inventory Accounting System
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', inventory_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), 1, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
        FROM temp_stock_details
        GROUP BY inventory_account_id;
    END IF;

    IF(_tax_total > 0) THEN
        FOR _tax IN 
        SELECT 
            format('P: %s x R: %s %% = %s (%s)', principal::text, rate::text, tax::text, sales_tax_detail_code) as statement_reference,
            account_id,
            tax
        FROM temp_stock_tax_details ORDER BY id
        LOOP    
            INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
            SELECT 'Dr', _tax.account_id, _tax.statement_reference || _statement_reference, _default_currency_code, _tax.tax, 1, _default_currency_code, _tax.tax;
        END LOOP;
    END IF;


    IF(_discount_total > 0) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', purchase_discount_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(discount, 0)), 1, _default_currency_code, SUM(COALESCE(discount, 0))
        FROM temp_stock_details
        GROUP BY purchase_discount_account_id;
    END IF;

    IF(_is_credit = true) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', core.get_account_id_by_party_id(_party_id), _statement_reference, _default_currency_code, _payable, 1, _default_currency_code, _payable;
    ELSE
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', _cash_account_id, _statement_reference, _cash_repository_id, _default_currency_code, _payable, 1, _default_currency_code, _payable;
    END IF;


    _transaction_master_id  := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id        := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));
    _tran_counter           := transactions.get_new_transaction_counter(_value_date);
    _transaction_code       := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);

    UPDATE temp_transaction_details     SET transaction_master_id   = _transaction_master_id;
    UPDATE temp_stock_details           SET stock_master_id         = _stock_master_id;
    
    INSERT INTO transactions.transaction_master(transaction_master_id, transaction_counter, transaction_code, book, value_date, user_id, login_id, office_id, cost_center_id, reference_number, statement_reference) 
    SELECT _transaction_master_id, _tran_counter, _transaction_code, _book_name, _value_date, _user_id, _login_id, _office_id, _cost_center_id, _reference_number, _statement_reference;


    INSERT INTO transactions.transaction_details(value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency)
    SELECT _value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency
    FROM temp_transaction_details
    ORDER BY tran_type DESC;


    INSERT INTO transactions.stock_master(value_date, stock_master_id, transaction_master_id, party_id, price_type_id, is_credit, shipper_id, shipping_charge, store_id, cash_repository_id)
    SELECT _value_date, _stock_master_id, _transaction_master_id, _party_id, _price_type_id, _is_credit, _shipper_id, _shipping_charge, _store_id, _cash_repository_id;
            
    FOR _tax IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        _stock_detail_id        := nextval(pg_get_serial_sequence('transactions.stock_details', 'stock_detail_id'));

        INSERT INTO transactions.stock_details(stock_detail_id, value_date, stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price, cost_of_goods_sold, discount, sales_tax_id, tax)
        SELECT _stock_detail_id, _value_date, _tax.stock_master_id, _tax.tran_type, _tax.store_id, _tax.item_id, _tax.quantity, _tax.unit_id, _tax.base_quantity, _tax.base_unit_id, _tax.price, COALESCE(_tax.cost_of_goods_sold, 0), _tax.discount, _tax.sales_tax_id, COALESCE(_tax.tax, 0)
        FROM temp_stock_details
        WHERE id = _tax.id;


        INSERT INTO transactions.stock_tax_details(stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax)
        SELECT _stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax
        FROM temp_stock_tax_details
        WHERE temp_stock_detail_id = _tax.id;
        
    END LOOP;


    IF(array_length(_tran_ids, 1) > 0 AND _tran_ids != ARRAY[NULL::bigint]) THEN
        INSERT INTO transactions.stock_master_non_gl_relations(stock_master_id, non_gl_stock_master_id)
        SELECT _stock_master_id, explode_array(_tran_ids);
    END IF;

    IF(array_length(_attachments, 1) > 0 AND _attachments != ARRAY[NULL::core.attachment_type]) THEN
        INSERT INTO core.attachments(user_id, resource, resource_key, resource_id, original_file_name, file_extension, file_path, comment)
        SELECT _user_id, 'transactions.transaction_master', 'transaction_master_id', _transaction_master_id, original_file_name, file_extension, file_path, comment 
        FROM explode_array(_attachments);
    END IF;
    
    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    RETURN _transaction_master_id;
END
$$
LANGUAGE plpgsql;


-- 
-- SELECT * FROM transactions.post_purchase('Purchase.Direct', 2, 2, 56, '2/2/2015', 1, '', '', false, 'JASMI-0002', NULL, NULL, 1, ARRAY[]::bigint[], 
--       ARRAY[
--                  ROW(1, 'RMBP', 1, 'Piece',180000, 0, 200, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--                  ROW(1, '13MBA', 1, 'Dozen',130000, 300, 30, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--                  ROW(1, '11MBA', 1, 'Piece',110000, 5000, 50, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type], 
--       ARRAY[NULL::core.attachment_type]);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_purchase_return.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_purchase_return
(
    _transaction_master_id          bigint,
    _office_id                      integer,
    _user_id                        integer,
    _login_id                       bigint,
    _value_date                     date,
    _store_id                       integer,
    _party_code                     national character varying(12),
    _price_type_id                  integer,
    _reference_number               national character varying(24),
    _statement_reference            text,
    _details                        transactions.stock_detail_type[],
    _attachments                    core.attachment_type[]
);

CREATE FUNCTION transactions.post_purchase_return
(
    _transaction_master_id          bigint,
    _office_id                      integer,
    _user_id                        integer,
    _login_id                       bigint,
    _value_date                     date,
    _store_id                       integer,
    _party_code                     national character varying(12),
    _price_type_id                  integer,
    _reference_number               national character varying(24),
    _statement_reference            text,
    _details                        transactions.stock_detail_type[],
    _attachments                    core.attachment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _party_id                       bigint;
    DECLARE _cost_center_id                 bigint;
    DECLARE _tran_master_id                 bigint;
    DECLARE _stock_detail_id                bigint;
    DECLARE _tran_counter                   integer;
    DECLARE _tran_code                      text;
    DECLARE _transaction_code               text;
    DECLARE _stock_master_id                bigint;
    DECLARE _grand_total                    money_strict;
    DECLARE _discount_total                 money_strict2;
    DECLARE _tax_total                      money_strict2;
    DECLARE _is_credit                      boolean;
    DECLARE _credit_account_id              bigint;
    DECLARE _default_currency_code          national character varying(12);
    DECLARE _sm_id                          bigint;
    DECLARE this                            RECORD;
    DECLARE _shipping_address_code          national character varying(12);
    DECLARE _is_periodic                    boolean = office.is_periodic_inventory(_office_id);
    DECLARE _book_name                      text='Purchase.Return';
    DECLARE _receivable                     money_strict;
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;
    
    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        stock_master_id                 bigint, 
        tran_type                       transaction_type, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict,
        discount                        money_strict2,
        shipping_charge                 money_strict2,
        tax_form                        text,
        sales_tax_id                    integer,
        tax                             money_strict2,
        purchase_account_id             integer, 
        purchase_discount_account_id    integer, 
        inventory_account_id            integer
    ) ON COMMIT DROP;

    CREATE TEMPORARY TABLE temp_stock_tax_details
    (
        id                                      SERIAL,
        temp_stock_detail_id                    integer REFERENCES temp_stock_details(id),
        sales_tax_detail_code                   text,
        stock_detail_id                         bigint,
        sales_tax_detail_id                     integer,
        state_sales_tax_id                      integer,
        county_sales_tax_id                     integer,
        account_id                              integer,
        principal                               money_strict,
        rate                                    decimal_strict,
        tax                                     money_strict
    ) ON COMMIT DROP;

    CREATE TEMPORARY TABLE temp_transaction_details
    (
        transaction_master_id       BIGINT, 
        tran_type                   transaction_type, 
        account_id                  integer, 
        statement_reference         text, 
        cash_repository_id          integer, 
        currency_code               national character varying(12), 
        amount_in_currency          money_strict, 
        local_currency_code         national character varying(12), 
        er                          decimal_strict, 
        amount_in_local_currency    money_strict
    ) ON COMMIT DROP;

    _party_id                       := core.get_party_id_by_party_code(_party_code);
    _default_currency_code          := transactions.get_default_currency_code_by_office_id(_office_id);
    
    SELECT 
        cost_center_id   
    INTO 
        _cost_center_id    
    FROM transactions.transaction_master 
    WHERE transactions.transaction_master.transaction_master_id = _transaction_master_id;

    SELECT 
        is_credit,
        core.get_shipping_address_code_by_shipping_address_id(shipping_address_id),
        stock_master_id
    INTO 
        _is_credit,
        _shipping_address_code,
        _sm_id
    FROM transactions.stock_master 
    WHERE transaction_master_id = _transaction_master_id;

    INSERT INTO temp_stock_details(store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax)
    SELECT store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax
    FROM explode_array(_details);

    UPDATE temp_stock_details 
    SET
        tran_type                   = 'Cr',
        sales_tax_id                = core.get_sales_tax_id_by_sales_tax_code(tax_form),
        item_id                     = core.get_item_id_by_item_code(item_code),
        unit_id                     = core.get_unit_id_by_unit_name(unit_name),
        base_quantity               = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                = core.get_base_unit_id_by_unit_name(unit_name);

    UPDATE temp_stock_details
    SET
        purchase_account_id             = core.get_purchase_account_id(item_id),
        purchase_discount_account_id    = core.get_purchase_discount_account_id(item_id),
        inventory_account_id            = core.get_inventory_account_id(item_id);

    IF EXISTS
    (

        SELECT * 
        FROM transactions.stock_details
        INNER JOIN temp_stock_details
        ON temp_stock_details.item_id = transactions.stock_details.item_id
        WHERE transactions.stock_details.stock_master_id = _sm_id
        AND COALESCE(temp_stock_details.sales_tax_id, 0) != COALESCE(transactions.stock_details.sales_tax_id, 0)
        LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Tax form mismatch.'
        USING ERRCODE='P3202';
    END IF;

    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        INSERT INTO temp_stock_tax_details
        (
            temp_stock_detail_id,
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            principal, 
            rate, 
            tax
        )
        SELECT 
            this.id, 
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            taxable_amount, 
            rate, 
            tax
        FROM transactions.get_sales_tax('Purchase', _store_id, _party_code, _shipping_address_code, _price_type_id, this.item_code, this.price, this.quantity, this.discount, this.shipping_charge, this.sales_tax_id);
    END LOOP;
    
    UPDATE temp_stock_details
    SET tax =
    (SELECT SUM(COALESCE(temp_stock_tax_details.tax, 0)) FROM temp_stock_tax_details
    WHERE temp_stock_tax_details.temp_stock_detail_id = temp_stock_details.id);

    _credit_account_id = core.get_account_id_by_party_code(_party_code); 

    _tran_master_id             := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id            := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));
    _tran_counter               := transactions.get_new_transaction_counter(_value_date);
    _tran_code                  := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);
        
    SELECT SUM(COALESCE(tax, 0))                                INTO _tax_total FROM temp_stock_tax_details;
    SELECT SUM(COALESCE(discount, 0))                           INTO _discount_total FROM temp_stock_details;
    SELECT SUM(COALESCE(price, 0) * COALESCE(quantity, 0))      INTO _grand_total FROM temp_stock_details;

    _receivable := _grand_total - COALESCE(_discount_total, 0) + COALESCE(_tax_total, 0);


    IF(_is_periodic = true) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', purchase_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), 1, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
        FROM temp_stock_details
        GROUP BY purchase_account_id;
    ELSE
        --Perpetutal Inventory Accounting System
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', inventory_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), 1, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
        FROM temp_stock_details
        GROUP BY inventory_account_id;
    END IF;


    IF(_tax_total IS NOT NULL AND _tax_total > 0) THEN
        FOR this IN 
        SELECT 
            format('P: %s x R: %s %% = %s (%s)', principal::text, rate::text, tax::text, sales_tax_detail_code) as statement_reference,
            account_id,
            tax
        FROM temp_stock_tax_details ORDER BY id
        LOOP    
            INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
            SELECT 'Cr', this.account_id, this.statement_reference || _statement_reference, _default_currency_code, this.tax, 1, _default_currency_code, this.tax;
        END LOOP;
    END IF;

    IF(_discount_total IS NOT NULL AND _discount_total > 0) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', purchase_discount_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(discount, 0)), 1, _default_currency_code, SUM(COALESCE(discount, 0))
        FROM temp_stock_details
        GROUP BY purchase_discount_account_id;
    END IF;

    INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
    SELECT 'Dr', core.get_account_id_by_party_id(_party_id), _statement_reference, _default_currency_code, _receivable, 1, _default_currency_code, _receivable;


    _transaction_master_id  := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id        := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));
    _tran_counter           := transactions.get_new_transaction_counter(_value_date);
    _transaction_code       := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);

    UPDATE temp_transaction_details     SET transaction_master_id   = _transaction_master_id;
    UPDATE temp_stock_details           SET stock_master_id         = _stock_master_id;

    INSERT INTO transactions.transaction_master(transaction_master_id, transaction_counter, transaction_code, book, value_date, user_id, login_id, office_id, cost_center_id, reference_number, statement_reference) 
    SELECT _transaction_master_id, _tran_counter, _transaction_code, _book_name, _value_date, _user_id, _login_id, _office_id, _cost_center_id, _reference_number, _statement_reference;


    INSERT INTO transactions.transaction_details(value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency)
    SELECT _value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency
    FROM temp_transaction_details
    ORDER BY tran_type DESC;


    INSERT INTO transactions.stock_master(value_date, stock_master_id, transaction_master_id, party_id, price_type_id, is_credit, shipper_id, shipping_charge, store_id, cash_repository_id)
    SELECT _value_date, _stock_master_id, _transaction_master_id, _party_id, _price_type_id, _is_credit, NULL, 0, _store_id, NULL;
            
    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        _stock_detail_id        := nextval(pg_get_serial_sequence('transactions.stock_details', 'stock_detail_id'));

        INSERT INTO transactions.stock_details(stock_detail_id, value_date, stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price, discount, sales_tax_id, tax)
        SELECT _stock_detail_id, _value_date, this.stock_master_id, this.tran_type, this.store_id, this.item_id, this.quantity, this.unit_id, this.base_quantity, this.base_unit_id, this.price, this.discount, this.sales_tax_id, COALESCE(this.tax, 0)
        FROM temp_stock_details
        WHERE id = this.id;


        INSERT INTO transactions.stock_tax_details(stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax)
        SELECT _stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax
        FROM temp_stock_tax_details
        WHERE temp_stock_detail_id = this.id;
        
    END LOOP;

    IF(array_length(_attachments, 1) > 0 AND _attachments != ARRAY[NULL::core.attachment_type]) THEN
        INSERT INTO core.attachments(user_id, resource, resource_key, resource_id, original_file_name, file_extension, file_path, comment)
        SELECT _user_id, 'transactions.transaction_master', 'transaction_master_id', _transaction_master_id, original_file_name, file_extension, file_path, comment 
        FROM explode_array(_attachments);
    END IF;
    
    RETURN _transaction_master_id;
    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    RETURN _tran_master_id;
END
$$
LANGUAGE plpgsql;




-- CREATE TEMPORARY TABLE temp_purchase_return
-- ON COMMIT DROP
-- AS
-- 
-- SELECT * FROM transactions.post_purchase_return(5, 2, 2, 1, '1-1-2000', 1, 'MAJON-0002', 1, '1234-AD', 'Test', 
-- ARRAY[
--  ROW(1, 'RMBP', 1, 'Piece', 180000, 0, 200, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--  ROW(1, '13MBA', 1, 'Piece', 110000, 5000, 50, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type
-- ],
-- ARRAY[
-- NULL::core.attachment_type
-- ]);
-- 
-- SELECT  tran_type, core.get_account_name_by_account_id(account_id), amount_in_local_currency 
-- FROM transactions.transaction_details
-- WHERE transaction_master_id  = (SELECT * FROM temp_purchase_return);


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_purhcase_reorder.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_purhcase_reorder
(
    _value_date                             date,
    _login_id                               bigint,
    _user_id                                integer,
    _office_id                              integer,
    _details                                transactions.purchase_reorder_type[]
);

CREATE FUNCTION transactions.post_purhcase_reorder
(
    _value_date                             date,
    _login_id                               bigint,
    _user_id                                integer,
    _office_id                              integer,
    _details                                transactions.purchase_reorder_type[]
)
RETURNS bool
AS
$$
    DECLARE this                                RECORD;
    DECLARE detail                              transactions.stock_detail_type[];
BEGIN
        
        CREATE TEMPORARY TABLE _temp_transaction(supplier_code national character varying(12))  ON COMMIT DROP;

        INSERT INTO _temp_transaction(supplier_code)
        SELECT DISTINCT supplier_code FROM explode_array(_details);

        FOR this IN SELECT supplier_code FROM _temp_transaction
        LOOP
            detail := 
                    (
                        SELECT 
                            array_agg
                            (
                                (
                                    NULL,--store_id
                                    core.get_item_code_by_item_id(details.item_id),
                                    details.order_quantity,
                                    core.get_unit_name_by_unit_id(details.unit_id),
                                    details.price,
                                    0, --discount
                                    0, --shipping_charge
                                    details.tax_code,
                                    NULL --tax (will be automatically caculated)
                               )::transactions.stock_detail_type
                           )
                        FROM explode_array(_details) as details
                        WHERE details.supplier_code = this.supplier_code
                    )::transactions.stock_detail_type[];

            
            PERFORM transactions.post_non_gl_transaction(
                'Purchase.Order', 
                _office_id,
                _user_id,
                _login_id,
                _value_date,
                '',
                'Automatically generated order.',
                this.supplier_code,
                NULL,
                false,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                detail,
                NULL

            );

        END LOOP;

        RETURN true;
END
$$
LANGUAGE plpgsql;


-- SELECT * FROM transactions.post_purhcase_reorder('1-1-2000', 1, 2, 2,
-- ARRAY[
-- ROW(1, 'ETBRO-0002', 1, 40000, 'MoF-NP-KTM-VAT', 10)::transactions.purchase_reorder_type,
-- ROW(1, 'ETBRO-0002', 1, 40000, '', 10)::transactions.purchase_reorder_type
-- ]);
-- 



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_receipt_function.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_receipt_function
(
    _user_id                                integer, 
    _office_id                              integer, 
    _login_id                               bigint,
    _party_code                             national character varying(12), 
    _currency_code                          national character varying(12), 
    _amount                                 money_strict, 
    _exchange_rate_debit                    decimal_strict, 
    _exchange_rate_credit                   decimal_strict,
    _reference_number                       national character varying(24), 
    _statement_reference                    national character varying(128), 
    _cost_center_id                         integer,
    _cash_repository_id                     integer,
    _posted_date                            date,
    _bank_account_id                        integer,
    _bank_instrument_code                   national character varying(128),
    _bank_tran_code                         national character varying(128)
);

CREATE FUNCTION transactions.post_receipt_function
(
    _user_id                                integer, 
    _office_id                              integer, 
    _login_id                               bigint,
    _party_code                             national character varying(12), 
    _currency_code                          national character varying(12), 
    _amount                                 money_strict, 
    _exchange_rate_debit                    decimal_strict, 
    _exchange_rate_credit                   decimal_strict,
    _reference_number                       national character varying(24), 
    _statement_reference                    national character varying(128), 
    _cost_center_id                         integer,
    _cash_repository_id                     integer,
    _posted_date                            date,
    _bank_account_id                        integer,
    _bank_instrument_code                   national character varying(128),
    _bank_tran_code                         national character varying(128)
)
RETURNS bigint
AS
$$
    DECLARE _value_date                     date;
    DECLARE _book                           text;
    DECLARE _transaction_master_id          bigint;
    DECLARE _base_currency_code             national character varying(12);
    DECLARE _local_currency_code            national character varying(12);
    DECLARE _party_id                       bigint;
    DECLARE _party_account_id               bigint;
    DECLARE _debit                          money_strict2;
    DECLARE _credit                         money_strict2;
    DECLARE _lc_debit                       money_strict2;
    DECLARE _lc_credit                      money_strict2;
    DECLARE _is_cash                        boolean;
    DECLARE _cash_account_id                bigint;
BEGIN
    _value_date                             := transactions.get_value_date(_office_id);

    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book, _value_date) = false) THEN
        RETURN 0;
    END IF;

    IF(_cash_repository_id > 0) THEN
        IF(_posted_Date IS NOT NULL OR _bank_account_id IS NOT NULL OR COALESCE(_bank_instrument_code, '') != '' OR COALESCE(_bank_tran_code, '') != '') THEN
            RAISE EXCEPTION 'Invalid bank transaction information provided.'
            USING ERRCODE='P5111';
        END IF;
        _is_cash                            := true;
    END IF;

    _book                                   := 'Sales.Receipt';
    
    _party_id                               := core.get_party_id_by_party_code(_party_code);
    _party_account_id                       := core.get_account_id_by_party_id(_party_id);
    _cash_account_id                        := core.get_cash_account_id();
    
    _local_currency_code                    := core.get_currency_code_by_office_id(_office_id);
    _base_currency_code                     := core.get_currency_code_by_party_id(_party_id);

    _debit                                  := _amount;
    _lc_debit                               := _amount * _exchange_rate_debit;

    _credit                                 := _amount * (_exchange_rate_debit/ _exchange_rate_credit);
    _lc_credit                              := _amount * _exchange_rate_debit;
    

    INSERT INTO transactions.transaction_master
    (
        transaction_master_id, 
        transaction_counter, 
        transaction_code, 
        book, 
        value_date, 
        user_id, 
        login_id, 
        office_id, 
        cost_center_id, 
        reference_number, 
        statement_reference
    )
    SELECT 
        nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id')), 
        transactions.get_new_transaction_counter(_value_date), 
        transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id),
        _book,
        _value_date,
        _user_id,
        _login_id,
        _office_id,
        _cost_center_id,
        _reference_number,
        _statement_reference;


    _transaction_master_id := currval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));

    --Debit
    IF(_is_cash) THEN
            INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency, audit_user_id)
            SELECT _transaction_master_id, _value_date, 'Dr', _cash_account_id, _statement_reference, _cash_repository_id, _currency_code, _debit, _local_currency_code, _exchange_rate_debit, _lc_debit, _user_id;
    ELSE
            INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency, audit_user_id)
            SELECT _transaction_master_id, _value_date, 'Dr', _bank_account_id, _statement_reference, NULL, _currency_code, _debit, _local_currency_code, _exchange_rate_debit, _lc_debit, _user_id;        
    END IF;

    --Credit
    INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency, audit_user_id)
    SELECT _transaction_master_id, _value_date, 'Cr', _party_account_id, _statement_reference, NULL, _base_currency_code, _credit, _local_currency_code, _exchange_rate_credit, _lc_credit, _user_id;        
    
    
    INSERT INTO transactions.customer_receipts(transaction_master_id, party_id, currency_code, amount, er_debit, er_credit, cash_repository_id, posted_date, bank_account_id, bank_instrument_code, bank_tran_code)
    SELECT _transaction_master_id, _party_id, _currency_code, _amount,  _exchange_rate_debit, _exchange_rate_credit, _cash_repository_id, _posted_date, _bank_account_id, _bank_instrument_code, _bank_tran_code;

    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    ------------TODO-----------------
    RETURN _transaction_master_id;
END
$$
LANGUAGE plpgsql;



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_sales.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_sales
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _cost_center_id                         integer,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _is_credit                              boolean,
    _payment_term_id                        integer,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _salesperson_id                         integer,
    _shipper_id                             integer,
    _shipping_address_code                  national character varying(12),
    _store_id                               integer,
    _is_non_taxable_sales                   boolean,
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]
);

CREATE FUNCTION transactions.post_sales
(
    _book_name                              national character varying(12),
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _cost_center_id                         integer,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _is_credit                              boolean,
    _payment_term_id                        integer,
    _party_code                             national character varying(12),
    _price_type_id                          integer,
    _salesperson_id                         integer,
    _shipper_id                             integer,
    _shipping_address_code                  national character varying(12),
    _store_id                               integer,
    _is_non_taxable_sales                   boolean,
    _details                                transactions.stock_detail_type[],
    _attachments                            core.attachment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _party_id                       bigint;
    DECLARE _transaction_master_id          bigint;
    DECLARE _stock_master_id                bigint;
    DECLARE _stock_detail_id                bigint;
    DECLARE _shipping_address_id            integer;
    DECLARE _grand_total                    money_strict;
    DECLARE _discount_total                 money_strict2;
    DECLARE _tax_total                      money_strict2;
    DECLARE _receivable                     money_strict2;
    DECLARE _default_currency_code          national character varying(12);
    DECLARE _is_periodic                    boolean = office.is_periodic_inventory(_office_id);
    DECLARE _cost_of_goods                  money_strict;
    DECLARE _tran_counter                   integer;
    DECLARE _transaction_code               text;
    DECLARE _shipping_charge                money_strict2;
    DECLARE this                            RECORD;
    DECLARE _cash_repository_id             integer;
    DECLARE _cash_account_id                bigint;
    DECLARE _is_cash                        boolean;
BEGIN        
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    _party_id                               := core.get_party_id_by_party_code(_party_code);
    _default_currency_code                  := transactions.get_default_currency_code_by_office_id(_office_id);
    _cash_account_id                        := core.get_cash_account_id_by_store_id(_store_id);
    _cash_repository_id                     := core.get_cash_repository_id_by_store_id(_store_id);
    _is_cash                                := core.is_cash_account_id(_cash_account_id);

    IF(NOT _is_cash) THEN
        _cash_repository_id                 := NULL;
    END IF;

    DROP TABLE IF EXISTS temp_stock_details CASCADE;
    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        stock_master_id                 bigint, 
        tran_type                       transaction_type, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict,
        cost_of_goods_sold              money_strict2 DEFAULT(0),
        discount                        money_strict2,
        shipping_charge                 money_strict2,
        tax_form                        text,
        sales_tax_id                    integer,
        tax                             money_strict2,
        sales_account_id                integer,
        sales_discount_account_id       integer,
        inventory_account_id            integer,
        cost_of_goods_sold_account_id   integer
    ) ON COMMIT DROP;


    DROP TABLE IF EXISTS temp_stock_tax_details;
    CREATE TEMPORARY TABLE temp_stock_tax_details
    (
        id                                      SERIAL,
        temp_stock_detail_id                    integer REFERENCES temp_stock_details(id),
        sales_tax_detail_code                   text,
        stock_detail_id                         bigint,
        sales_tax_detail_id                     integer,
        state_sales_tax_id                      integer,
        county_sales_tax_id                     integer,
        account_id                              integer,
        principal                               money_strict,
        rate                                    decimal_strict,
        tax                                     money_strict
    ) ON COMMIT DROP;
    


    INSERT INTO temp_stock_details(store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax)
    SELECT store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax
    FROM explode_array(_details);


    UPDATE temp_stock_details 
    SET
        tran_type                       = 'Cr',
        sales_tax_id                    = core.get_sales_tax_id_by_sales_tax_code(tax_form),
        item_id                         = core.get_item_id_by_item_code(item_code),
        unit_id                         = core.get_unit_id_by_unit_name(unit_name),
        base_quantity                   = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                    = core.get_base_unit_id_by_unit_name(unit_name);

    UPDATE temp_stock_details
    SET
        sales_account_id                = core.get_sales_account_id(item_id),
        sales_discount_account_id       = core.get_sales_discount_account_id(item_id),
        inventory_account_id            = core.get_inventory_account_id(item_id),
        cost_of_goods_sold_account_id   = core.get_cost_of_goods_sold_account_id(item_id);
            
    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    IF(_is_non_taxable_sales) THEN
        IF EXISTS(SELECT * FROM temp_stock_details WHERE sales_tax_id IS NOT NULL LIMIT 1) THEN
            RAISE EXCEPTION 'You cannot provide sales tax information for non taxable sales.'
            USING ERRCODE='P5110';
        END IF;
    END IF;

    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        INSERT INTO temp_stock_tax_details
        (
            temp_stock_detail_id,
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            principal, 
            rate, 
            tax
        )
        SELECT 
            this.id, 
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            taxable_amount, 
            rate, 
            tax
        FROM transactions.get_sales_tax('Sales', _store_id, _party_code, _shipping_address_code, _price_type_id, this.item_code, this.price, this.quantity, this.discount, this.shipping_charge, this.sales_tax_id);
    END LOOP;

    UPDATE temp_stock_details
    SET tax =
    (SELECT SUM(COALESCE(temp_stock_tax_details.tax, 0)) FROM temp_stock_tax_details
    WHERE temp_stock_tax_details.temp_stock_detail_id = temp_stock_details.id);


    SELECT SUM(COALESCE(tax, 0))                                INTO _tax_total FROM temp_stock_tax_details;
    SELECT SUM(COALESCE(discount, 0))                           INTO _discount_total FROM temp_stock_details;
    SELECT SUM(COALESCE(price, 0) * COALESCE(quantity, 0))      INTO _grand_total FROM temp_stock_details;
    SELECT SUM(COALESCE(shipping_charge, 0))                    INTO _shipping_charge FROM temp_stock_details;
    
     _receivable                    := _grand_total - COALESCE(_discount_total, 0) + COALESCE(_tax_total, 0) + COALESCE(_shipping_charge, 0);
    
    DROP TABLE IF EXISTS temp_transaction_details;
    CREATE TEMPORARY TABLE temp_transaction_details
    (
        transaction_master_id       BIGINT, 
        tran_type                   transaction_type, 
        account_id                  integer, 
        statement_reference         text, 
        cash_repository_id          integer, 
        currency_code               national character varying(12), 
        amount_in_currency          money_strict, 
        local_currency_code         national character varying(12), 
        er                          decimal_strict, 
        amount_in_local_currency    money_strict
    ) ON COMMIT DROP;


    INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
    SELECT 'Cr', sales_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), 1, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
    FROM temp_stock_details
    GROUP BY sales_account_id;

    IF(_is_periodic = false) THEN
        --Perpetutal Inventory Accounting System

        UPDATE temp_stock_details SET cost_of_goods_sold = transactions.get_cost_of_goods_sold(item_id, unit_id, store_id, quantity);
        
        SELECT SUM(cost_of_goods_sold) INTO _cost_of_goods
        FROM temp_stock_details;

        IF(_cost_of_goods > 0) THEN
            INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
            SELECT 'Dr', cost_of_goods_sold_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
            FROM temp_stock_details
            GROUP BY cost_of_goods_sold_account_id;

            INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
            SELECT 'Cr', inventory_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
            FROM temp_stock_details
            GROUP BY inventory_account_id;
        END IF;
    END IF;

    IF(_tax_total > 0) THEN
        FOR this IN 
        SELECT 
            format('P: %s x R: %s %% = %s (%s)/', SUM(principal)::text, rate::text, SUM(tax)::text, sales_tax_detail_code) as statement_reference,
            account_id,
            SUM(tax) AS tax 
        FROM temp_stock_tax_details
        GROUP BY account_id, rate, sales_tax_detail_code
        LOOP
            INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
            SELECT 'Cr', this.account_id, this.statement_reference || _statement_reference, _default_currency_code, this.tax, 1, _default_currency_code, this.tax;
        END LOOP;    
    END IF;

    IF(COALESCE(_shipping_charge, 0) > 0) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', core.get_account_id_by_shipper_id(_shipper_id), _statement_reference, _default_currency_code, _shipping_charge, 1, _default_currency_code, _shipping_charge;                
    END IF;


    IF(_discount_total > 0) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', sales_discount_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(discount, 0)), 1, _default_currency_code, SUM(COALESCE(discount, 0))
        FROM temp_stock_details
        GROUP BY sales_discount_account_id;
    END IF;

    IF(_is_credit = true) THEN
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', core.get_account_id_by_party_id(_party_id), _statement_reference, _default_currency_code, _receivable, 1, _default_currency_code, _receivable;
    ELSE
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', _cash_account_id, _statement_reference, _cash_repository_id, _default_currency_code, _receivable, 1, _default_currency_code, _receivable;
    END IF;

    _transaction_master_id  := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id        := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));    
    _tran_counter           := transactions.get_new_transaction_counter(_value_date);
    _transaction_code       := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);
    _shipping_address_id    := core.get_shipping_address_id_by_shipping_address_code(_shipping_address_code, _party_id);

    UPDATE temp_transaction_details     SET transaction_master_id   = _transaction_master_id;
    UPDATE temp_stock_details           SET stock_master_id         = _stock_master_id;
    
    INSERT INTO transactions.transaction_master(transaction_master_id, transaction_counter, transaction_code, book, value_date, user_id, login_id, office_id, cost_center_id, reference_number, statement_reference) 
    SELECT _transaction_master_id, _tran_counter, _transaction_code, _book_name, _value_date, _user_id, _login_id, _office_id, _cost_center_id, _reference_number, _statement_reference;


    INSERT INTO transactions.transaction_details(value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency)
    SELECT _value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency
    FROM temp_transaction_details
    ORDER BY tran_type DESC;


    INSERT INTO transactions.stock_master(value_date, stock_master_id, transaction_master_id, party_id, salesperson_id, price_type_id, is_credit, payment_term_id, shipper_id, shipping_address_id, shipping_charge, store_id, cash_repository_id, non_taxable)
    SELECT _value_date, _stock_master_id, _transaction_master_id, _party_id, _salesperson_id, _price_type_id, _is_credit, _payment_term_id, _shipper_id, _shipping_address_id, _shipping_charge, _store_id, _cash_repository_id, _is_non_taxable_sales;
            

    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        _stock_detail_id        := nextval(pg_get_serial_sequence('transactions.stock_details', 'stock_detail_id'));

        INSERT INTO transactions.stock_details(stock_detail_id, value_date, stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price, cost_of_goods_sold, discount, shipping_charge, sales_tax_id, tax)
        SELECT _stock_detail_id, _value_date, this.stock_master_id, this.tran_type, this.store_id, this.item_id, this.quantity, this.unit_id, this.base_quantity, this.base_unit_id, this.price, COALESCE(this.cost_of_goods_sold, 0), this.discount, this.shipping_charge, this.sales_tax_id, COALESCE(this.tax, 0) 
        FROM temp_stock_details
        WHERE id = this.id;


        INSERT INTO transactions.stock_tax_details(stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax)
        SELECT _stock_detail_id, sales_tax_detail_id, state_sales_tax_id, county_sales_tax_id, principal, rate, tax
        FROM temp_stock_tax_details
        WHERE temp_stock_detail_id = this.id;
        
    END LOOP;



    IF(array_length(_attachments, 1) > 0 AND _attachments != ARRAY[NULL::core.attachment_type]) THEN
        INSERT INTO core.attachments(user_id, resource, resource_key, resource_id, original_file_name, file_extension, file_path, comment)
        SELECT _user_id, 'transactions.transaction_master', 'transaction_master_id', _transaction_master_id, original_file_name, file_extension, file_path, comment 
        FROM explode_array(_attachments);
    END IF;
    
    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    RETURN _transaction_master_id;
END
$$
LANGUAGE plpgsql;



--       SELECT * FROM transactions.post_sales('Sales.Direct', 2, 2, 5, '1-1-2020', 1, 'asdf', 'Test', false, NULL, 'JASMI-0002', 1, 1, 1, NULL, 1, false,
--       ARRAY[
--                  ROW(1, 'RMBP', 1, 'Piece',180000, 0, 200, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--                  ROW(1, '13MBA', 1, 'Dozen',130000, 300, 30, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--                  ROW(1, '11MBA', 1, 'Piece',110000, 5000, 50, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type], 
--       ARRAY[NULL::core.attachment_type]);



/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_sales_return.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_sales_return
(
    _transaction_master_id          bigint,
    _office_id                      integer,
    _user_id                        integer,
    _login_id                       bigint,
    _value_date                     date,
    _store_id                       integer,
    _party_code                     national character varying(12),
    _price_type_id                  integer,
    _reference_number               national character varying(24),
    _statement_reference            text,
    _details                        transactions.stock_detail_type[],
    _attachments                    core.attachment_type[]
);

CREATE FUNCTION transactions.post_sales_return
(
    _transaction_master_id          bigint,
    _office_id                      integer,
    _user_id                        integer,
    _login_id                       bigint,
    _value_date                     date,
    _store_id                       integer,
    _party_code                     national character varying(12),
    _price_type_id                  integer,
    _reference_number               national character varying(24),
    _statement_reference            text,
    _details                        transactions.stock_detail_type[],
    _attachments                    core.attachment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _party_id               bigint;
    DECLARE _cost_center_id         bigint;
    DECLARE _tran_master_id         bigint;
    DECLARE _tran_counter           integer;
    DECLARE _tran_code              text;
    DECLARE _stock_master_id        bigint;
    DECLARE _grand_total            money_strict;
    DECLARE _discount_total         money_strict2;
    DECLARE _tax_total              money_strict2;
    DECLARE _is_credit              boolean;
    DECLARE _default_currency_code  national character varying(12);
    DECLARE _cost_of_goods_sold     money_strict2;
    DECLARE _sm_id                  bigint;
    DECLARE _is_non_taxable_sales   boolean;
    DECLARE this                    RECORD;
    DECLARE _shipping_address_code  national character varying(12);
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, 'Sales.Return', _value_date) = false) THEN
        RETURN 0;
    END IF;
    
    _party_id                       := core.get_party_id_by_party_code(_party_code);
    _default_currency_code          := transactions.get_default_currency_code_by_office_id(_office_id);
    
    SELECT cost_center_id   INTO _cost_center_id    FROM transactions.transaction_master WHERE transactions.transaction_master.transaction_master_id = _transaction_master_id;

    SELECT 
        is_credit,
        non_taxable,
        core.get_shipping_address_code_by_shipping_address_id(shipping_address_id),
        stock_master_id
    INTO 
        _is_credit,
        _is_non_taxable_sales,
        _shipping_address_code,
        _sm_id
    FROM transactions.stock_master 
    WHERE transaction_master_id = _transaction_master_id;

    CREATE TEMPORARY TABLE temp_stock_details
    (
        id                              SERIAL PRIMARY KEY,
        stock_master_id                 bigint, 
        tran_type                       transaction_type, 
        store_id                        integer,
        item_code                       text,
        item_id                         integer, 
        quantity                        integer_strict,
        unit_name                       text,
        unit_id                         integer,
        base_quantity                   decimal,
        base_unit_id                    integer,                
        price                           money_strict,
        cost_of_goods_sold              money_strict2 DEFAULT(0),
        discount                        money_strict2,
        shipping_charge                 money_strict2,
        tax_form                        text,
        sales_tax_id                    integer,
        tax                             money_strict2,
        sales_account_id                integer,
        sales_discount_account_id       integer,
        sales_return_account_id         integer,
        inventory_account_id            integer,
        cost_of_goods_sold_account_id   integer        
    ) ON COMMIT DROP;

    CREATE TEMPORARY TABLE temp_stock_tax_details
    (
        id                                      SERIAL,
        temp_stock_detail_id                    integer REFERENCES temp_stock_details(id),
        sales_tax_detail_code                   text,
        stock_detail_id                         bigint,
        sales_tax_detail_id                     integer,
        state_sales_tax_id                      integer,
        county_sales_tax_id                     integer,
        account_id                              integer,
        principal                               money_strict,
        rate                                    decimal_strict,
        tax                                     money_strict
    ) ON COMMIT DROP;

    INSERT INTO temp_stock_details(store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax)
    SELECT store_id, item_code, quantity, unit_name, price, discount, shipping_charge, tax_form, tax
    FROM explode_array(_details);

    UPDATE temp_stock_details 
    SET
        tran_type                   = 'Dr',
        sales_tax_id                = core.get_sales_tax_id_by_sales_tax_code(tax_form),
        item_id                     = core.get_item_id_by_item_code(item_code),
        unit_id                     = core.get_unit_id_by_unit_name(unit_name),
        base_quantity               = core.get_base_quantity_by_unit_name(unit_name, quantity),
        base_unit_id                = core.get_base_unit_id_by_unit_name(unit_name);

    UPDATE temp_stock_details
    SET
        sales_account_id                = core.get_sales_account_id(item_id),
        sales_discount_account_id       = core.get_sales_discount_account_id(item_id),
        sales_return_account_id         = core.get_sales_return_account_id(item_id),        
        inventory_account_id            = core.get_inventory_account_id(item_id),
        cost_of_goods_sold_account_id   = core.get_cost_of_goods_sold_account_id(item_id);
    
    IF EXISTS
    (

        SELECT * 
        FROM transactions.stock_details
        INNER JOIN temp_stock_details
        ON temp_stock_details.item_id = transactions.stock_details.item_id
        WHERE transactions.stock_details.stock_master_id = _sm_id
        AND COALESCE(temp_stock_details.sales_tax_id, 0) != COALESCE(transactions.stock_details.sales_tax_id, 0)
        LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Tax form mismatch.'
        USING ERRCODE='P3202';
    END IF;

    IF EXISTS
    (
            SELECT 1 FROM temp_stock_details AS details
            WHERE core.is_valid_unit_id(details.unit_id, details.item_id) = false
            LIMIT 1
    ) THEN
        RAISE EXCEPTION 'Item/unit mismatch.'
        USING ERRCODE='P3201';
    END IF;

    IF(_is_non_taxable_sales) THEN
        IF EXISTS(SELECT * FROM temp_stock_details WHERE sales_tax_id IS NOT NULL LIMIT 1) THEN
            RAISE EXCEPTION 'You cannot provide sales tax information for non taxable sales.'
            USING ERRCODE='P5110';
        END IF;
    END IF;

    FOR this IN SELECT * FROM temp_stock_details ORDER BY id
    LOOP
        INSERT INTO temp_stock_tax_details
        (
            temp_stock_detail_id,
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            principal, 
            rate, 
            tax
        )
        SELECT 
            this.id, 
            sales_tax_detail_code,
            account_id, 
            sales_tax_detail_id, 
            state_sales_tax_id, 
            county_sales_tax_id, 
            taxable_amount, 
            rate, 
            tax
        FROM transactions.get_sales_tax('Sales', _store_id, _party_code, _shipping_address_code, _price_type_id, this.item_code, this.price, this.quantity, this.discount, this.shipping_charge, this.sales_tax_id);
    END LOOP;
    
    UPDATE temp_stock_details
    SET tax =
    (SELECT SUM(COALESCE(temp_stock_tax_details.tax, 0)) FROM temp_stock_tax_details
    WHERE temp_stock_tax_details.temp_stock_detail_id = temp_stock_details.id);

    _tran_master_id             := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));
    _stock_master_id            := nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));
    _tran_counter               := transactions.get_new_transaction_counter(_value_date);
    _tran_code                  := transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id);

    INSERT INTO transactions.transaction_master(transaction_master_id, transaction_counter, transaction_code, book, value_date, user_id, login_id, office_id, cost_center_id, reference_number, statement_reference)
    SELECT _tran_master_id, _tran_counter, _tran_code, 'Sales.Return', _value_date, _user_id, _login_id, _office_id, _cost_center_id, _reference_number, _statement_reference;
        
    SELECT SUM(COALESCE(tax, 0))                                INTO _tax_total FROM temp_stock_tax_details;
    SELECT SUM(COALESCE(discount, 0))                           INTO _discount_total FROM temp_stock_details;
    SELECT SUM(COALESCE(price, 0) * COALESCE(quantity, 0))      INTO _grand_total FROM temp_stock_details;



    UPDATE temp_stock_details
    SET cost_of_goods_sold = transactions.get_write_off_cost_of_goods_sold(_sm_id, item_id, unit_id, quantity);


    SELECT SUM(cost_of_goods_sold) INTO _cost_of_goods_sold FROM temp_stock_details;


    IF(_cost_of_goods_sold > 0) THEN
        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT _tran_master_id, _value_date, 'Dr', inventory_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
        FROM temp_stock_details
        GROUP BY inventory_account_id;


        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT _tran_master_id, _value_date, 'Cr', cost_of_goods_sold_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
        FROM temp_stock_details
        GROUP BY cost_of_goods_sold_account_id;
    END IF;


    INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, local_currency_code, er,amount_in_local_currency) 
    SELECT _tran_master_id, _value_date, 'Dr', sales_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)), _default_currency_code, 1, SUM(COALESCE(price, 0) * COALESCE(quantity, 0))
    FROM temp_stock_details
    GROUP BY sales_account_id;


    IF(_tax_total IS NOT NULL AND _tax_total > 0) THEN
        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency)
        SELECT _tran_master_id, _value_date, 'Dr', temp_stock_tax_details.account_id, _statement_reference, _default_currency_code, SUM(COALESCE(tax, 0)), _default_currency_code, 1, SUM(COALESCE(tax, 0))
        FROM temp_stock_tax_details
        GROUP BY temp_stock_tax_details.account_id;
    END IF;

    IF(_discount_total IS NOT NULL AND _discount_total > 0) THEN
        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency) 
        SELECT _tran_master_id, _value_date, 'Cr', sales_discount_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(discount, 0)), _default_currency_code, 1, SUM(COALESCE(discount, 0))
        FROM temp_stock_details
        GROUP BY sales_discount_account_id;
    END IF;

    IF(_is_credit) THEN
        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency) 
        SELECT _tran_master_id, _value_date, 'Cr',  core.get_account_id_by_party_code(_party_code), _statement_reference, _default_currency_code, _grand_total + _tax_total - _discount_total, _default_currency_code, 1, _grand_total + _tax_total - _discount_total;
    ELSE
        INSERT INTO transactions.transaction_details(transaction_master_id, value_date, tran_type, account_id, statement_reference, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency) 
        SELECT _tran_master_id, _value_date, 'Cr',  sales_return_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)) + SUM(COALESCE(tax, 0)) - SUM(COALESCE(discount, 0)), _default_currency_code, 1, SUM(COALESCE(price, 0) * COALESCE(quantity, 0)) + SUM(COALESCE(tax, 0)) - SUM(COALESCE(discount, 0))
        FROM temp_stock_details
        GROUP BY sales_return_account_id;
    END IF;



    INSERT INTO transactions.stock_master(stock_master_id, value_date, transaction_master_id, party_id, price_type_id, is_credit, store_id) 
    SELECT _stock_master_id, _value_date, _tran_master_id, _party_id, _price_type_id, false, _store_id;


    INSERT INTO transactions.stock_details(value_date, stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price, cost_of_goods_sold, discount, sales_tax_id, tax)
    SELECT _value_date, _stock_master_id, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price, cost_of_goods_sold, discount, sales_tax_id, tax FROM temp_stock_details;

    INSERT INTO transactions.stock_return(transaction_master_id, return_transaction_master_id)
    SELECT _transaction_master_id, _tran_master_id;

    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    RETURN _tran_master_id;
END
$$
LANGUAGE plpgsql;




-- CREATE TEMPORARY TABLE temp_sales_return
-- ON COMMIT DROP
-- AS
-- 
-- SELECT * FROM transactions.post_sales_return(5, 2, 2, 1, '1-1-2000', 1, 'MAJON-0002', 1, '1234-AD', 'Test', 
-- ARRAY[
--  ROW(1, 'RMBP', 1, 'Piece', 180000, 0, 200, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type,
--  ROW(1, '13MBA', 1, 'Piece', 110000, 5000, 50, 'MoF-NY-BK-STX', 0)::transactions.stock_detail_type
-- ],
-- ARRAY[
-- NULL::core.attachment_type
-- ]);
-- 
-- SELECT  tran_type, core.get_account_name_by_account_id(account_id), amount_in_local_currency 
-- FROM transactions.transaction_details
-- WHERE transaction_master_id  = (SELECT * FROM temp_sales_return);


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_stock_adjustment.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_stock_adjustment
(
        _office_id                              integer,
        _user_id                                integer,
        _login_id                               bigint,
        _value_date                             date,
        _reference_number                       national character varying(24),
        _statement_reference                    text,
        _details                                transactions.stock_adjustment_type[]
);


CREATE FUNCTION transactions.post_stock_adjustment
(
        _office_id                              integer,
        _user_id                                integer,
        _login_id                               bigint,
        _value_date                             date,
        _reference_number                       national character varying(24),
        _statement_reference                    text,
        _details                                transactions.stock_adjustment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _transaction_master_id                  bigint;
    DECLARE _stock_master_id                        bigint;
    DECLARE _book_name                              text='Stock.Adjustment';
    DECLARE _is_periodic                            boolean = office.is_periodic_inventory(_office_id);
    DECLARE _default_currency_code                  national character varying(12);
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    CREATE TEMPORARY TABLE IF NOT EXISTS temp_stock_details
    (
        tran_type                       transaction_type,
        store_id                        integer,
        store_name                      national character varying(50),
        item_id                         integer,
        item_code                       national character varying(12),
        unit_id                         integer,
        base_unit_id                    integer,
        unit_name                       national character varying(50),
        quantity                        integer_strict,
        base_quantity                   integer,                
        price                           money_strict,
        cost_of_goods_sold              money_strict2 DEFAULT(0),
        inventory_account_id            integer,
        cost_of_goods_sold_account_id   integer
    ) 
    ON COMMIT DROP; 

    DROP TABLE IF EXISTS temp_transaction_details;
    CREATE TEMPORARY TABLE temp_transaction_details
    (
        tran_type                   transaction_type, 
        account_id                  integer, 
        statement_reference         text, 
        cash_repository_id          integer, 
        currency_code               national character varying(12), 
        amount_in_currency          money_strict, 
        local_currency_code         national character varying(12), 
        er                          decimal_strict, 
        amount_in_local_currency    money_strict
    ) ON COMMIT DROP;

    INSERT INTO temp_stock_details(tran_type, store_name, item_code, unit_name, quantity)
    SELECT tran_type, store_name, item_code, unit_name, quantity FROM explode_array(_details);

    IF EXISTS
    (
        SELECT * FROM temp_stock_details
        WHERE tran_type = 'Dr'
    ) THEN
        RAISE EXCEPTION 'A stock adjustment entry can not contain debit item(s).'
        USING ERRCODE='P5201';
    END IF;

    IF EXISTS
    (
        SELECT 1 FROM temp_stock_details
        GROUP BY item_code, store_name
        HAVING COUNT(item_code) <> 1
    ) THEN
        RAISE EXCEPTION 'An item can appear only once in a store.'
        USING ERRCODE='P5202';
    END IF;

    UPDATE temp_stock_details 
    SET 
        item_id         = core.get_item_id_by_item_code(item_code),
        unit_id         = core.get_unit_id_by_unit_name(unit_name),
        store_id        = office.get_store_id_by_store_name(store_name);

    IF EXISTS
    (
        SELECT * FROM temp_stock_details
        WHERE item_id IS NULL OR unit_id IS NULL OR store_id IS NULL
    ) THEN
        RAISE EXCEPTION 'Invalid data supplied.'
        USING ERRCODE='P3000';
    END IF;

    UPDATE temp_stock_details 
    SET
        tran_type                       = 'Cr',
        base_quantity                   = core.get_base_quantity_by_unit_id(unit_id, quantity),
        base_unit_id                    = core.get_root_unit_id(unit_id),
        price                           = core.get_item_cost_price(item_id, unit_id, NULL),
        inventory_account_id            = core.get_inventory_account_id(item_id),
        cost_of_goods_sold_account_id   = core.get_cost_of_goods_sold_account_id(item_id);


    IF EXISTS
    (
            SELECT 1
            FROM 
            office.stores
            WHERE office.stores.store_id
            IN
            (
                SELECT temp_stock_details.store_id
                FROM temp_stock_details
            )
            HAVING COUNT(DISTINCT office.stores.office_id) > 1

    ) THEN
        RAISE EXCEPTION E'Access is denied!\nA stock adjustment transaction cannot references multiple branches.'
        USING ERRCODE='P9012';
    END IF;

    IF EXISTS
    (
            SELECT 1
            FROM 
            temp_stock_details
            WHERE tran_type = 'Cr'
            AND quantity > core.count_item_in_stock(item_id, unit_id, store_id)
    ) THEN
        RAISE EXCEPTION 'Negative stock is not allowed.'
        USING ERRCODE='P5001';
    END IF;

    --No accounting treatment is needed for periodic accounting system.
    IF(_is_periodic = false) THEN
        _default_currency_code  := transactions.get_default_currency_code_by_office_id(_office_id);

        UPDATE temp_stock_details 
        SET 
            cost_of_goods_sold = transactions.get_cost_of_goods_sold(item_id, unit_id, store_id, quantity);
    
        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Dr', cost_of_goods_sold_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
        FROM temp_stock_details
        GROUP BY cost_of_goods_sold_account_id;

        INSERT INTO temp_transaction_details(tran_type, account_id, statement_reference, currency_code, amount_in_currency, er, local_currency_code, amount_in_local_currency)
        SELECT 'Cr', inventory_account_id, _statement_reference, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0)), 1, _default_currency_code, SUM(COALESCE(cost_of_goods_sold, 0))
        FROM temp_stock_details
        GROUP BY inventory_account_id;
    END IF;
    
    _transaction_master_id  := nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));

    INSERT INTO transactions.transaction_master
    (
            transaction_master_id,
            transaction_counter,
            transaction_code,
            book,
            value_date,
            login_id,
            user_id,
            office_id,
            reference_number,
            statement_reference
    )
    SELECT
            _transaction_master_id, 
            transactions.get_new_transaction_counter(_value_date), 
            transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id),
            _book_name,
            _value_date,
            _login_id,
            _user_id,
            _office_id,
            _reference_number,
            _statement_reference;

    INSERT INTO transactions.transaction_details(value_date, transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency)
    SELECT _value_date, _transaction_master_id, tran_type, account_id, statement_reference, cash_repository_id, currency_code, amount_in_currency, local_currency_code, er, amount_in_local_currency
    FROM temp_transaction_details
    ORDER BY tran_type DESC;


    INSERT INTO transactions.stock_master(stock_master_id, transaction_master_id, value_date)
    SELECT nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id')), _transaction_master_id, _value_date;

    _stock_master_id                                := currval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));

    INSERT INTO transactions.stock_details(stock_master_id, value_date, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price)
    SELECT _stock_master_id, _value_date, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price
    FROM temp_stock_details;

    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    
    RETURN _transaction_master_id;
END
$$
LANGUAGE plpgsql;


-- SELECT * FROM transactions.post_stock_adjustment(2, 2, 5, '1-1-2020', '22', 'Test', 
-- ARRAY[
-- ROW('Cr', 'Store 1', 'RMBP', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Cr', 'Godown 1', 'RMBP', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Cr', 'Store 1', '11MBA', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Cr', 'Godown 1', '11MBA', 'Piece', 1)::transactions.stock_adjustment_type
-- ]
-- );




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.post_stock_journal.sql --<--<--
DROP FUNCTION IF EXISTS transactions.post_stock_journal
(
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _details                                transactions.stock_adjustment_type[]
);


CREATE FUNCTION transactions.post_stock_journal
(
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _value_date                             date,
    _reference_number                       national character varying(24),
    _statement_reference                    text,
    _details                                transactions.stock_adjustment_type[]
)
RETURNS bigint
AS
$$
    DECLARE _transaction_master_id                  bigint;
    DECLARE _stock_master_id                        bigint;
    DECLARE _book_name                              text='Stock.Transfer';
BEGIN
    IF(policy.can_post_transaction(_login_id, _user_id, _office_id, _book_name, _value_date) = false) THEN
        RETURN 0;
    END IF;

    CREATE TEMPORARY TABLE IF NOT EXISTS temp_stock_details
    (
        tran_type       transaction_type,
        store_id        integer,
        store_name      national character varying(50),
        item_id         integer,
        item_code       national character varying(12),
        unit_id         integer,
        base_unit_id    integer,
        unit_name       national character varying(50),
        quantity        integer_strict,
        base_quantity   integer,                
        price           money_strict                             
    ) 
    ON COMMIT DROP; 

    INSERT INTO temp_stock_details(tran_type, store_name, item_code, unit_name, quantity)
    SELECT tran_type, store_name, item_code, unit_name, quantity FROM explode_array(_details);

    IF EXISTS
    (
        SELECT 1 FROM temp_stock_details
        GROUP BY item_code, store_name
        HAVING COUNT(item_code) <> 1
    ) THEN
        RAISE EXCEPTION 'An item can appear only once in a store.'
        USING ERRCODE='P5202';
    END IF;

    IF EXISTS
    (
        SELECT item_code FROM temp_stock_details
        GROUP BY item_code
        HAVING SUM(CASE WHEN tran_type='Dr' THEN quantity ELSE quantity *-1 END) <> 0
    ) THEN
        RAISE EXCEPTION 'Referencing sides are not equal.'
        USING ERRCODE='P5000';        
    END IF;


    UPDATE temp_stock_details SET 
    item_id         = core.get_item_id_by_item_code(item_code),
    unit_id         = core.get_unit_id_by_unit_name(unit_name),
    store_id        = office.get_store_id_by_store_name(store_name);

    IF EXISTS
    (
        SELECT * FROM temp_stock_details
        WHERE item_id IS NULL OR unit_id IS NULL OR store_id IS NULL
    ) THEN
        RAISE EXCEPTION 'Invalid data supplied.'
        USING ERRCODE='P3000';
    END IF;

    UPDATE temp_stock_details SET
    base_unit_id    = core.get_root_unit_id(unit_id),
    base_quantity   = core.get_base_quantity_by_unit_id(unit_id, quantity),
    price           = core.get_item_cost_price(item_id, unit_id, NULL);



    IF EXISTS
    (
            SELECT 1
            FROM 
            office.stores
            WHERE office.stores.store_id
            IN
            (
                SELECT temp_stock_details.store_id
                FROM temp_stock_details
            )
            HAVING COUNT(DISTINCT office.stores.office_id) > 1

    ) THEN
        RAISE EXCEPTION E'Access is denied!\nA stock journal transaction cannot references multiple branches.'
        USING ERRCODE='P9013';
    END IF;

    IF EXISTS
    (
            SELECT 1
            FROM 
            temp_stock_details
            WHERE tran_type = 'Cr'
            AND quantity > core.count_item_in_stock(item_id, unit_id, store_id)
    ) THEN
        RAISE EXCEPTION 'Negative stock is not allowed.'
        USING ERRCODE='P5001';
    END IF;

    INSERT INTO transactions.transaction_master
    (
            transaction_master_id,
            transaction_counter,
            transaction_code,
            book,
            value_date,
            login_id,
            user_id,
            office_id,
            reference_number,
            statement_reference
    )
    SELECT
            nextval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id')), 
            transactions.get_new_transaction_counter(_value_date), 
            transactions.get_transaction_code(_value_date, _office_id, _user_id, _login_id),
            _book_name,
            _value_date,
            _login_id,
            _user_id,
            _office_id,
            _reference_number,
            _statement_reference;


    _transaction_master_id                          := currval(pg_get_serial_sequence('transactions.transaction_master', 'transaction_master_id'));


    INSERT INTO transactions.stock_master(stock_master_id, transaction_master_id, value_date)
    SELECT nextval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id')), _transaction_master_id, _value_date;

    _stock_master_id                                := currval(pg_get_serial_sequence('transactions.stock_master', 'stock_master_id'));

    INSERT INTO transactions.stock_details(stock_master_id, value_date, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price)
    SELECT _stock_master_id, _value_date, tran_type, store_id, item_id, quantity, unit_id, base_quantity, base_unit_id, price
    FROM temp_stock_details;
    
    
    PERFORM transactions.auto_verify(_transaction_master_id, _office_id);
    RETURN _transaction_master_id;
END
$$
LANGUAGE plpgsql;


-- SELECT * FROM transactions.post_stock_journal(2, 2, 5, '1-1-2020', '22', 'Test', 
-- ARRAY[
-- ROW('Cr', 'Store 1', 'RMBP', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Dr', 'Godown 1', 'RMBP', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Cr', 'Store 1', '11MBA', 'Piece', 1)::transactions.stock_adjustment_type,
-- ROW('Dr', 'Godown 1', '11MBA', 'Piece', 1)::transactions.stock_adjustment_type
-- ]
-- );




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.refresh_materialized_views.sql --<--<--
DROP FUNCTION IF EXISTS transactions.refresh_materialized_views(_office_id integer);

CREATE FUNCTION transactions.refresh_materialized_views(_office_id integer)
RETURNS void
AS
$$
BEGIN
        REFRESH MATERIALIZED VIEW transactions.trial_balance_view;
        REFRESH MATERIALIZED VIEW transactions.verified_stock_transaction_view;
        REFRESH MATERIALIZED VIEW transactions.verified_transaction_mat_view;
        REFRESH MATERIALIZED VIEW transactions.verified_cash_transaction_mat_view;
END
$$
LANGUAGE plpgsql;


SELECT transactions.create_routine('REF-MV', 'transactions.refresh_materialized_views', 1000);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.validate_item_for_return.sql --<--<--
DROP FUNCTION IF EXISTS transactions.validate_item_for_return(_transaction_master_id bigint, _store_id integer, _item_code national character varying(12), _unit_name national character varying(50), _quantity integer, _price money_strict);

CREATE FUNCTION transactions.validate_item_for_return(_transaction_master_id bigint, _store_id integer, _item_code national character varying(12), _unit_name national character varying(50), _quantity integer, _price money_strict)
RETURNS boolean
AS
$$
        DECLARE _stock_master_id bigint = 0;
        DECLARE _is_purchase boolean = false;
        DECLARE _item_id integer = 0;
        DECLARE _unit_id integer = 0;
        DECLARE _actual_quantity decimal_strict2 = 0;
        DECLARE _returned_in_previous_batch decimal_strict2 = 0;
        DECLARE _actual_price_in_root_unit money_strict2 = 0;
        DECLARE _price_in_root_unit money_strict2 = 0;
        DECLARE _item_in_stock decimal_strict2 = 0;        
BEGIN        
        IF(_store_id IS NULL OR _store_id <= 0) THEN
                RAISE EXCEPTION 'Invalid store.'
                USING ERRCODE='P3012';
        END IF;


        IF(_item_code IS NULL OR trim(_item_code) = '') THEN
                RAISE EXCEPTION 'Invalid item.'
                USING ERRCODE='P3051';
        END IF;

        IF(_unit_name IS NULL OR trim(_unit_name) = '') THEN
                RAISE EXCEPTION 'Invalid unit.'
                USING ERRCODE='P3052';
        END IF;

        IF(_quantity IS NULL OR _quantity <= 0) THEN
                RAISE EXCEPTION 'Invalid quantity.'
                USING ERRCODE='P3301';
        END IF;


        IF NOT EXISTS
        (
                SELECT * FROM transactions.transaction_master
                WHERE transaction_master_id = _transaction_master_id
                AND verification_status_id > 0
        ) THEN
                RAISE EXCEPTION 'Invalid or rejected transaction.'
                USING ERRCODE='P5301';
        END IF;
        
        
        _stock_master_id                := transactions.get_stock_master_id_by_transaction_master_id(_transaction_master_id);
        IF(_stock_master_id  IS NULL OR _stock_master_id  <= 0) THEN
                RAISE EXCEPTION 'Invalid transaction id.'
                USING ERRCODE='P3302';
        END IF;

        _item_id                        := core.get_item_id_by_item_code(_item_code);
        IF(_item_id IS NULL OR _item_id <= 0) THEN
                RAISE EXCEPTION 'Invalid item.'
                USING ERRCODE='P3051';
        END IF;

        IF NOT EXISTS
        (
                SELECT * FROM transactions.stock_details
                WHERE stock_master_id = _stock_master_id
                AND item_id = _item_id
                LIMIT 1
        ) THEN
                RAISE EXCEPTION '%', format('The item %1$s is not associated with this transaction.', _item_code)
                USING ERRCODE='P4020';
        END IF;

        _unit_id                        := core.get_unit_id_by_unit_name(_unit_name);
        IF(_unit_id IS NULL OR _unit_id <= 0) THEN
                RAISE EXCEPTION 'Invalid unit.'
                USING ERRCODE='P3052';
        END IF;


        _is_purchase                    := transactions.is_purchase(_transaction_master_id);

        IF NOT EXISTS
        (
                SELECT * FROM transactions.stock_details
                WHERE stock_master_id = _stock_master_id
                AND item_id = _item_id
                AND core.get_root_unit_id(_unit_id) = core.get_root_unit_id(unit_id)
                LIMIT 1
        ) THEN
                RAISE EXCEPTION 'Invalid or incompatible unit specified'
                USING ERRCODE='P3053';
        END IF;

        IF(_is_purchase = true) THEN
                _item_in_stock = core.count_item_in_stock(_item_id, _unit_id, _store_id);

                IF(_item_in_stock < _quantity) THEN
                        RAISE EXCEPTION '%', format('Only %1$s %2$s of %3$s left in stock.',_item_in_stock, _unit_name, _item_code)
                        USING ERRCODE='P5500';
                END IF;
        END IF;

        SELECT 
                COALESCE(core.convert_unit(base_unit_id, _unit_id) * base_quantity, 0)
                INTO _actual_quantity
        FROM transactions.stock_details
        WHERE stock_master_id = _stock_master_id
        AND item_id = _item_id;

        SELECT 
                COALESCE(SUM(core.convert_unit(base_unit_id, 1) * base_quantity), 0)
                INTO _returned_in_previous_batch
        FROM transactions.stock_details
        WHERE stock_master_id IN
        (
                SELECT stock_master_id
                FROM transactions.stock_master
                INNER JOIN transactions.transaction_master
                ON transactions.transaction_master.transaction_master_id = transactions.stock_master.transaction_master_id
                WHERE transactions.transaction_master.verification_status_id > 0
                AND transactions.stock_master.transaction_master_id IN (

                        SELECT 
                        return_transaction_master_id 
                        FROM transactions.stock_return
                        WHERE transaction_master_id = _transaction_master_id
                )
        )
        AND item_id = _item_id;



        IF(_quantity + _returned_in_previous_batch > _actual_quantity) THEN
                RAISE EXCEPTION 'The returned quantity cannot be greater than actual quantity.'
                USING ERRCODE='P5203';
        END IF;



        _price_in_root_unit := core.convert_unit(core.get_root_unit_id(_unit_id), _unit_id) * _price;



        SELECT 
                (core.convert_unit(core.get_root_unit_id(transactions.stock_details.unit_id), transactions.stock_details.base_unit_id) * price) / (base_quantity/quantity)
                INTO _actual_price_in_root_unit
        FROM transactions.stock_details
        WHERE stock_master_id = _stock_master_id
        AND item_id = _item_id;


        IF(_price_in_root_unit > _actual_price_in_root_unit) THEN
                RAISE EXCEPTION 'The returned amount cannot be greater than actual amount.'
                USING ERRCODE='P5204';

                RETURN FALSE;
        END IF;

        RETURN TRUE;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM transactions.validate_item_for_return(9, 1, 'RMBP', 'Piece', 1, 180000);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/functions/transactions/transactions.verify_transaction.sql --<--<--
-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/FrontEnd/MixERP.Net.FrontEnd/db/src/02. functions and logic/logic/functions/transactions/transactions.verify_transaction.sql --<--<--
DROP FUNCTION IF EXISTS transactions.verify_transaction
(
    _transaction_master_id                  bigint,
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _verification_status_id                 smallint,
    _reason                                 national character varying
) 
CASCADE;

CREATE FUNCTION transactions.verify_transaction
(
    _transaction_master_id                  bigint,
    _office_id                              integer,
    _user_id                                integer,
    _login_id                               bigint,
    _verification_status_id                 smallint,
    _reason                                 national character varying
)
RETURNS VOID
VOLATILE
AS
$$
    DECLARE _transaction_posted_by integer;
    DECLARE _can_approve boolean=true;
    DECLARE _book text;
    DECLARE _verify_sales boolean;
    DECLARE _sales_verification_limit money_strict2;
    DECLARE _verify_purchase boolean;
    DECLARE _purchase_verification_limit money_strict2;
    DECLARE _verify_gl boolean;
    DECLARE _gl_verification_limit money_strict2;
    DECLARE _posted_amount money_strict2;
    DECLARE _has_policy boolean=false;
    DECLARE _voucher_date date;
    DECLARE _voucher_office_id integer;
    DECLARE _value_date date=transactions.get_value_date(_office_id);
BEGIN

    SELECT
        transactions.transaction_master.book,
        transactions.transaction_master.value_date,
        transactions.transaction_master.office_id,
        transactions.transaction_master.user_id
    INTO
        _book,
        _voucher_date,
        _voucher_office_id,
        _transaction_posted_by  
    FROM
    transactions.transaction_master
    WHERE transactions.transaction_master.transaction_master_id=_transaction_master_id;


    IF(_voucher_office_id <> _office_id) THEN
        RAISE EXCEPTION 'Access is denied. You cannot verify a transaction of another office.'
        USING ERRCODE='P9014';
    END IF;
    
    IF(_voucher_date <> _value_date) THEN
        RAISE EXCEPTION 'Access is denied. You cannot verify past or futuer dated transaction.'
        USING ERRCODE='P9015';
    END IF;
    
    SELECT
        SUM(amount_in_local_currency)
    INTO
        _posted_amount
    FROM
        transactions.transaction_details
    WHERE transactions.transaction_details.transaction_master_id = _transaction_master_id
    AND transactions.transaction_details.tran_type='Cr';


    SELECT
        true,
        can_verify_sales_transactions,
        sales_verification_limit,
        can_verify_purchase_transactions,
        purchase_verification_limit,
        can_verify_gl_transactions,
        gl_verification_limit
    INTO
        _has_policy,
        _verify_sales,
        _sales_verification_limit,
        _verify_purchase,
        _purchase_verification_limit,
        _verify_gl,
        _gl_verification_limit
    FROM
    policy.voucher_verification_policy
    WHERE user_id=_user_id
    AND is_active=true
    AND now() >= effective_from
    AND now() <= ends_on;


    IF(lower(_book) LIKE 'sales%') THEN
        IF(_verify_sales = false) THEN
            _can_approve := false;
        END IF;
        IF(_verify_sales = true) THEN
            IF(_posted_amount > _sales_verification_limit AND _sales_verification_limit > 0::money_strict2) THEN
                _can_approve := false;
            END IF;
        END IF;         
    END IF;


    IF(lower(_book) LIKE 'purchase%') THEN
        IF(_verify_purchase = false) THEN
            _can_approve := false;
        END IF;
        IF(_verify_purchase = true) THEN
            IF(_posted_amount > _purchase_verification_limit AND _purchase_verification_limit > 0::money_strict2) THEN
                _can_approve := false;
            END IF;
        END IF;         
    END IF;


    IF(lower(_book) LIKE 'journal%') THEN
        IF(_verify_gl = false) THEN
            _can_approve := false;
        END IF;
        IF(_verify_gl = true) THEN
            IF(_posted_amount > _gl_verification_limit AND _gl_verification_limit > 0::money_strict2) THEN
                _can_approve := false;
            END IF;
        END IF;         
    END IF;

    IF(_has_policy=true) THEN
        IF(_can_approve = true) THEN
            UPDATE transactions.transaction_master
            SET 
                last_verified_on = now(),
                verified_by_user_id=_user_id,
                verification_status_id=_verification_status_id,
                verification_reason=_reason
            WHERE
                transactions.transaction_master.transaction_master_id=_transaction_master_id;
            RAISE NOTICE 'Done.';
        END IF;
    ELSE
        RAISE EXCEPTION 'No verification policy found for this user.'
        USING ERRCODE='P4030';
    END IF;
    RETURN;
END
$$
LANGUAGE plpgsql;


--SELECT * FROM transactions.verify_transaction(65::bigint, 2, 2, 51::bigint, -3::smallint, '');

/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/triggers/policy.check_menu_policy_trigger.sql --<--<--
DROP FUNCTION IF EXISTS policy.check_menu_policy_trigger() CASCADE;


CREATE FUNCTION policy.check_menu_policy_trigger()
RETURNS trigger
AS
$$
    DECLARE count integer=0;
BEGIN
    IF NEW.office_id IS NOT NULL THEN
        count := count + 1;
    END IF;

    IF NEW.role_id IS NOT NULL THEN
        count := count + 1;
    END IF;
    
    IF NEW.user_id IS NOT NULL THEN
        count := count + 1;
    END IF;

    IF count <> 1 THEN
        RAISE EXCEPTION 'Only one of the following columns is required : %', 'office_id, role_id, user_id.'
        USING ERRCODE='P8501';
    END IF;

    RETURN NEW;
END
$$
LANGUAGE plpgsql;


CREATE TRIGGER check_menu_policy_trigger BEFORE INSERT
ON policy.menu_policy
FOR EACH ROW EXECUTE PROCEDURE policy.check_menu_policy_trigger();


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/logic/triggers/transactions.verification_trigger.sql --<--<--
DROP FUNCTION IF EXISTS transactions.verification_trigger() CASCADE;
CREATE FUNCTION transactions.verification_trigger()
RETURNS TRIGGER
AS
$$
    DECLARE _transaction_master_id bigint;
    DECLARE _transaction_posted_by integer;
    DECLARE _old_verifier integer;
    DECLARE _old_status integer;
    DECLARE _old_reason national character varying(128);
    DECLARE _verifier integer;
    DECLARE _status integer;
    DECLARE _reason national character varying(128);
    DECLARE _has_policy boolean;
    DECLARE _is_sys boolean;
    DECLARE _rejected smallint=-3;
    DECLARE _closed smallint=-2;
    DECLARE _withdrawn smallint=-1;
    DECLARE _unapproved smallint = 0;
    DECLARE _auto_approved smallint = 1;
    DECLARE _approved smallint=2;
    DECLARE _book text;
    DECLARE _can_verify_sales_transactions boolean;
    DECLARE _sales_verification_limit money_strict2;
    DECLARE _can_verify_purchase_transactions boolean;
    DECLARE _purchase_verification_limit money_strict2;
    DECLARE _can_verify_gl_transactions boolean;
    DECLARE _gl_verification_limit money_strict2;
    DECLARE _can_verify_self boolean;
    DECLARE _self_verification_limit money_strict2;
    DECLARE _posted_amount money_strict2;
BEGIN
    IF TG_OP='DELETE' THEN
        RAISE EXCEPTION 'Deleting a transaction is not allowed. Mark the transaction as rejected instead.'
        USING ERRCODE='P5800';
    END IF;

    IF TG_OP='UPDATE' THEN
        RAISE NOTICE 'Columns except the following will be ignored for this update: %', 'verified_by_user_id, verification_status_id, verification_reason.';

        IF(OLD.transaction_master_id IS DISTINCT FROM NEW.transaction_master_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"transaction_master_id".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.transaction_counter IS DISTINCT FROM NEW.transaction_counter) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"transaction_counter".'
            USING ERRCODE='P8502';            
        END IF;

        IF(OLD.transaction_code IS DISTINCT FROM NEW.transaction_code) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"transaction_code".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.book IS DISTINCT FROM NEW.book) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"book".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.value_date IS DISTINCT FROM NEW.value_date) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"value_date".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.transaction_ts IS DISTINCT FROM NEW.transaction_ts) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"transaction_ts".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.login_id IS DISTINCT FROM NEW.login_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"login_id".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.user_id IS DISTINCT FROM NEW.user_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"user_id".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.sys_user_id IS DISTINCT FROM NEW.sys_user_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"sys_user_id".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.office_id IS DISTINCT FROM NEW.office_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"office_id".'
            USING ERRCODE='P8502';
        END IF;

        IF(OLD.cost_center_id IS DISTINCT FROM NEW.cost_center_id) THEN
            RAISE EXCEPTION 'Cannot update the column %', '"cost_center_id".'
            USING ERRCODE='P8502';
        END IF;

        _transaction_master_id := OLD.transaction_master_id;
        _book := OLD.book;
        _old_verifier := OLD.verified_by_user_id;
        _old_status := OLD.verification_status_id;
        _old_reason := OLD.verification_reason;
        _transaction_posted_by := OLD.user_id;      
        _verifier := NEW.verified_by_user_id;
        _status := NEW.verification_status_id;
        _reason := NEW.verification_reason;
        _is_sys := office.is_sys(_verifier);


        SELECT
            SUM(amount_in_local_currency)
        INTO
            _posted_amount
        FROM
            transactions.transaction_details
        WHERE transactions.transaction_details.transaction_master_id = _transaction_master_id
        AND transactions.transaction_details.tran_type='Cr';


        SELECT
            true,
            can_verify_sales_transactions,
            sales_verification_limit,
            can_verify_purchase_transactions,
            purchase_verification_limit,
            can_verify_gl_transactions,
            gl_verification_limit,
            can_self_verify,
            self_verification_limit
        INTO
            _has_policy,
            _can_verify_sales_transactions,
            _sales_verification_limit,
            _can_verify_purchase_transactions,
            _purchase_verification_limit,
            _can_verify_gl_transactions,
            _gl_verification_limit,
            _can_verify_self,
            _self_verification_limit
        FROM
        policy.voucher_verification_policy
        WHERE user_id=_verifier
        AND is_active=true
        AND now() >= effective_from
        AND now() <= ends_on;

        IF(_verifier IS NULL) THEN
            RAISE EXCEPTION 'Access is denied.'
            USING ERRCODE='P9001';
        END IF;     
        
        IF(_status != _withdrawn AND _has_policy = false) THEN
            RAISE EXCEPTION 'Access is denied. You don''t have the right to verify the transaction.'
            USING ERRCODE='P9016';
        END IF;

        IF(_status = _withdrawn AND _has_policy = false) THEN
            IF(_transaction_posted_by != _verifier) THEN
                RAISE EXCEPTION 'Access is denied. You don''t have the right to withdraw the transaction.'
                USING ERRCODE='P9017';
            END IF;
        END IF;

        IF(_status = _auto_approved AND _is_sys = false) THEN
            RAISE EXCEPTION 'Access is denied.'
            USING ERRCODE='P9001';
        END IF;


        IF(_has_policy = false) THEN
            RAISE EXCEPTION 'Access is denied.'
            USING ERRCODE='P9001';
        END IF;


        --Is trying verify self transaction.
        IF(NEW.verified_by_user_id = NEW.user_id) THEN
            IF(_can_verify_self = false) THEN
                RAISE EXCEPTION 'Please ask someone else to verify the transaction you posted.'
                USING ERRCODE='P5901';                
            END IF;
            IF(_can_verify_self = true) THEN
                IF(_posted_amount > _self_verification_limit AND _self_verification_limit > 0::money_strict2) THEN
                    RAISE EXCEPTION 'Self verification limit exceeded. The transaction was not verified.'
                    USING ERRCODE='P5910';
                END IF;
            END IF;
        END IF;

        IF(lower(_book) LIKE '%sales%') THEN
            IF(_can_verify_sales_transactions = false) THEN
                RAISE EXCEPTION 'Access is denied.'
                USING ERRCODE='P9001';
            END IF;
            IF(_can_verify_sales_transactions = true) THEN
                IF(_posted_amount > _sales_verification_limit AND _sales_verification_limit > 0::money_strict2) THEN
                    RAISE EXCEPTION 'Sales verification limit exceeded. The transaction was not verified.'
                    USING ERRCODE='P5911';
                END IF;
            END IF;         
        END IF;


        IF(lower(_book) LIKE '%purchase%') THEN
            IF(_can_verify_purchase_transactions = false) THEN
                RAISE EXCEPTION 'Access is denied.'
                USING ERRCODE='P9001';
            END IF;
            IF(_can_verify_purchase_transactions = true) THEN
                IF(_posted_amount > _purchase_verification_limit AND _purchase_verification_limit > 0::money_strict2) THEN
                    RAISE EXCEPTION 'Purchase verification limit exceeded. The transaction was not verified.'
                    USING ERRCODE='P5912';
                END IF;
            END IF;         
        END IF;


        IF(lower(_book) LIKE 'journal%') THEN
            IF(_can_verify_gl_transactions = false) THEN
                RAISE EXCEPTION 'Access is denied.'
                USING ERRCODE='P9001';
            END IF;
            IF(_can_verify_gl_transactions = true) THEN
                IF(_posted_amount > _gl_verification_limit AND _gl_verification_limit > 0::money_strict2) THEN
                    RAISE EXCEPTION 'GL verification limit exceeded. The transaction was not verified.'
                    USING ERRCODE='P5913';
                END IF;
            END IF;         
        END IF;

        NEW.last_verified_on := now();

    END IF; 
    RETURN NEW;
END
$$
LANGUAGE plpgsql;


CREATE TRIGGER verification_update_trigger
AFTER UPDATE
ON transactions.transaction_master
FOR EACH ROW 
EXECUTE PROCEDURE transactions.verification_trigger();

CREATE TRIGGER verification_delete_trigger
BEFORE DELETE
ON transactions.transaction_master
FOR EACH ROW 
EXECUTE PROCEDURE transactions.verification_trigger();


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.count_item_in_stock.sql --<--<--
CREATE FUNCTION office.count_item_in_stock(item_id_ integer, unit_id_ integer, office_id_ integer)
RETURNS decimal
AS
$$
    DECLARE _base_unit_id integer;
    DECLARE _debit decimal;
    DECLARE _credit decimal;
    DECLARE _balance decimal;
    DECLARE _factor decimal;
BEGIN

    --Get the base item unit
    SELECT 
        core.get_root_unit_id(core.items.unit_id) 
    INTO _base_unit_id
    FROM core.items
    WHERE core.items.item_id=$1;

    --Get the sum of debit stock quantity from approved transactions
    SELECT 
        COALESCE(SUM(base_quantity), 0)
    INTO _debit
    FROM transactions.stock_details
    INNER JOIN transactions.stock_master
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    INNER JOIN transactions.transaction_master
    ON transactions.stock_master.transaction_master_id = transactions.transaction_master.transaction_master_id
    WHERE transactions.transaction_master.verification_status_id > 0
    AND transactions.stock_details.item_id=$1
    AND transactions.stock_details.store_id IN (SELECT store_id FROM office.stores WHERE office.stores.office_id = $3)
    AND transactions.stock_details.tran_type='Dr';
    
    --Get the sum of credit stock quantity from approved transactions
    SELECT 
        COALESCE(SUM(base_quantity), 0)
    INTO _credit
    FROM transactions.stock_details
    INNER JOIN transactions.stock_master
    ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
    INNER JOIN transactions.transaction_master
    ON transactions.stock_master.transaction_master_id = transactions.transaction_master.transaction_master_id
    WHERE transactions.transaction_master.verification_status_id > 0
    AND transactions.stock_details.item_id=$1
    AND transactions.stock_details.store_id IN (SELECT store_id FROM office.stores WHERE office.stores.office_id = $3)
    AND transactions.stock_details.tran_type='Cr';
    
    _balance:= _debit - _credit;

    
    _factor = core.convert_unit($2, _base_unit_id);

    return _balance / _factor;  
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.create_user.sql --<--<--
CREATE FUNCTION office.create_user
(
    _role_id		integer,
    _department_id	integer,
    _office_id		integer,
    _user_name 		text,
    _password 		text,
    _full_name 		text,
    _elevated 		boolean = false
)
RETURNS VOID
AS
$$
BEGIN
    INSERT INTO office.users(role_id, department_id, office_id, user_name, password, full_name, elevated)
    SELECT _role_id, _department_id, _office_id, _user_name, _password, _full_name, _elevated;
    RETURN;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_cash_repository_id_by_cash_repository_code.sql --<--<--
CREATE FUNCTION office.get_cash_repository_id_by_cash_repository_code(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT cash_repository_id
        FROM office.cash_repositories
        WHERE cash_repository_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_cash_repository_id_by_cash_repository_name.sql --<--<--
CREATE FUNCTION office.get_cash_repository_id_by_cash_repository_name(text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT cash_repository_id
        FROM office.cash_repositories
        WHERE cash_repository_name=$1
    );
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_cost_center_id_by_cost_center_code.sql --<--<--
DROP FUNCTION IF EXISTS office.get_cost_center_id_by_cost_center_code(text);

CREATE FUNCTION office.get_cost_center_id_by_cost_center_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN cost_center_id
    FROM office.cost_centers
    WHERE cost_center_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_cost_of_good_method.sql --<--<--
DROP FUNCTION IF EXISTS office.get_cost_of_good_method(_office_id integer);

CREATE FUNCTION office.get_cost_of_good_method(_office_id integer)
RETURNS text
AS
$$
BEGIN
        RETURN value
        FROM office.configuration
        WHERE office_id=$1
        AND config_id=2;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_department_id_by_code.sql --<--<--
DROP FUNCTION IF EXISTS office.get_department_id_by_code(text);

CREATE FUNCTION office.get_department_id_by_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN department_id
    FROM office.departments
    WHERE department_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_logged_in_culture.sql --<--<--
CREATE FUNCTION office.get_logged_in_culture(_user_id integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT culture
        FROM audit.logins
        WHERE user_id=$1
        AND login_date_time = 
        (
            SELECT MAX(login_date_time)
            FROM audit.logins
            WHERE user_id=$1
        )
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_logged_in_office_id.sql --<--<--
CREATE FUNCTION office.get_logged_in_office_id(_user_id integer)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office_id
        FROM audit.logins
        WHERE user_id=$1
        AND login_date_time = 
        (
            SELECT MAX(login_date_time)
            FROM audit.logins
            WHERE user_id=$1
        )
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_login_id.sql --<--<--
DROP FUNCTION IF EXISTS office.get_login_id(_user_id integer);

CREATE FUNCTION office.get_login_id(_user_id integer)
RETURNS bigint
AS
$$
BEGIN
    RETURN
    (
        SELECT login_id
        FROM audit.logins
        WHERE user_id=$1
        AND login_date_time = 
        (
            SELECT MAX(login_date_time)
            FROM audit.logins
            WHERE user_id=$1
        )
        LIMIT 1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_code_by_id.sql --<--<--
CREATE FUNCTION office.get_office_code_by_id(office_id integer_strict)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT office.offices.office_code FROM office.offices
        WHERE office.offices.office_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_id_by_cash_repository_id.sql --<--<--
DROP FUNCTION IF EXISTS office.get_office_id_by_cash_repository_id(integer);

CREATE FUNCTION office.get_office_id_by_cash_repository_id(integer)
RETURNS integer
AS
$$
BEGIN
        RETURN office_id
        FROM office.cash_repositories
        WHERE cash_repository_id=$1;
END
$$
LANGUAGE plpgsql;


ALTER TABLE office.stores
ADD CONSTRAINT store_default_cash_repository_chk
CHECK(office.get_office_id_by_cash_repository_id(default_cash_repository_id) = office_id);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_id_by_office_code.sql --<--<--
CREATE FUNCTION office.get_office_id_by_office_code(office_code text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office.offices.office_id FROM office.offices
        WHERE office.offices.office_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_id_by_store_id.sql --<--<--
DROP FUNCTION IF EXISTS office.get_office_id_by_store_id(integer);

CREATE FUNCTION office.get_office_id_by_store_id(integer)
RETURNS integer
AS
$$
BEGIN
        RETURN office_id
        FROM office.stores
        WHERE store_id=$1;
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_id_by_user_id.sql --<--<--
CREATE FUNCTION office.get_office_id_by_user_id(user_id integer_strict)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office.users.office_id FROM office.users
        WHERE office.users.user_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_ids.sql --<--<--
DROP FUNCTION IF EXISTS office.get_office_ids(root_office_id integer);

CREATE FUNCTION office.get_office_ids(root_office_id integer)
RETURNS SETOF integer
AS
$$
BEGIN
    RETURN QUERY 
    (
        WITH RECURSIVE office_cte(office_id, path) AS (
         SELECT
            tn.office_id,  tn.office_id::TEXT AS path
            FROM office.offices AS tn WHERE tn.office_id =$1
        UNION ALL
         SELECT
            c.office_id, (p.path || '->' || c.office_id::TEXT)
            FROM office_cte AS p, office.offices AS c WHERE parent_office_id = p.office_id
        )

        SELECT office_id FROM office_cte
    );
END
$$LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_office_name_by_id.sql --<--<--
CREATE FUNCTION office.get_office_name_by_id(office_id integer_strict)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT office.offices.office_name FROM office.offices
        WHERE office.offices.office_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_offices.sql --<--<--
CREATE TYPE office.office_type AS
(
    office_id                   integer,
    office_code                 national character varying(12),
    office_name                 national character varying(150),
    address text
);

DROP FUNCTION IF EXISTS office.get_offices();

CREATE FUNCTION office.get_offices()
RETURNS setof office.office_type
STABLE
AS
$$
BEGIN
    RETURN QUERY
    SELECT office_id, office_code,office_name,street || ' ' || city AS Address FROM office.offices
    ORDER BY parent_office_id NULLS LAST;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_role_code_by_user_name.sql --<--<--
CREATE FUNCTION office.get_role_code_by_user_name(user_name text)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT office.roles.role_code FROM office.roles, office.users
        WHERE office.roles.role_id=office.users.role_id
        AND office.users.user_name=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_role_id_by_role_code.sql --<--<--
DROP FUNCTION IF EXISTS office.get_role_id_by_role_code(text);

CREATE FUNCTION office.get_role_id_by_role_code(text)
RETURNS integer
AS
$$
BEGIN
        RETURN
        role_id
        FROM office.roles
        WHERE role_code=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_role_id_by_role_name.sql --<--<--
DROP FUNCTION IF EXISTS office.get_role_id_by_role_name(text);

CREATE FUNCTION office.get_role_id_by_role_name(text)
RETURNS integer
AS
$$
BEGIN
        RETURN
        role_id
        FROM office.roles
        WHERE role_name=$1;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_role_id_by_use_id.sql --<--<--
CREATE FUNCTION office.get_role_id_by_use_id(user_id integer_strict)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office.users.role_id FROM office.users
        WHERE office.users.user_id=$1
    );
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_store_id_by_store_code.sql --<--<--
DROP FUNCTION IF EXISTS office.get_store_id_by_store_code(text);

CREATE FUNCTION office.get_store_id_by_store_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN
    (
        SELECT store_id
        FROM office.stores
        WHERE store_code=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_store_id_by_store_name.sql --<--<--
CREATE FUNCTION office.get_store_id_by_store_name(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN
    (
        SELECT store_id
        FROM office.stores
        WHERE store_name=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_store_name_by_store_id.sql --<--<--
CREATE FUNCTION office.get_store_name_by_store_id(integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT store_name
        FROM office.stores
        WHERE store_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_store_type_id_by_store_type_code.sql --<--<--
DROP FUNCTION IF EXISTS office.get_store_type_id_by_store_type_code(text);

CREATE FUNCTION office.get_store_type_id_by_store_type_code(text)
RETURNS integer
STABLE
AS
$$
BEGIN
    RETURN store_type_id
    FROM office.store_types
    WHERE store_type_code=$1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_sys_user_id.sql --<--<--
CREATE FUNCTION office.get_sys_user_id()
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office.users.user_id 
        FROM office.roles, office.users
        WHERE office.roles.role_id = office.users.role_id
        AND office.roles.is_system=true LIMIT 1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_user_id_by_user_name.sql --<--<--
CREATE FUNCTION office.get_user_id_by_user_name(user_name text)
RETURNS integer
AS
$$
BEGIN
    RETURN
    (
        SELECT office.users.user_id FROM office.users
        WHERE office.users.user_name=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.get_user_name_by_user_id.sql --<--<--
CREATE FUNCTION office.get_user_name_by_user_id(user_id integer)
RETURNS text
AS
$$
BEGIN
    RETURN
    (
        SELECT office.users.user_name FROM office.users
        WHERE office.users.user_id=$1
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_admin.sql --<--<--
CREATE FUNCTION office.is_admin(integer)
RETURNS boolean
AS
$$
BEGIN
    RETURN
    (
        SELECT office.roles.is_admin FROM office.users
        INNER JOIN office.roles
        ON office.users.role_id = office.roles.role_id
        WHERE office.users.user_id=$1
    );
END
$$
LANGUAGE PLPGSQL;

ALTER TABLE office.users
ADD CONSTRAINT users_elevated_chk
CHECK
(
    (NOT office.is_admin(user_id) AND NOT elevated)
    OR
    (office.is_admin(user_id))
);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_parent_office.sql --<--<--

CREATE FUNCTION office.is_parent_office(parent integer_strict, child integer_strict)
RETURNS boolean
AS
$$      
BEGIN
    IF $1!=$2 THEN
        IF EXISTS
        (
            WITH RECURSIVE office_cte(office_id, path) AS (
             SELECT
                tn.office_id,  tn.office_id::TEXT AS path
                FROM office.offices AS tn WHERE tn.parent_office_id IS NULL
            UNION ALL
             SELECT
                c.office_id, (p.path || '->' || c.office_id::TEXT)
                FROM office_cte AS p, office.offices AS c WHERE parent_office_id = p.office_id
            )
            SELECT * FROM
            (
                SELECT regexp_split_to_table(path, '->')
                FROM office_cte AS n WHERE n.office_id = $2
            ) AS items
            WHERE regexp_split_to_table=$1::text
        ) THEN
            RETURN TRUE;
        END IF;
    END IF;
    RETURN false;
END
$$
LANGUAGE plpgsql;


ALTER TABLE office.offices
ADD CONSTRAINT offices_check_if_parent_chk
        CHECK
        (
            office.is_parent_office(office_id, parent_office_id) = FALSE
            AND
            parent_office_id != office_id
        );


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_periodic_inventory.sql --<--<--
DROP FUNCTION IF EXISTS office.is_periodic_inventory(_office_id integer);

CREATE FUNCTION office.is_periodic_inventory(_office_id integer)
RETURNS boolean
AS
$$
    DECLARE config boolean;
BEGIN
    SELECT value = 'Periodic' INTO config
    FROM office.configuration
    WHERE config_id=1
    AND office_id=$1;

    IF(config IS NULL) THEN
        RETURN false;
    END IF;

    RETURN config;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_sys.sql --<--<--
CREATE FUNCTION office.is_sys(integer)
RETURNS boolean
AS
$$
BEGIN
    RETURN
    (
        SELECT office.roles.is_system FROM office.users
        INNER JOIN office.roles
        ON office.users.role_id = office.roles.role_id
        WHERE office.users.user_id=$1
    );
END
$$
LANGUAGE PLPGSQL;





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_sys_user.sql --<--<--
CREATE FUNCTION office.is_sys_user(integer)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT * FROM office.users
        WHERE user_id=$1
        AND role_id IN
        (
            SELECT office.roles.role_id FROM office.roles WHERE office.roles.role_code='SYST'
        )
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.is_valid_office_id.sql --<--<--
DROP FUNCTION IF EXISTS office.is_valid_office_id(integer);

CREATE FUNCTION office.is_valid_office_id(integer)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT 1 FROM office.offices WHERE office_id=$1) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/office/office.validate_login.sql --<--<--
DROP FUNCTION IF EXISTS office.validate_login
(
    user_name       text,
    password        text,
    challenge       text
);

CREATE FUNCTION office.validate_login
(
    user_name       text,
    password        text,
    challenge       text
)
RETURNS boolean
AS
$$
BEGIN

    IF EXISTS
    (
        SELECT 1 FROM office.users 
        WHERE office.users.user_name=$1 
        AND encode(digest(office.users.password || challenge, 'sha512'), 'hex')=$2
        --The system user must never login.
        AND office.users.role_id != 
        (
            SELECT office.roles.role_id 
            FROM office.roles 
            WHERE office.roles.role_code='SYST'
        )
    ) THEN
        RETURN true;
    END IF;
    RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/policy/policy.is_elevated_user.sql --<--<--
DROP FUNCTION IF EXISTS policy.is_elevated_user(_user_id integer);

CREATE FUNCTION policy.is_elevated_user(_user_id integer)
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 0 FROM office.users
        WHERE user_id = $1
        AND elevated
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END;
$$
LANGUAGE plpgsql;


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/policy/policy.is_locked_out_till.sql --<--<--
CREATE FUNCTION policy.is_locked_out_till(user_id integer_strict)
RETURNS TIMESTAMP
AS
$$
BEGIN
    RETURN
    (
        SELECT MAX(policy.lock_outs.lock_out_till)::TIMESTAMP WITHOUT TIME ZONE FROM policy.lock_outs
        WHERE policy.lock_outs.user_id=$1
    );
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/policy/policy.is_restricted_mode.sql --<--<--
DROP FUNCTION IF EXISTS policy.is_restricted_mode();

CREATE FUNCTION policy.is_restricted_mode()
RETURNS boolean
AS
$$
BEGIN
    IF EXISTS
    (
        SELECT 0 FROM transactions.day_operation
        WHERE completed = false
        LIMIT 1
    ) THEN
        RETURN true;
    END IF;

    RETURN false;
END;
$$
LANGUAGE plpgsql;


/**************************************************************************************************************************
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
'########::'##:::::::'########:::'######:::'##::::'##:'##::: ##:'####:'########::::'########:'########::'######::'########:
 ##.... ##: ##::::::: ##.... ##:'##... ##:: ##:::: ##: ###:: ##:. ##::... ##..:::::... ##..:: ##.....::'##... ##:... ##..::
 ##:::: ##: ##::::::: ##:::: ##: ##:::..::: ##:::: ##: ####: ##:: ##::::: ##:::::::::: ##:::: ##::::::: ##:::..::::: ##::::
 ########:: ##::::::: ########:: ##::'####: ##:::: ##: ## ## ##:: ##::::: ##:::::::::: ##:::: ######:::. ######::::: ##::::
 ##.....::: ##::::::: ##.....::: ##::: ##:: ##:::: ##: ##. ####:: ##::::: ##:::::::::: ##:::: ##...:::::..... ##:::: ##::::
 ##:::::::: ##::::::: ##:::::::: ##::: ##:: ##:::: ##: ##:. ###:: ##::::: ##:::::::::: ##:::: ##:::::::'##::: ##:::: ##::::
 ##:::::::: ########: ##::::::::. ######:::. #######:: ##::. ##:'####:::: ##:::::::::: ##:::: ########:. ######::::: ##::::
..:::::::::........::..::::::::::......:::::.......:::..::::..::....:::::..:::::::::::..:::::........:::......::::::..:::::
--------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
**************************************************************************************************************************/

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/public/explode_array.sql --<--<--
DROP FUNCTION IF EXISTS explode_array(in_array anyarray);

CREATE FUNCTION explode_array(in_array anyarray) 
RETURNS SETOF anyelement as
$$
    SELECT ($1)[s] FROM generate_series(1,array_upper($1, 1)) AS s;
$$
LANGUAGE sql 
IMMUTABLE;

--select * from explode_array(ARRAY[ROW(1, 1)::FOO_TYPE,ROW(1, 1)::FOO_TYPE])

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.are_sales_orders_already_merged.sql --<--<--
CREATE FUNCTION transactions.are_sales_orders_already_merged(VARIADIC arr bigint[])
RETURNS boolean
AS
$$
BEGIN
    IF
    (
        SELECT 
        COUNT(*) 
        FROM transactions.stock_master_non_gl_relations
        WHERE non_gl_stock_master_id = any($1)
    ) > 0 THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;   



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.are_sales_quotations_already_merged.sql --<--<--
CREATE FUNCTION transactions.are_sales_quotations_already_merged(VARIADIC arr bigint[])
RETURNS boolean
AS
$$
BEGIN
    IF
    (
        SELECT 
        COUNT(*) 
        FROM transactions.non_gl_stock_master_relations 
        WHERE quotation_non_gl_stock_master_id = any($1)
    ) > 0 THEN
        RETURN true;
    END IF;

    IF
    (
        SELECT 
        COUNT(*) 
        FROM transactions.stock_master_non_gl_relations
        WHERE non_gl_stock_master_id = any($1)
    ) > 0 THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;   



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.contains_incompatible_taxes.sql --<--<--
DROP FUNCTION IF EXISTS transactions.contains_incompatible_taxes(VARIADIC arr bigint[]);


CREATE FUNCTION transactions.contains_incompatible_taxes(VARIADIC arr bigint[])
RETURNS boolean
AS
$$
BEGIN
    IF
    (
        SELECT COUNT(DISTINCT non_taxable) FROM transactions.non_gl_stock_master
        WHERE non_gl_stock_master_id = any($1)
    ) > 1 THEN
        RETURN true;
    END IF;

    RETURN false;
END
$$
LANGUAGE plpgsql;   





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_default_currency_code.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_default_currency_code(cash_repository_id integer);

CREATE FUNCTION transactions.get_default_currency_code(cash_repository_id integer)
RETURNS national character varying(12)
AS
$$
BEGIN
    RETURN
    (
        SELECT office.offices.currency_code 
        FROM office.cash_repositories
        INNER JOIN office.offices
        ON office.offices.office_id = office.cash_repositories.office_id
        WHERE office.cash_repositories.cash_repository_id=$1
        
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_default_currency_code_by_office_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_default_currency_code_by_office_id(office_id integer);

CREATE FUNCTION transactions.get_default_currency_code_by_office_id(office_id integer)
RETURNS national character varying(12)
AS
$$
BEGIN
    RETURN
    (
        SELECT office.offices.currency_code 
        FROM office.offices
        WHERE office.offices.office_id = $1
        
    );
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_exchange_rate.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_exchange_rate(office_id integer, currency_code national character varying(12));

CREATE FUNCTION transactions.get_exchange_rate(office_id integer, currency_code national character varying(12))
RETURNS decimal_strict2
AS
$$
    DECLARE _local_currency_code national character varying(12)= '';
    DECLARE _unit integer_strict2 = 0;
    DECLARE _exchange_rate decimal_strict2=0;
BEGIN
    SELECT office.offices.currency_code
    INTO _local_currency_code
    FROM office.offices
    WHERE office.offices.office_id=$1;

    IF(_local_currency_code = $2) THEN
        RETURN 1;
    END IF;

    SELECT unit, exchange_rate
    INTO _unit, _exchange_rate
    FROM core.exchange_rate_details
    INNER JOIN core.exchange_rates
    ON core.exchange_rate_details.exchange_rate_id = core.exchange_rates.exchange_rate_id
    WHERE core.exchange_rates.office_id=$1
    AND foreign_currency_code=$2;

    IF(_unit = 0) THEN
        RETURN 0;
    END IF;
    
    RETURN _exchange_rate/_unit;    
END
$$
LANGUAGE plpgsql;

DROP FUNCTION IF EXISTS transactions.get_exchange_rate(office_id integer, source_currency_code national character varying(12), destination_currency_code national character varying(12));

CREATE FUNCTION transactions.get_exchange_rate(office_id integer, source_currency_code national character varying(12), destination_currency_code national character varying(12))
RETURNS decimal_strict2
AS
$$
    DECLARE _unit integer_strict2 = 0;
    DECLARE _exchange_rate decimal_strict2=0;
    DECLARE _from_source_currency decimal_strict2=0;
    DECLARE _from_destination_currency decimal_strict2=0;
BEGIN
    IF($2 = $3) THEN
        RETURN 1;
    END IF;


    _from_source_currency := transactions.get_exchange_rate($1, $2);
    _from_destination_currency := transactions.get_exchange_rate($1, $3);
        
    RETURN _from_source_currency / _from_destination_currency ; 
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_invoice_amount.sql --<--<--

CREATE FUNCTION transactions.get_invoice_amount(transaction_master_id_ bigint)
RETURNS money_strict2
AS
$$
DECLARE _shipping_charge money_strict2;
DECLARE _stock_total money_strict2;
BEGIN
    SELECT SUM((quantity * price) + tax - discount) INTO _stock_total
    FROM transactions.stock_details
    WHERE transactions.stock_details.stock_master_id =
    (
        SELECT transactions.stock_master.stock_master_id
        FROM transactions.stock_master WHERE transactions.stock_master.transaction_master_id= $1
    );

    SELECT shipping_charge INTO _shipping_charge
    FROM transactions.stock_master
    WHERE transactions.stock_master.transaction_master_id=$1;

    RETURN COALESCE(_stock_total + _shipping_charge, 0::money_strict2); 
END
$$
LANGUAGE plpgsql;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_new_transaction_counter.sql --<--<--

/*******************************************************************
    THIS FUNCTION RETURNS A NEW INCREMENTAL COUNTER SUBJECT 
    TO BE USED TO GENERATE TRANSACTION CODES
*******************************************************************/

CREATE FUNCTION transactions.get_new_transaction_counter(date)
RETURNS integer
AS
$$
    DECLARE _ret_val integer;
BEGIN
    SELECT INTO _ret_val
        COALESCE(MAX(transaction_counter),0)
    FROM transactions.transaction_master
    WHERE value_date=$1;

    IF _ret_val IS NULL THEN
        RETURN 1::integer;
    ELSE
        RETURN (_ret_val + 1)::integer;
    END IF;
END;
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_stock_master_id_by_transaction_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_stock_master_id_by_transaction_master_id(_stock_master_id bigint);

CREATE FUNCTION transactions.get_stock_master_id_by_transaction_master_id(_stock_master_id bigint)
RETURNS bigint
AS
$$
BEGIN
        RETURN
        (
                SELECT transactions.stock_master.stock_master_id
                FROM transactions.stock_master
                WHERE transactions.stock_master.transaction_master_id=$1
        );
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_transaction_code.sql --<--<--
CREATE FUNCTION transactions.get_transaction_code(value_date date, office_id integer, user_id integer, login_id bigint)
RETURNS text
AS
$$
    DECLARE _office_id bigint:=$2;
    DECLARE _user_id integer:=$3;
    DECLARE _login_id bigint:=$4;
    DECLARE _ret_val text;  
BEGIN
    _ret_val:= transactions.get_new_transaction_counter($1)::text || '-' || TO_CHAR($1, 'YYYY-MM-DD') || '-' || CAST(_office_id as text) || '-' || CAST(_user_id as text) || '-' || CAST(_login_id as text)   || '-' ||  TO_CHAR(now(), 'HH24-MI-SS');
    RETURN _ret_val;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.get_transaction_master_id_by_stock_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.get_transaction_master_id_by_stock_master_id(_stock_master_id bigint);

CREATE FUNCTION transactions.get_transaction_master_id_by_stock_master_id(_stock_master_id bigint)
RETURNS bigint
AS
$$
BEGIN
        RETURN
        (
                SELECT transactions.stock_master.transaction_master_id
                FROM transactions.stock_master
                WHERE transactions.stock_master.stock_master_id=$1
        );
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.has_nexus.sql --<--<--
CREATE FUNCTION transactions.has_nexus(_state_id integer)
RETURNS boolean
AS
$$
BEGIN
    RETURN false;--Todo
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_normally_debit.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_normally_debit(_account_id bigint);

CREATE FUNCTION transactions.is_normally_debit(_account_id bigint)
RETURNS boolean
AS
$$
BEGIN
    RETURN
        core.account_masters.normally_debit
    FROM  core.accounts
    INNER JOIN core.account_masters
    ON core.accounts.account_master_id = core.account_masters.account_master_id
    WHERE account_id = $1;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_purchase.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_purchase(_transaction_master_id bigint);

CREATE FUNCTION transactions.is_purchase(_transaction_master_id bigint)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS
        (
                SELECT * FROM transactions.transaction_master
                WHERE transactions.transaction_master.transaction_master_id = $1
                AND book IN ('Purchase.Direct', 'Purchase.Receipt')
        ) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_valid_party_by_stock_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_valid_party_by_stock_master_id(_stock_master_id bigint, _party_id bigint);

CREATE FUNCTION transactions.is_valid_party_by_stock_master_id(_stock_master_id bigint, _party_id bigint)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT * FROM transactions.stock_master WHERE stock_master_id=$1 AND party_id=$2) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_valid_party_by_transaction_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_valid_party_by_transaction_master_id(_transaction_master_id bigint, _party_id bigint);

CREATE FUNCTION transactions.is_valid_party_by_transaction_master_id(_transaction_master_id bigint, _party_id bigint)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT * FROM transactions.stock_master WHERE transaction_master_id=$1 AND party_id=$2) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_valid_stock_transaction_by_stock_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_valid_stock_transaction_by_stock_master_id(_stock_master_id bigint);

CREATE FUNCTION transactions.is_valid_stock_transaction_by_stock_master_id(_stock_master_id bigint)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT * FROM transactions.stock_master WHERE stock_master_id=$1) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/02.functions-and-logic/transactions/transactions.is_valid_stock_transaction_by_transaction_master_id.sql --<--<--
DROP FUNCTION IF EXISTS transactions.is_valid_stock_transaction_by_transaction_master_id(_transaction_master_id bigint);

CREATE FUNCTION transactions.is_valid_stock_transaction_by_transaction_master_id(_transaction_master_id bigint)
RETURNS boolean
AS
$$
BEGIN
        IF EXISTS(SELECT * FROM transactions.stock_master WHERE transaction_master_id=$1) THEN
                RETURN true;
        END IF;

        RETURN false;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/04.default-values/default.sql --<--<--
INSERT INTO core.attachment_lookup(book, resource, resource_key)
SELECT 'transaction',           'transactions.transaction_master',  'transaction_master_id' UNION ALL
SELECT 'non-gl-transaction',    'transactions.non_gl_stock_master', 'non_gl_stock_master_id';


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/04.default-values/policy-config.sql --<--<--
--This table should not be localized
INSERT INTO core.config
SELECT 1, 'Inventory System' UNION ALL
SELECT 2, 'COGS Calculation Method';

--This table should not be localized
INSERT INTO office.configuration(config_id, office_id, value, configuration_details)
SELECT 1, office_id, 'Perpetual', ''
FROM office.offices
WHERE parent_office_id IS NOT NULL;

--This table should not be localized
INSERT INTO office.configuration(config_id, office_id, value, configuration_details)
SELECT 2, office_id, 'LIFO', ''
FROM office.offices
WHERE parent_office_id IS NOT NULL;





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/04.default-values/widgets.sql --<--<--
--This table should not be localized.
INSERT INTO core.widgets(widget_name, widget_source, row_number, column_number)
SELECT 'SalesByGeographyWidget',                    '/Modules/Sales/Widgets/SalesByGeographyWidget.ascx',                   1, 1 UNION ALL
SELECT 'SalesByOfficeWidget',                       '/Modules/Sales/Widgets/SalesByOfficeWidget.ascx',                      2, 1 UNION ALL
SELECT 'CurrentOfficeSalesByMonthWidget',           '/Modules/Sales/Widgets/CurrentOfficeSalesByMonthWidget.ascx',          2, 2 UNION ALL
SELECT 'OfficeInformationWidget',                   '/Modules/BackOffice/Widgets/OfficeInformationWidget.ascx',             3, 1 UNION ALL
SELECT 'LinksWidget',                               '/Modules/BackOffice/Widgets/LinksWidget.ascx',                         3, 2 UNION ALL
SELECT 'WorkflowWidget',                            '/Modules/Finance/Widgets/WorkflowWidget.ascx',                         3, 4 UNION ALL
SELECT 'TopSellingProductOfAllTimeWidget',          '/Modules/Sales/Widgets/TopSellingProductOfAllTimeWidget.ascx',         4, 1 UNION ALL
SELECT 'TopSellingProductOfAllTimeCurrentWidget',   '/Modules/Sales/Widgets/TopSellingProductOfAllTimeCurrentWidget.ascx',  4, 2;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.account_scrud_view.sql --<--<--
CREATE VIEW core.account_scrud_view
AS
SELECT
    core.accounts.account_id,
    core.account_masters.account_master_code || ' (' || core.account_masters.account_master_name || ')' AS account_master,
    core.accounts.account_number,
    core.accounts.external_code,
	core.currencies.currency_code || ' ('|| core.currencies.currency_name|| ')' currency,
    core.accounts.account_name,
    core.accounts.description,
	core.accounts.confidential,
	core.accounts.is_transaction_node,
    core.accounts.sys_type,
    parent_account.account_number || ' (' || parent_account.account_name || ')' AS parent
    
FROM core.accounts
INNER JOIN core.account_masters
ON core.account_masters.account_master_id=core.accounts.account_master_id
INNER JOIN core.currencies
ON core.accounts.currency_code = core.currencies.currency_code
LEFT JOIN core.accounts parent_account
ON parent_account.account_id=core.accounts.parent_account_id
WHERE NOT core.accounts.sys_type;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.ageing_slab_scrud_view.sql --<--<--
CREATE VIEW core.ageing_slab_scrud_view
AS
SELECT 
  ageing_slabs.ageing_slab_id, 
  ageing_slabs.ageing_slab_name, 
  ageing_slabs.from_days, 
  ageing_slabs.to_days
FROM 
  core.ageing_slabs;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.bank_accounts_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.bank_accounts_scrud_view;
CREATE VIEW core.bank_accounts_scrud_view
AS
SELECT 
    core.bank_accounts.account_id,
    office.users.user_name,
    office.offices.office_code || '(' || office.offices.office_name||')' AS office_name,
	core.bank_accounts.bank_name,
	core.bank_accounts.bank_branch,
	core.bank_accounts.bank_contact_number,
	core.bank_accounts.bank_address,
	core.bank_accounts.bank_account_number,
	core.bank_accounts.bank_account_type,
	core.bank_accounts.relationship_officer_name
FROM
    core.bank_accounts
INNER JOIN office.users
ON core.bank_accounts.maintained_by_user_id = office.users.user_id
INNER JOIN office.offices
ON core.bank_accounts.office_id = office.offices.office_id; 

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.bonus_slab_detail_scrud_view.sql --<--<--
CREATE VIEW core.bonus_slab_detail_scrud_view
AS
SELECT
    bonus_slab_detail_id,
    core.bonus_slab_details.bonus_slab_id,
    core.bonus_slabs.bonus_slab_name AS slab_name,
    amount_from,
    amount_to,
    bonus_rate
FROM
    core.bonus_slab_details,
    core.bonus_slabs
WHERE
    core.bonus_slab_details.bonus_slab_id = core.bonus_slabs.bonus_slab_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.bonus_slab_scrud_view.sql --<--<--
CREATE VIEW core.bonus_slab_scrud_view
AS
SELECT
    core.bonus_slabs.bonus_slab_id,
    core.bonus_slabs.bonus_slab_code,
    core.bonus_slabs.bonus_slab_name,
    core.bonus_slabs.effective_from,
    core.bonus_slabs.ends_on,
    core.frequencies.frequency_code || '('||core.frequencies.frequency_name||')' AS checking_frequency
FROM
core.bonus_slabs
INNER JOIN core.frequencies
ON core.bonus_slabs.checking_frequency_id = core.frequencies.frequency_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.brand_scrud_view.sql --<--<--
CREATE VIEW core.brand_scrud_view
AS
SELECT 
        brand_id,
        brand_code,
        brand_name
FROM core.brands;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.cash_flow_heading_scrud_view.sql --<--<--
CREATE VIEW core.cash_flow_heading_scrud_view
AS
SELECT 
  core.cash_flow_headings.cash_flow_heading_id, 
  core.cash_flow_headings.cash_flow_heading_code, 
  core.cash_flow_headings.cash_flow_heading_name, 
  core.cash_flow_headings.cash_flow_heading_type, 
  core.cash_flow_headings.is_debit, 
  core.cash_flow_headings.is_sales, 
  core.cash_flow_headings.is_purchase
FROM 
  core.cash_flow_headings;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.cash_flow_setup_scrud_view.sql --<--<--
CREATE VIEW core.cash_flow_setup_scrud_view
AS
SELECT 
 core.cash_flow_setup.cash_flow_setup_id, 
 core.cash_flow_headings.cash_flow_heading_code || '('|| core.cash_flow_headings.cash_flow_heading_name||')' AS cash_flow_heading, 
 core.account_masters.account_master_code || '('|| core.account_masters.account_master_name||')' AS account_master
FROM 
core.cash_flow_setup
INNER JOIN core.cash_flow_headings
ON  core.cash_flow_setup.cash_flow_heading_id =core.cash_flow_headings.cash_flow_heading_id
INNER JOIN core.account_masters
ON core.cash_flow_setup.account_master_id = core.account_masters.account_master_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.compound_item_detail_scrud_view.sql --<--<--
CREATE VIEW core.compound_item_detail_scrud_view
AS
SELECT
        compound_item_detail_id,
        core.compound_item_details.compound_item_id,
        core.compound_items.compound_item_code,
        core.compound_items.compound_item_name,
        item_id,
        core.get_item_name_by_item_id(item_id) AS item,
        core.get_unit_name_by_unit_id(unit_id) AS unit,
        quantity
FROM core.compound_item_details
INNER JOIN core.compound_items
ON core.compound_item_details.compound_item_id = core.compound_items.compound_item_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.compound_item_scrud_view.sql --<--<--
CREATE VIEW core.compound_item_scrud_view
AS
SELECT 
        compound_item_id,
        compound_item_code,
        compound_item_name
FROM core.compound_items;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.compound_unit_scrud_view.sql --<--<--
CREATE VIEW core.compound_unit_scrud_view
AS
SELECT
    compound_unit_id,
    base_unit.unit_name base_unit_name,
    value,
    compare_unit.unit_name compare_unit_name
FROM
    core.compound_units,
    core.units base_unit,
    core.units compare_unit
WHERE
    core.compound_units.base_unit_id = base_unit.unit_id
AND
    core.compound_units.compare_unit_id = compare_unit.unit_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.country_scrud_view.sql --<--<--
CREATE VIEW core.country_scrud_view
AS
SELECT 
  core.countries.country_id, 
  core.countries.country_code, 
  core.countries.country_name
FROM 
  core.countries;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.county_sales_tax_scrud_view.sql --<--<--
CREATE VIEW core.county_sales_tax_scrud_view
AS
SELECT 
    core.county_sales_taxes.county_sales_tax_id,   
    core.county_sales_taxes.county_sales_tax_code,
    core.county_sales_taxes.county_sales_tax_name,
    core.counties.county_code ||'('||  core.counties.county_name || ')' AS county,
    core.entities.entity_name,
    core.industries.industry_name,
    core.item_groups.item_group_code ||'(' ||  core.item_groups.item_group_name  || ')' AS item_group,
    core.county_sales_taxes.rate
FROM
    core.county_sales_taxes
LEFT JOIN core.counties
ON core.county_sales_taxes.county_id=core.counties.county_id
LEFT JOIN core.entities
ON core.county_sales_taxes.entity_id=core.entities.entity_id
LEFT JOIN core.industries
ON core.county_sales_taxes.industry_id=core.industries.industry_id
LEFT JOIN core.item_groups
ON core.county_sales_taxes.item_group_id=core.item_groups.item_group_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.county_scrud_view.sql --<--<--
CREATE VIEW core.county_scrud_view
AS
SELECT 
  core.counties.county_id, 
  core.counties.county_code, 
  core.counties.county_name, 
  core.states.state_code || '('|| core.states.state_name||')' AS state
FROM 
  core.counties
INNER JOIN  core.states
ON core.counties.state_id = core.states.state_id;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.currency_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.currency_scrud_view;
CREATE VIEW core.currency_scrud_view
AS
SELECT 
  core.currencies.currency_code, 
  core.currencies.currency_symbol, 
  core.currencies.currency_name, 
  core.currencies.hundredth_name
FROM 
  core.currencies;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.entity_scrud_view.sql --<--<--
CREATE VIEW core.entity_scrud_view
AS
SELECT
core.entities.entity_id,
core.entities.entity_name
FROM
core.entities; 

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.fiscal_year_scrud_view.sql --<--<--
CREATE VIEW core.fiscal_year_scrud_view
AS
SELECT 
  core.fiscal_year.fiscal_year_code, 
  core.fiscal_year.fiscal_year_name, 
  core.fiscal_year.starts_from, 
  core.fiscal_year.ends_on
FROM 
  core.fiscal_year;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.flag_type_scrud_view.sql --<--<--
CREATE VIEW core.flag_type_scrud_view
AS
SELECT 
  flag_types.flag_type_id, 
  flag_types.flag_type_name, 
  flag_types.background_color, 
  flag_types.foreground_color
FROM 
  core.flag_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.frequency_setup_scrud_view.sql --<--<--
CREATE VIEW core.frequency_setup_scrud_view
AS
SELECT 
        frequency_setup_id,
        fiscal_year_code,
        value_date,
        core.get_frequency_code_by_frequency_id(frequency_id) AS frequency_code
FROM core.frequency_setups;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.industry_scrud_view.sql --<--<--
CREATE VIEW core.industry_scrud_view
AS          
SELECT 
    core.industries.industry_id, 
    core.industries.industry_name,
    parent_industry.industry_name AS parent_industry_name
FROM core.industries
LEFT JOIN core.industries AS parent_industry
ON core.industries.parent_industry_id = parent_industry.industry_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.item_cost_price_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.item_cost_price_scrud_view;

CREATE VIEW core.item_cost_price_scrud_view
AS
SELECT
    core.item_cost_prices.item_cost_price_id,
    core.items.item_code,
    core.items.item_name,
    core.parties.party_code,
    core.parties.party_name,
    unit_code || ' (' || unit_name || ')' AS unit,
    core.item_cost_prices.price
FROM 
core.item_cost_prices
INNER JOIN core.items
ON core.item_cost_prices.item_id = core.items.item_id
INNER JOIN core.units
ON core.item_cost_prices.unit_id = core.units.unit_id
LEFT JOIN core.parties
ON core.item_cost_prices.party_id = core.parties.party_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.item_group_scrud_view.sql --<--<--
CREATE VIEW core.item_group_scrud_view
AS
SELECT 
        core.item_groups.item_group_id,
        core.item_groups.item_group_code,
        core.item_groups.item_group_name,
        core.item_groups.exclude_from_purchase,
        core.item_groups.exclude_from_sales,
        sales_tax_code || ' (' || sales_tax_name || ')' AS sales_tax,
        parent_item_group.item_group_code || ' (' || parent_item_group.item_group_name || ')' AS parent        
FROM core.item_groups
INNER JOIN core.sales_taxes
ON core.item_groups.sales_tax_id = sales_taxes.sales_tax_id
LEFT JOIN core.item_groups AS parent_item_group
ON core.item_groups.parent_item_group_id = parent_item_group.item_group_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.item_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.item_scrud_view;

CREATE VIEW core.item_scrud_view
AS
SELECT 
        item_id,
        item_code,
        item_name,
        item_group_code || ' (' || item_group_name || ')' AS item_group,
        maintain_stock,
        brand_code || ' (' || brand_name || ')' AS brand,
        party_code || ' (' || party_name || ')' AS preferred_supplier,
        lead_time_in_days,
        weight_in_grams,
        width_in_centimeters,
        height_in_centimeters,
        length_in_centimeters,
        machinable,
        shipping_mail_type_code || ' (' || shipping_mail_type_name || ')' AS preferred_shipping_mail_type,
        shipping_package_shape_code || ' (' || shipping_package_shape_name || ')' AS preferred_shipping_package_shape,
        core.units.unit_code || ' (' || core.units.unit_name || ')' AS unit,
        hot_item,
        cost_price,
        cost_price_includes_tax,
        selling_price,
        selling_price_includes_tax,
        sales_tax_code || ' (' || sales_tax_name || ')' AS sales_tax,
        reorder_unit.unit_code || ' (' || reorder_unit.unit_name || ')' AS reorder_unit,
        reorder_level,
        reorder_quantity
FROM core.items
INNER JOIN core.item_groups
ON core.items.item_group_id = core.item_groups.item_group_id
INNER JOIN core.brands
ON core.items.brand_id = core.brands.brand_id
INNER JOIN core.parties
ON core.items.preferred_supplier_id = core.parties.party_id
INNER JOIN core.units
ON core.items.unit_id = core.units.unit_id
INNER JOIN core.units AS reorder_unit
ON core.items.reorder_unit_id = reorder_unit.unit_id
INNER JOIN core.sales_taxes
ON core.items.sales_tax_id = core.sales_taxes.sales_tax_id
LEFT JOIN core.shipping_mail_types
ON core.items.preferred_shipping_mail_type_id = core.shipping_mail_types.shipping_mail_type_id
LEFT JOIN core.shipping_package_shapes
ON core.items.shipping_package_shape_id = core.shipping_package_shapes.shipping_package_shape_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.item_selling_price_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.item_selling_price_scrud_view;

CREATE VIEW core.item_selling_price_scrud_view
AS
SELECT
    core.item_selling_prices.item_selling_price_id,
    core.items.item_code,
    core.items.item_name,
    core.party_types.party_type_code,
    core.party_types.party_type_name,
    unit_code || ' (' || unit_name || ')' AS unit,
    price
FROM
    core.item_selling_prices
INNER JOIN  core.items
ON core.item_selling_prices.item_id = core.items.item_id
INNER JOIN core.units
ON core.item_selling_prices.unit_id = core.units.unit_id
LEFT JOIN core.price_types
ON core.item_selling_prices.price_type_id = core.price_types.price_type_id
LEFT JOIN core.party_types
ON  core.item_selling_prices.party_type_id = core.party_types.party_type_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.item_type_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.item_type_scrud_view;
CREATE VIEW core.item_type_scrud_view
AS
SELECT 
  core.item_types.item_type_id, 
  core.item_types.item_type_code, 
  core.item_types.item_type_name
FROM 
  core.item_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.late_fee_scrud_view.sql --<--<--
CREATE VIEW core.late_fee_scrud_view
AS
SELECT 
  late_fee.late_fee_id, 
  late_fee.late_fee_code, 
  late_fee.late_fee_name, 
  late_fee.is_flat_amount, 
  late_fee.rate
FROM 
  core.late_fee;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.party_scrud_view.sql --<--<--
CREATE VIEW core.party_scrud_view
AS
SELECT
    core.parties.party_id,
    core.party_types.party_type_id,
    core.party_types.is_supplier,
    core.party_types.party_type_code || ' (' || core.party_types.party_type_name || ')' AS party_type,
    core.parties.party_code,
    core.parties.first_name,
    core.parties.middle_name,
    core.parties.last_name,
    core.parties.party_name,
    core.parties.zip_code,
    core.parties.address_line_1,
    core.parties.address_line_2,
    core.parties.street,
    core.parties.city,
    core.get_state_name_by_state_id(core.parties.state_id) AS state,
    core.get_country_name_by_country_id(core.parties.country_id) AS country,
    core.parties.allow_credit,
    core.parties.maximum_credit_period,
    core.parties.maximum_credit_amount,
    core.parties.pan_number,
    core.parties.sst_number,
    core.parties.cst_number,
    core.parties.phone,
    core.parties.fax,
    core.parties.cell,
    core.parties.email,
    core.parties.url,
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_number || ' (' || core.accounts.account_name || ')' AS gl_head
FROM
core.parties
INNER JOIN
core.party_types
ON core.parties.party_type_id = core.party_types.party_type_id
INNER JOIN core.accounts
ON core.parties.account_id=core.accounts.account_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.party_type_scrud_view.sql --<--<--
CREATE VIEW core.party_type_scrud_view
AS
SELECT 
        party_type_id,
        party_type_code,
        party_type_name,
        is_supplier
FROM core.party_types;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.payment_term_scrud_view.sql --<--<--
CREATE VIEW core.payment_term_scrud_view
AS
SELECT
    core.payment_terms.payment_term_id,
    core.payment_terms.payment_term_code,
    core.payment_terms.payment_term_name,
    core.payment_terms.due_on_date,
    core.payment_terms.due_days,
    due_frequency.frequency_code || ' (' || due_frequency.frequency_name || ')' AS due_frequency,
    core.payment_terms.grace_peiod,
    core.late_fee.late_fee_code || '(' || core.late_fee.late_fee_name || ')' AS late_fee,
    late_fee_posting_frequency.frequency_code || ' (' || late_fee_posting_frequency.frequency_name || ')' AS late_fee_posting_frequency
FROM core.payment_terms
LEFT JOIN core.frequencies AS due_frequency
ON core.payment_terms.due_frequency_id=due_frequency.frequency_id
LEFT JOIN core.frequencies AS late_fee_posting_frequency 
ON core.payment_terms.late_fee_posting_frequency_id=late_fee_posting_frequency.frequency_id
LEFT JOIN core.late_fee
ON core.payment_terms.late_fee_id=core.late_fee.late_fee_id;





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.recurring_invoice_scrud_view.sql --<--<--
CREATE VIEW core.recurring_invoice_scrud_view
AS
SELECT 
  core.recurring_invoices.recurring_invoice_id, 
  core.recurring_invoices.recurring_invoice_code, 
  core.recurring_invoices.recurring_invoice_name,
  core.items.item_code || '('|| core.items.item_name||')' AS item,
  core.compound_items.compound_item_code || ' (' || core.compound_items.compound_item_name || ')' AS compound_item,
  core.frequencies.frequency_code || '('|| core.frequencies.frequency_name||')' AS recurring_frequency,
  core.recurring_invoices.recurring_amount, 
  core.recurring_invoices.auto_trigger_on_sales
FROM 
  core.recurring_invoices
LEFT JOIN core.items 
ON core.recurring_invoices.item_id = core.items.item_id
INNER JOIN core.frequencies
ON core.recurring_invoices.recurring_frequency_id = core.frequencies.frequency_id
LEFT JOIN core.compound_items
ON core.recurring_invoices.compound_item_id=core.compound_items.compound_item_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.recurring_invoice_setup_scrud_view.sql --<--<--
DROP VIEW IF EXISTS core.recurring_invoice_setup_scrud_view;
CREATE VIEW core.recurring_invoice_setup_scrud_view
AS
SELECT 
  core.recurring_invoice_setup.recurring_invoice_setup_id, 
  core.recurring_invoices.recurring_invoice_code || ' (' || core.recurring_invoices.recurring_invoice_name || ')' AS recurring_invoice,
  core.parties.party_code || ' (' || core.parties.party_name || ')' AS party,
  core.recurring_invoice_setup.starts_from, 
  core.recurring_invoice_setup.ends_on, 
  core.recurring_invoice_setup.recurring_amount, 
  core.payment_terms.payment_term_code || ' (' || core.payment_terms.payment_term_name || ')' AS payment_term
FROM 
  core.recurring_invoice_setup
INNER JOIN core.recurring_invoices
ON core.recurring_invoice_setup.recurring_invoice_id = core.recurring_invoices.recurring_invoice_id
INNER JOIN core.parties ON 
core.recurring_invoice_setup.party_id = core.parties.party_id
INNER JOIN core.payment_terms ON 
core.recurring_invoice_setup.payment_term_id = core.payment_terms.payment_term_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_tax_detail_scrud_view.sql --<--<--
CREATE VIEW core.sales_tax_detail_scrud_view
AS
SELECT 
  core.sales_tax_details.sales_tax_detail_id, 
  core.sales_taxes.sales_tax_code || ' ('|| core.sales_taxes.sales_tax_name||')' AS sales_tax,
  core.sales_tax_types.sales_tax_type_code || ' ('|| core.sales_tax_types.sales_tax_type_name||')' AS sales_tax_type, 
  core.sales_tax_details.priority,
  core.sales_tax_details.sales_tax_detail_code, 
  core.sales_tax_details.sales_tax_detail_name, 
  core.sales_tax_details.based_on_shipping_address, 
  core.sales_tax_details.check_nexus, 
  core.sales_tax_details.applied_on_shipping_charge, 
  core.state_sales_taxes.state_sales_tax_code || ' ('|| core.state_sales_taxes.state_sales_tax_name||')' AS state_sales_tax, 
  core.county_sales_taxes.county_sales_tax_code || ' (' || core.county_sales_taxes.county_sales_tax_name||')' AS county_sales_tax, 
  core.tax_rate_types.tax_rate_type_code || '('|| core.tax_rate_types.tax_rate_type_name||')' AS tax_rate_type,  
  core.sales_tax_details.rate,
  reporting_tax_authority.tax_authority_code || ' (' || reporting_tax_authority.tax_authority_name||')' AS reporting_tax_authority, 
  collecting_tax_authority.tax_authority_code || ' (' || collecting_tax_authority.tax_authority_name||')' AS collecting_tax_authority,
  collecting_account.account_number || '  ('|| collecting_account.account_name||')' AS collecting_account,
  use_tax_collecting_account.account_number || '  ('|| use_tax_collecting_account.account_name||')' AS use_tax_collecting_account,
  core.rounding_methods.rounding_method_code || '('|| core.rounding_methods.rounding_method_name||')' AS rounding_method,
  core.sales_tax_details.rounding_decimal_places

FROM 
   core.sales_tax_details
INNER JOIN core.sales_taxes
ON core.sales_tax_details.sales_tax_id = core.sales_taxes.sales_tax_id 
INNER JOIN core.sales_tax_types
ON core.sales_tax_details.sales_tax_type_id = core.sales_tax_types.sales_tax_type_id
LEFT JOIN core.state_sales_taxes
ON core.sales_tax_details.state_sales_tax_id = core.state_sales_taxes.state_sales_tax_id
LEFT JOIN core.county_sales_taxes
ON core.sales_tax_details.county_sales_tax_id = core.county_sales_taxes.county_sales_tax_id
INNER JOIN core.tax_rate_types
ON  core.sales_tax_details.tax_rate_type_code  = core.tax_rate_types.tax_rate_type_code
INNER JOIN core.tax_authorities AS reporting_tax_authority
ON core.sales_tax_details.reporting_tax_authority_id = reporting_tax_authority.tax_authority_id
INNER JOIN core.tax_authorities AS collecting_tax_authority
ON core.sales_tax_details.collecting_tax_authority_id = collecting_tax_authority.tax_authority_id
INNER JOIN core.accounts AS collecting_account
ON core.sales_tax_details.collecting_account_id = collecting_account.account_id
LEFT JOIN core.accounts AS use_tax_collecting_account
ON core.sales_tax_details.use_tax_collecting_account_id = use_tax_collecting_account.account_id
LEFT JOIN core.rounding_methods
ON core.sales_tax_details.rounding_method_code = core.rounding_methods.rounding_method_code;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_tax_exempt_detail_scrud_view.sql --<--<--
CREATE VIEW core.sales_tax_exempt_detail_scrud_view
AS
SELECT 
  core.sales_tax_exempt_details.sales_tax_exempt_detail_id, 
  core.sales_tax_exempts.sales_tax_exempt_code || '('|| core.sales_tax_exempts.sales_tax_exempt_name ||')' AS sales_tax_exempt,  
  core.entities.entity_name, 
  core.industries.industry_name, 
  core.parties.party_code || '(' || core.parties.party_name ||')' AS party, 
  core.party_types.party_type_code || '('|| core.party_types.party_type_name ||')' AS party_type, 
  core.items.item_code || '('|| core.items.item_name ||')' AS item, 
  core.item_groups.item_group_code || '('|| core.item_groups.item_group_name ||')' AS item_group
FROM 
  core.sales_tax_exempt_details
LEFT JOIN core.sales_tax_exempts
ON core.sales_tax_exempt_details.sales_tax_exempt_id = core.sales_tax_exempts.sales_tax_exempt_id
LEFT JOIN core.entities
ON core.sales_tax_exempt_details.entity_id = core.entities.entity_id
LEFT JOIN core.industries
ON core.sales_tax_exempt_details.industry_id = core.industries.industry_id
LEFT JOIN  core.parties
ON core.sales_tax_exempt_details.party_id = core.parties.party_id
LEFT JOIN core.party_types
ON core.sales_tax_exempt_details.party_type_id = core.party_types.party_type_id
LEFT JOIN core.items
ON core.sales_tax_exempt_details.item_id = core.items.item_id
LEFT JOIN core.item_groups
ON core.sales_tax_exempt_details.item_group_id = core.item_groups.item_group_id;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_tax_exempt_scrud_view.sql --<--<--
CREATE VIEW core.sales_tax_exempt_scrud_view
AS 
SELECT 
  core.sales_tax_exempts.sales_tax_exempt_id, 
  core.tax_master.tax_master_code || '('|| core.tax_master.tax_master_name||')' AS tax_master, 
  core.sales_tax_exempts.sales_tax_exempt_code, 
  core.sales_tax_exempts.sales_tax_exempt_name, 
  core.tax_exempt_types.tax_exempt_type_code || '('|| core.tax_exempt_types.tax_exempt_type_name||')' AS tax_exempt_type,
  office.stores.store_code || '('|| office.stores.store_name||')' AS store,
  core.sales_taxes.sales_tax_code || '('|| core.sales_taxes.sales_tax_name||')' AS sales_tax, 
  core.sales_tax_exempts.valid_from, 
  core.sales_tax_exempts.valid_till, 
  core.sales_tax_exempts.price_from, 
  core.sales_tax_exempts.price_to
FROM 
  core.sales_tax_exempts
INNER JOIN core.tax_master
ON core.sales_tax_exempts.tax_master_id = core.tax_master.tax_master_id
INNER JOIN core.tax_exempt_types
ON core.sales_tax_exempts.tax_exempt_type_id = core.tax_exempt_types.tax_exempt_type_id
INNER JOIN office.stores
ON core.sales_tax_exempts.store_id = office.stores.store_id
INNER JOIN core.sales_taxes
ON core.sales_tax_exempts.sales_tax_id = core.sales_taxes.sales_tax_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_tax_scrud_view.sql --<--<--
CREATE VIEW core.sales_tax_scrud_view
AS
SELECT 
  core.sales_taxes.sales_tax_id, 
  core.tax_master.tax_master_code || ' (' || core.tax_master.tax_master_name||')' AS tax_master, 
  office.offices.office_code || ' (' || offices.office_name||')' AS office, 
  core.sales_taxes.sales_tax_code, 
  core.sales_taxes.sales_tax_name, 
  core.sales_taxes.is_exemption, 
  core.tax_base_amount_types.tax_base_amount_type_code || '('|| core.tax_base_amount_types.tax_base_amount_type_name||')' AS tax_base_amount,
  core.sales_taxes.rate
FROM 
  core.sales_taxes 
INNER JOIN core.tax_master
ON sales_taxes.tax_master_id = tax_master.tax_master_id
INNER JOIN office.offices
ON  sales_taxes.office_id = offices.office_id 
INNER JOIN core.tax_base_amount_types 
ON sales_taxes.tax_base_amount_type_code = tax_base_amount_types.tax_base_amount_type_code;





-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_tax_type_scrud_view.sql --<--<--
CREATE VIEW core.sales_tax_type_scrud_view
AS
SELECT 
  core.sales_tax_types.sales_tax_type_id, 
  core.sales_tax_types.sales_tax_type_code, 
  core.sales_tax_types.sales_tax_type_name, 
  core.sales_tax_types.is_vat
FROM 
  core.sales_tax_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.sales_team_scrud_view.sql --<--<--
CREATE VIEW core.sales_team_scrud_view
AS
SELECT 
        sales_team_id,
        sales_team_code,
        sales_team_name
FROM core.sales_teams;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.salesperson_bonus_setup_scrud_view.sql --<--<--
CREATE VIEW core.salesperson_bonus_setup_scrud_view
AS
SELECT
    salesperson_bonus_setup_id,
    salesperson_name,
    bonus_slab_name
FROM
    core.salesperson_bonus_setups,
    core.salespersons,
    core.bonus_slabs
WHERE
    core.salesperson_bonus_setups.salesperson_id = core.salespersons.salesperson_id
AND
    core.salesperson_bonus_setups.bonus_slab_id = core.bonus_slabs.bonus_slab_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.salesperson_scrud_view.sql --<--<--
CREATE VIEW core.salesperson_scrud_view
AS
SELECT
    salesperson_id,
    salesperson_code,
    salesperson_name,
    address,
    contact_number,
    commission_rate,
    account_name
FROM
    core.salespersons,
    core.accounts
WHERE
    core.salespersons.account_id = core.accounts.account_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.shipper_scrud_view.sql --<--<--
CREATE VIEW core.shipper_scrud_view
AS
SELECT
        shipper_id,
        shipper_code,
        company_name,
        shipper_name,
        po_box,
        address_line_1,
        address_line_2,
        street,
        city,
        state,
        country,
        phone,
        fax,
        cell,
        email,
        url,
        contact_person,
        contact_po_box,
        contact_address_line_1,
        contact_address_line_2,
        contact_street,
        contact_city,
        contact_state,
        contact_country,
        contact_email,
        contact_phone,
        contact_cell,
        factory_address,
        pan_number,
        sst_number,
        cst_number,
        account_number || ' (' || account_name || ')' AS account
FROM core.shippers
INNER JOIN core.accounts
ON core.shippers.account_id = core.accounts.account_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.shipping_address_scrud_view.sql --<--<--
CREATE VIEW core.shipping_address_scrud_view
AS
SELECT
    core.shipping_addresses.shipping_address_id,
    core.shipping_addresses.shipping_address_code,
    core.parties.party_code || ' (' || core.parties.party_name || ')' AS party,
    core.shipping_addresses.zip_code,
    core.shipping_addresses.address_line_1,
    core.shipping_addresses.address_line_2,
    core.shipping_addresses.street,
    core.shipping_addresses.city,
    core.get_state_name_by_state_id(core.shipping_addresses.state_id) AS state,
    core.get_country_name_by_country_id(core.shipping_addresses.country_id) AS country
FROM core.shipping_addresses
INNER JOIN core.parties
ON core.shipping_addresses.party_id=core.parties.party_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.state_sales_tax_scrud_view.sql --<--<--
CREATE VIEW core.state_sales_tax_scrud_view
AS
SELECT 
    core.state_sales_taxes.state_sales_tax_id,   
    core.state_sales_taxes.state_sales_tax_code,
    core.state_sales_taxes.state_sales_tax_name,
    core.states.state_code || ' (' ||  core.states.state_name || ')' AS state,
    core.entities.entity_name,
    core.industries.industry_name,
    core.item_groups.item_group_code || ' (' ||  core.item_groups.item_group_name || ')' AS item_group,
    core.state_sales_taxes.rate
FROM
    core.state_sales_taxes
INNER JOIN core.states
ON core.state_sales_taxes.state_id=core.states.state_id
LEFT JOIN core.entities
ON core.state_sales_taxes.entity_id=core.entities.entity_id
LEFT JOIN core.industries
ON core.state_sales_taxes.industry_id=core.industries.industry_id
LEFT JOIN core.item_groups
ON core.state_sales_taxes.item_group_id=core.item_groups.item_group_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.state_scrud_view.sql --<--<--
CREATE VIEW core.state_scrud_view
AS
SELECT 
  core.states.state_id, 
  core.countries.country_code || '('|| core.countries.country_name||')' AS country_name, 
  core.states.state_code, 
  core.states.state_name
FROM 
  core.states
INNER JOIN core.countries
ON core.states.country_id = core.countries.country_id; 






-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.tax_authority_scrud_view.sql --<--<--
CREATE VIEW core.tax_authority_scrud_view
AS
SELECT
	core.tax_authorities.tax_authority_id,
	core.tax_master.tax_master_code || '(' || core.tax_master.tax_master_name ||')' AS tax_master,
	core.tax_authorities.tax_authority_code,
	core.tax_authorities.tax_authority_name,
	core.countries.country_code || '(' || core.countries.country_name ||')' AS country,
	core.states.state_code || '(' || core.states.state_name ||')' AS county,
	core.tax_authorities.zip_code,
	core.tax_authorities.address_line_1,
	core.tax_authorities.address_line_2,
	core.tax_authorities.street,
	core.tax_authorities.city,
	core.tax_authorities.phone,
	core.tax_authorities.fax,
	core.tax_authorities.cell,
	core.tax_authorities.email,
	core.tax_authorities.url	
FROM core.tax_authorities
INNER JOIN core.tax_master
ON core.tax_authorities.tax_master_id = core.tax_master.tax_master_id
INNER JOIN core.countries
ON core.tax_authorities.country_id = core.countries.country_id
LEFT JOIN core.states
ON core.tax_authorities.state_id = core.states.state_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.tax_exempt_type_scrud_view.sql --<--<--
CREATE VIEW core.tax_exempt_type_scrud_view
AS
SELECT 
  tax_exempt_types.tax_exempt_type_id, 
  tax_exempt_types.tax_exempt_type_code, 
  tax_exempt_types.tax_exempt_type_name
FROM 
  core.tax_exempt_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.tax_master_scrud_view.sql --<--<--
CREATE VIEW core.tax_master_scrud_view
AS
SELECT 
  tax_master.tax_master_id, 
  tax_master.tax_master_code, 
  tax_master.tax_master_name
FROM 
  core.tax_master;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/core/core.unit_scrud_view.sql --<--<--
CREATE VIEW core.unit_scrud_view
AS
SELECT
        unit_id,
        unit_code,
        unit_name
FROM core.units;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.cash_repository_scrud_view.sql --<--<--
DROP VIEW IF EXISTS office.cash_repository_scrud_view;
CREATE VIEW office.cash_repository_scrud_view
AS
SELECT
office.cash_repositories.cash_repository_id,
office.offices.office_code || ' (' || office.offices.office_name || ') ' AS office,
office.cash_repositories.cash_repository_code,
office.cash_repositories.cash_repository_name,
parent_cash_repository.cash_repository_code || ' (' || parent_cash_repository.cash_repository_name || ') ' AS parent_cash_repository,
office.cash_repositories.description

FROM office.cash_repositories
INNER JOIN office.offices
ON office.cash_repositories.office_id = office.offices.office_id
LEFT JOIN office.cash_repositories AS parent_cash_repository
ON office.cash_repositories.parent_cash_repository_id = parent_cash_repository.parent_cash_repository_id;






-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.cost_center_scrud_view.sql --<--<--
CREATE VIEW office.cost_center_scrud_view
AS
SELECT
    office.cost_centers.cost_center_id,
    office.cost_centers.cost_center_code,
    office.cost_centers.cost_center_name
FROM
    office.cost_centers;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.counter_scrud_view.sql --<--<--
DROP VIEW IF EXISTS office.counter_scrud_view;
CREATE VIEW office.counter_scrud_view
AS
SELECT 
  office.counters.counter_id, 
  office.stores.store_code || '('|| office.stores.store_name||')' AS store,
  office.cash_repositories.cash_repository_code || '('|| office.cash_repositories.cash_repository_name||')' AS cash_repository,
  office.counters.counter_code,
  office.counters.counter_name
FROM 
  office.counters
INNER JOIN office.cash_repositories
ON office.counters.cash_repository_id = office.cash_repositories.cash_repository_id 
INNER JOIN office.stores
ON office.counters.store_id = office.stores.store_id;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.department_scrud_view.sql --<--<--
CREATE VIEW office.department_scrud_view
AS
SELECT 
	departments.department_id,
	departments.department_code,
	departments.department_name
FROM office.departments;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.office_scrud_view.sql --<--<--
DROP VIEW IF EXISTS office.office_scrud_view;
CREATE VIEW office.office_scrud_view
AS
SELECT 
  office.offices.office_id, 
  office.offices.office_code, 
  office.offices.office_name, 
  office.offices.nick_name, 
  office.offices.registration_date, 
  core.currencies.currency_code || '('|| core.currencies.currency_name||')' AS currency, 
  office.offices.po_box, 
  office.offices.address_line_1, 
  office.offices.address_line_2, 
  office.offices.street, 
  office.offices.city, 
  office.offices.state, 
  office.offices.zip_code, 
  office.offices.country, 
  office.offices.phone, 
  office.offices.fax, 
  office.offices.email, 
  office.offices.url, 
  office.offices.registration_number, 
  parent_office.office_code || '('|| parent_office.office_name||')' AS parent_office
FROM 
  office.offices
INNER JOIN core.currencies
ON office.offices.currency_code = core.currencies.currency_code
LEFT JOIN office.offices AS parent_office
ON  office.offices.office_id = parent_office.office_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.role_scrud_view.sql --<--<--
CREATE VIEW office.role_scrud_view
AS
SELECT 
  roles.role_id, 
  roles.role_code, 
  roles.role_name, 
  roles.is_admin, 
  roles.is_system
FROM 
  office.roles;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.store_scrud_view.sql --<--<--
DROP VIEW IF EXISTS office.store_scrud_view;
CREATE VIEW office.store_scrud_view
AS
SELECT 
  office.stores.store_id, 
  office.offices.office_code || '('|| office.offices.office_name||')' AS office, 
  office.stores.store_code, 
  office.stores.store_name, 
  office.stores.address, 
  office.store_types.store_type_code || '('|| office.store_types.store_type_name||')' AS store_type, 
  office.stores.allow_sales, 
  core.sales_taxes.sales_tax_code || '('|| core.sales_taxes.sales_tax_name||')' AS sales_tax,
  core.accounts.account_number || '('|| core.accounts.account_name||')' AS account,
  office.cash_repositories.cash_repository_code || '('|| office.cash_repositories.cash_repository_name||')' AS cash_repository 
FROM 
  office.stores
INNER JOIN office.offices
ON office.stores.office_id = office.offices.office_id
INNER JOIN office.store_types
ON office.stores.store_type_id = office.store_types.store_type_id
INNER JOIN core.sales_taxes
ON office.stores.sales_tax_id = core.sales_taxes.sales_tax_id
INNER JOIN core.accounts
ON office.stores.default_cash_account_id = core.accounts.account_id
INNER JOIN office.cash_repositories
ON office.stores.default_cash_repository_id = office.cash_repositories.cash_repository_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/office/office.store_type_scrud_view.sql --<--<--
CREATE VIEW office.store_type_scrud_view
AS 

SELECT 
  store_types.store_type_id, 
  store_types.store_type_code, 
  store_types.store_type_name
FROM 
  office.store_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/policy/policy.auto_verification_policy_scrud_view.sql --<--<--
CREATE VIEW policy.auto_verification_policy_scrud_view
AS
SELECT
    policy.auto_verification_policy.user_id,
    office.users.user_name,
    policy.auto_verification_policy.verify_sales_transactions,
    policy.auto_verification_policy.sales_verification_limit,
    policy.auto_verification_policy.verify_purchase_transactions,
    policy.auto_verification_policy.purchase_verification_limit,
    policy.auto_verification_policy.verify_gl_transactions,
    policy.auto_verification_policy.gl_verification_limit,
    policy.auto_verification_policy.effective_from,
    policy.auto_verification_policy.ends_on,
    policy.auto_verification_policy.is_active
FROM policy.auto_verification_policy
INNER JOIN office.users
ON policy.auto_verification_policy.user_id=office.users.user_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.scrud-views/policy/policy.voucher_verification_policy_scrud_view.sql --<--<--
CREATE VIEW policy.voucher_verification_policy_scrud_view
AS
SELECT
    policy.voucher_verification_policy.user_id,
    office.users.user_name,
    policy.voucher_verification_policy.can_verify_sales_transactions,
    policy.voucher_verification_policy.sales_verification_limit,
    policy.voucher_verification_policy.can_verify_purchase_transactions,
    policy.voucher_verification_policy.purchase_verification_limit,
    policy.voucher_verification_policy.can_verify_gl_transactions,
    policy.voucher_verification_policy.gl_verification_limit,
    policy.voucher_verification_policy.can_self_verify,
    policy.voucher_verification_policy.self_verification_limit,
    policy.voucher_verification_policy.effective_from,
    policy.voucher_verification_policy.ends_on,
    policy.voucher_verification_policy.is_active
FROM policy.voucher_verification_policy
INNER JOIN office.users
ON policy.voucher_verification_policy.user_id=office.users.user_id;




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.account_master_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.account_master_selector_view;

CREATE VIEW core.account_master_selector_view
AS
SELECT * FROM core.account_masters;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.account_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.account_selector_view;

CREATE VIEW core.account_selector_view
AS
SELECT
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_name,
    core.accounts.description,
    core.accounts.sys_type,
    core.accounts.parent_account_id,
    parent_accounts.account_number AS parent_account_number,
    parent_accounts.account_name AS parent_account_name,
    core.account_masters.account_master_id,
    core.account_masters.account_master_code,
    core.account_masters.account_master_name
FROM
    core.account_masters
    INNER JOIN core.accounts 
    ON core.account_masters.account_master_id = core.accounts.account_master_id
    LEFT OUTER JOIN core.accounts AS parent_accounts 
    ON core.accounts.parent_account_id = parent_accounts.account_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.bonus_slab_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.bonus_slab_selector_view;

CREATE VIEW core.bonus_slab_selector_view
AS
SELECT * FROM core.bonus_slabs;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.brand_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.brand_selector_view;

CREATE VIEW core.brand_selector_view
AS
SELECT * FROM core.brands;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.compound_item_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.compound_item_selector_view;

CREATE VIEW core.compound_item_selector_view
AS
SELECT * FROM core.compound_items;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.currency_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.currency_selector_view;

CREATE VIEW core.currency_selector_view
AS
SELECT * FROM core.currencies;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.fiscal_year_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.fiscal_year_selector_view;

CREATE VIEW core.fiscal_year_selector_view
AS
SELECT * FROM core.fiscal_year;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.frequency_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.frequency_selector_view;

CREATE VIEW core.frequency_selector_view
AS
SELECT * FROM core.frequencies;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.item_group_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.item_group_selector_view;

CREATE VIEW core.item_group_selector_view
AS
SELECT * FROM core.item_groups;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.item_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.item_selector_view;

CREATE VIEW core.item_selector_view
AS
SELECT * FROM core.items;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.party_selector_view.sql --<--<--
CREATE VIEW core.party_selector_view
AS
SELECT
    core.parties.party_id,
    core.party_types.party_type_id,
    core.party_types.is_supplier,
    core.party_types.party_type_code || ' (' || core.party_types.party_type_name || ')' AS party_type,
    core.parties.party_code,
    core.parties.first_name,
    core.parties.middle_name,
    core.parties.last_name,
    core.parties.party_name,
    core.parties.zip_code,
    core.parties.address_line_1,
    core.parties.address_line_2,
    core.parties.street,
    core.parties.city,
    core.get_state_name_by_state_id(core.parties.state_id) AS state,
    core.get_country_name_by_country_id(core.parties.country_id) AS country,
    core.parties.allow_credit,
    core.parties.maximum_credit_period,
    core.parties.maximum_credit_amount,
    core.parties.pan_number,
    core.parties.sst_number,
    core.parties.cst_number,
    core.parties.phone,
    core.parties.fax,
    core.parties.cell,
    core.parties.email,
    core.parties.url,
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_number || ' (' || core.accounts.account_name || ')' AS gl_head
FROM
core.parties
INNER JOIN
core.party_types
ON core.parties.party_type_id = core.party_types.party_type_id
INNER JOIN core.accounts
ON core.parties.account_id=core.accounts.account_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.party_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.party_type_selector_view;

CREATE VIEW core.party_type_selector_view
AS
SELECT * FROM core.party_types;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.price_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.price_type_selector_view;
CREATE VIEW core.price_type_selector_view
AS
SELECT 
  price_types.price_type_id, 
  price_types.price_type_code, 
  price_types.price_type_name
FROM 
  core.price_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.rounding_method_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.rounding_method_selector_view;

CREATE VIEW core.rounding_method_selector_view
AS
SELECT * FROM core.rounding_methods;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.sales_tax_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.sales_tax_selector_view;

CREATE VIEW core.sales_tax_selector_view
AS
SELECT * FROM core.sales_taxes;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.sales_team_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.sales_team_selector_view;

CREATE VIEW core.sales_team_selector_view
AS
SELECT * FROM core.sales_teams;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.salesperson_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.salesperson_selector_view;

CREATE VIEW core.salesperson_selector_view
AS
SELECT
    salesperson_id,
    salesperson_code,
    salesperson_name,
    address,
    contact_number,
    commission_rate,
    account_name
FROM
    core.salespersons,
    core.accounts
WHERE
    core.salespersons.account_id = core.accounts.account_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.shipping_mail_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.shipping_mail_type_selector_view;

CREATE VIEW core.shipping_mail_type_selector_view
AS
SELECT 
  shipping_mail_types.shipping_mail_type_id, 
  shipping_mail_types.shipping_mail_type_code, 
  shipping_mail_types.shipping_mail_type_name
FROM 
  core.shipping_mail_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.shipping_package_shape_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.shipping_package_shape_selector_view;

CREATE VIEW core.shipping_package_shape_selector_view
AS
SELECT 
  shipping_package_shapes.shipping_package_shape_id, 
  shipping_package_shapes.shipping_package_shape_code, 
  shipping_package_shapes.shipping_package_shape_name, 
  shipping_package_shapes.is_rectangular
FROM 
  core.shipping_package_shapes;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.supplier_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.supplier_selector_view;
CREATE VIEW core.supplier_selector_view
AS
SELECT
    core.parties.party_id,
    core.party_types.party_type_id,
    core.party_types.is_supplier,
    core.party_types.party_type_code || ' (' || core.party_types.party_type_name || ')' AS party_type,
    core.parties.party_code,
    core.parties.first_name,
    core.parties.middle_name,
    core.parties.last_name,
    core.parties.party_name,
    core.parties.zip_code,
    core.parties.address_line_1,
    core.parties.address_line_2,
    core.parties.street,
    core.parties.city,
    core.get_state_name_by_state_id(core.parties.state_id) AS state,
    core.get_country_name_by_country_id(core.parties.country_id) AS country,
    core.parties.allow_credit,
    core.parties.maximum_credit_period,
    core.parties.maximum_credit_amount,
    core.parties.pan_number,
    core.parties.sst_number,
    core.parties.cst_number,
    core.parties.phone,
    core.parties.fax,
    core.parties.cell,
    core.parties.email,
    core.parties.url,
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_number || ' (' || core.accounts.account_name || ')' AS gl_head
FROM
core.parties
INNER JOIN
core.party_types
ON core.parties.party_type_id = core.party_types.party_type_id
INNER JOIN core.accounts
ON core.parties.account_id=core.accounts.account_id
WHERE is_supplier=true;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.tax_base_amount_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.tax_base_amount_type_selector_view;

CREATE VIEW core.tax_base_amount_type_selector_view
AS
SELECT * FROM core.tax_base_amount_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.tax_rate_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.tax_rate_type_selector_view;

CREATE VIEW core.tax_rate_type_selector_view
AS
SELECT * FROM core.tax_rate_types;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/core/core.unit_selector_view.sql --<--<--
DROP VIEW IF EXISTS core.unit_selector_view;

CREATE VIEW core.unit_selector_view
AS
SELECT * FROM core.units;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/office/office.cash_repository_selector_view.sql --<--<--
DROP VIEW IF EXISTS office.cash_repository_selector_view;

CREATE VIEW office.cash_repository_selector_view
AS
SELECT
    office.cash_repositories.cash_repository_id,
    office.cash_repositories.cash_repository_code,
    office.cash_repositories.cash_repository_name,
    parent_cash_repositories.cash_repository_code parent_cr_code,
    parent_cash_repositories.cash_repository_name parent_cr_name,
    office.cash_repositories.description
FROM
    office.cash_repositories
LEFT OUTER JOIN
    office.cash_repositories AS parent_cash_repositories
ON
    office.cash_repositories.parent_cash_repository_id=parent_cash_repositories.cash_repository_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/office/office.office_selector_view.sql --<--<--
DROP VIEW IF EXISTS office.office_selector_view;

CREATE VIEW office.office_selector_view
AS
SELECT * FROM office.offices;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/office/office.store_selector_view.sql --<--<--
DROP VIEW IF EXISTS office.store_selector_view;

CREATE VIEW office.store_selector_view
AS
SELECT * FROM office.stores;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/office/office.store_type_selector_view.sql --<--<--
DROP VIEW IF EXISTS office.store_type_selector_view;

CREATE VIEW office.store_type_selector_view
AS
SELECT * FROM office.store_types;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.selector-views/office/office.user_selector_view.sql --<--<--
DROP VIEW IF EXISTS office.user_selector_view;

CREATE VIEW office.user_selector_view
AS
SELECT
    office.users.user_id,
    office.users.user_name,
    office.users.full_name,
    office.roles.role_name,
    office.offices.office_name
FROM
    office.users
INNER JOIN office.roles
ON office.users.role_id = office.roles.role_id
INNER JOIN office.offices
ON office.users.office_id = office.offices.office_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.account_view.sql --<--<--
CREATE VIEW core.account_view
AS
SELECT
    core.accounts.account_id,
    core.accounts.account_number || ' (' || core.accounts.account_name || ')' AS account,
    core.accounts.account_number,
    core.accounts.account_name,
    core.accounts.description,
    core.accounts.external_code,
    core.accounts.currency_code,
    core.accounts.confidential,
    core.account_masters.normally_debit,
    core.accounts.is_transaction_node,
    core.accounts.sys_type,
    core.accounts.parent_account_id,
    parent_accounts.account_number AS parent_account_number,
    parent_accounts.account_name AS parent_account_name,
    parent_accounts.account_number || ' (' || parent_accounts.account_name || ')' AS parent_account,
    core.account_masters.account_master_id,
    core.account_masters.account_master_code,
    core.account_masters.account_master_name,
    core.has_child_accounts(core.accounts.account_id) AS has_child
FROM core.account_masters
INNER JOIN core.accounts 
ON core.account_masters.account_master_id = core.accounts.account_master_id
LEFT OUTER JOIN core.accounts AS parent_accounts 
ON core.accounts.parent_account_id = parent_accounts.account_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.bank_account_view.sql --<--<--
CREATE VIEW core.bank_account_view
AS
SELECT
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_name,
    office.users.user_name AS maintained_by,
    core.bank_accounts.bank_name,
    core.bank_accounts.bank_branch,
    core.bank_accounts.bank_contact_number,
    core.bank_accounts.bank_address,
    core.bank_accounts.bank_account_number,
    core.bank_accounts.bank_account_type,
    core.bank_accounts.relationship_officer_name AS relation_officer
FROM
    core.bank_accounts
INNER JOIN core.accounts ON core.accounts.account_id = core.bank_accounts.account_id
INNER JOIN office.users ON core.bank_accounts.maintained_by_user_id = office.users.user_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.item_view.sql --<--<--
DROP VIEW IF EXISTS core.item_view;

CREATE VIEW core.item_view
AS
SELECT 
        item_id,
        item_code,
        item_name,
        item_group_code || ' (' || item_group_name || ')' AS item_group,
        item_type_code || ' (' || item_type_name || ')' AS item_type,
        maintain_stock,
        brand_code || ' (' || brand_name || ')' AS brand,
        party_code || ' (' || party_name || ')' AS preferred_supplier,
        lead_time_in_days,
        weight_in_grams,
        width_in_centimeters,
        height_in_centimeters,
        length_in_centimeters,
        machinable,
        shipping_mail_type_code || ' (' || shipping_mail_type_name || ')' AS preferred_shipping_mail_type,
        shipping_package_shape_code || ' (' || shipping_package_shape_name || ')' AS preferred_shipping_package_shape,
        core.units.unit_code || ' (' || core.units.unit_name || ')' AS unit,
        base_unit.unit_code || ' (' || base_unit.unit_name || ')' AS base_unit,
        hot_item,
        cost_price,
        cost_price_includes_tax,
        selling_price,
        selling_price_includes_tax,
        sales_tax_code || ' (' || sales_tax_name || ')' AS sales_tax,
        reorder_unit.unit_code || ' (' || reorder_unit.unit_name || ')' AS reorder_unit,
        reorder_level,
        reorder_quantity
FROM core.items
INNER JOIN core.item_groups
ON core.items.item_group_id = core.item_groups.item_group_id
INNER JOIN core.item_types
ON core.items.item_type_id = core.item_types.item_type_id
INNER JOIN core.brands
ON core.items.brand_id = core.brands.brand_id
INNER JOIN core.parties
ON core.items.preferred_supplier_id = core.parties.party_id
INNER JOIN core.units
ON core.items.unit_id = core.units.unit_id
INNER JOIN core.units AS base_unit
ON core.get_root_unit_id(core.items.unit_id) = core.units.unit_id
INNER JOIN core.units AS reorder_unit
ON core.items.reorder_unit_id = reorder_unit.unit_id
INNER JOIN core.sales_taxes
ON core.items.sales_tax_id = core.sales_taxes.sales_tax_id
LEFT JOIN core.shipping_mail_types
ON core.items.preferred_shipping_mail_type_id = core.shipping_mail_types.shipping_mail_type_id
LEFT JOIN core.shipping_package_shapes
ON core.items.shipping_package_shape_id = core.shipping_package_shapes.shipping_package_shape_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.party_user_control_view.sql --<--<--
CREATE VIEW core.party_user_control_view
AS
SELECT
    core.party_types.party_type_code,
    core.party_types.party_type_name,
    core.parties.email,
    core.parties.url,
    core.parties.pan_number,
    core.parties.sst_number,
    core.parties.cst_number,
    core.parties.allow_credit,
    core.parties.maximum_credit_period,
    core.parties.maximum_credit_amount,
    core.accounts.account_number,
    core.accounts.account_name,
    core.parties.zip_code,
    core.parties.address_line_1,
    core.parties.address_line_2,
    core.parties.street,
    core.get_state_name_by_state_id(core.parties.state_id) AS state,
    core.get_country_name_by_country_id(core.parties.country_id) AS country
FROM core.parties
INNER JOIN core.party_types
ON core.parties.party_type_id = core.party_types.party_type_id
INNER JOIN core.accounts
ON core.parties.account_id = core.accounts.account_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.party_view.sql --<--<--
CREATE VIEW core.party_view
AS
SELECT
    core.parties.party_id,
    core.party_types.party_type_id,
    core.party_types.is_supplier,
    core.party_types.party_type_code || ' (' || core.party_types.party_type_name || ')' AS party_type,
    core.parties.party_code,
    core.parties.first_name,
    core.parties.middle_name,
    core.parties.last_name,
    core.parties.party_name,
    core.parties.zip_code,
    core.parties.address_line_1,
    core.parties.address_line_2,
    core.parties.street,
    core.parties.city,
    core.get_state_name_by_state_id(core.parties.state_id) AS state,
    core.get_country_name_by_country_id(core.parties.country_id) AS country,
    core.parties.allow_credit,
    core.parties.maximum_credit_period,
    core.parties.maximum_credit_amount,
    core.parties.pan_number,
    core.parties.sst_number,
    core.parties.cst_number,
    core.parties.phone,
    core.parties.fax,
    core.parties.cell,
    core.parties.email,
    core.parties.url,
    core.accounts.account_id,
    core.accounts.account_number,
    core.accounts.account_number || ' (' || core.accounts.account_name || ')' AS gl_head
FROM
core.parties
INNER JOIN
core.party_types
ON core.parties.party_type_id = core.party_types.party_type_id
INNER JOIN core.accounts
ON core.parties.account_id=core.accounts.account_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.shipping_address_view.sql --<--<--
CREATE VIEW core.shipping_address_view
AS
SELECT
    core.shipping_addresses.shipping_address_id,
    core.shipping_addresses.shipping_address_code,
    core.shipping_addresses.party_id,
    core.parties.party_code || ' (' || core.parties.party_name || ')' AS party,
    core.shipping_addresses.zip_code,
    core.shipping_addresses.address_line_1,
    core.shipping_addresses.address_line_2,
    core.shipping_addresses.street,
    core.shipping_addresses.city,
    core.get_state_name_by_state_id(core.shipping_addresses.state_id) AS state,
    core.get_country_name_by_country_id(core.shipping_addresses.country_id) AS country
FROM core.shipping_addresses
INNER JOIN core.parties
ON core.shipping_addresses.party_id=core.parties.party_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.supplier_view.sql --<--<--
CREATE VIEW core.supplier_view
AS
SELECT * FROM core.parties
WHERE party_type_id IN
(
        SELECT party_type_id FROM core.party_types
        WHERE is_supplier=true
);

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/core/core.unit_view.sql --<--<--
--TODO
CREATE VIEW core.unit_view
AS
SELECT * FROM core.units;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.office_view.sql --<--<--
--TODO
CREATE VIEW office.office_view
AS
SELECT * FROM office.offices;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.role_view.sql --<--<--
CREATE OR REPLACE VIEW office.role_view
AS
SELECT 
  roles.role_id, 
  roles.role_code, 
  roles.role_name
FROM 
  office.roles;
   

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.sign_in_view.sql --<--<--
CREATE VIEW office.sign_in_view
AS
SELECT 
  logins.login_id, 
  logins.user_id, 
  users.role_id, 
  roles.role_code || ' (' || roles.role_name || ')' AS role, 
  roles.role_code, 
  roles.role_name, 
  roles.is_admin, 
  roles.is_system, 
  logins.browser, 
  logins.ip_address, 
  logins.login_date_time, 
  logins.remote_user, 
  logins.culture, 
  users.user_name, 
  users.full_name, 
  users.elevated, 
  offices.office_code || ' (' || offices.office_name || ')' AS office,
  offices.office_id, 
  offices.office_code, 
  offices.office_name, 
  offices.nick_name, 
  offices.registration_date, 
  offices.currency_code, 
  offices.po_box, 
  offices.address_line_1, 
  offices.address_line_2, 
  offices.street, 
  offices.city, 
  offices.state, 
  offices.zip_code, 
  offices.country, 
  offices.phone, 
  offices.fax, 
  offices.email, 
  offices.url, 
  offices.registration_number, 
  offices.pan_number,
  offices.allow_transaction_posting
FROM 
  audit.logins, 
  office.users, 
  office.offices, 
  office.roles
WHERE 
  logins.user_id = users.user_id AND
  logins.office_id = offices.office_id AND
  users.role_id = roles.role_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.store_view.sql --<--<--
--TODO
CREATE VIEW office.store_view
AS
SELECT * FROM office.stores;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.user_view.sql --<--<--
CREATE VIEW office.user_view
AS
SELECT
    office.users.user_id,
    office.users.user_name,
    office.users.full_name,
    office.roles.role_name,
    office.offices.office_name
FROM
    office.users
INNER JOIN office.roles
ON office.users.role_id = office.roles.role_id
INNER JOIN office.offices
ON office.users.office_id = office.offices.office_id;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/office/office.work_center_view.sql --<--<--
CREATE VIEW office.work_center_view
AS
SELECT
    office.work_centers.work_center_id,
    office.offices.office_code || ' (' || office.offices.office_name || ')' AS office,
    office.work_centers.work_center_code,
    office.work_centers.work_center_name
FROM office.work_centers
INNER JOIN office.offices
ON office.work_centers.office_id = office.offices.office_id;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/public.dbstat.sql --<--<--
DROP VIEW IF EXISTS db_stat;

CREATE VIEW db_stat
AS
SELECT
    relname,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze,
    vacuum_count,
    autovacuum_count,
    analyze_count,
    autoanalyze_count
FROM
   pg_stat_user_tables;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/1. transactions.transaction_view.sql --<--<--
DROP VIEW IF EXISTS transactions.transaction_view;
CREATE VIEW transactions.transaction_view
AS
SELECT
    transactions.transaction_master.transaction_master_id,
    transactions.transaction_master.transaction_counter,
    transactions.transaction_master.transaction_code,
    transactions.transaction_master.book,
    transactions.transaction_master.value_date,
    transactions.transaction_master.transaction_ts,
    transactions.transaction_master.login_id,
    transactions.transaction_master.user_id,
    transactions.transaction_master.sys_user_id,
    transactions.transaction_master.office_id,
    transactions.transaction_master.cost_center_id,
    transactions.transaction_master.reference_number,
    transactions.transaction_master.statement_reference AS master_statement_reference,
    transactions.transaction_master.last_verified_on,
    transactions.transaction_master.verified_by_user_id,
    transactions.transaction_master.verification_status_id,
    transactions.transaction_master.verification_reason,
    transactions.transaction_details.transaction_detail_id,
    transactions.transaction_details.tran_type,
    transactions.transaction_details.account_id,
    core.accounts.account_number,
    core.accounts.account_name,
    core.account_masters.normally_debit,
    core.account_masters.account_master_code,
    core.account_masters.account_master_name,
    core.accounts.account_master_id,
    core.accounts.confidential,
    transactions.transaction_details.statement_reference,
    transactions.transaction_details.cash_repository_id,
    transactions.transaction_details.currency_code,
    transactions.transaction_details.amount_in_currency,
    transactions.transaction_details.local_currency_code,
    transactions.transaction_details.amount_in_local_currency
FROM
transactions.transaction_master
INNER JOIN transactions.transaction_details
ON transactions.transaction_master.transaction_master_id = transactions.transaction_details.transaction_master_id
INNER JOIN core.accounts
ON transactions.transaction_details.account_id = core.accounts.account_id
INNER JOIN core.account_masters
ON core.accounts.account_master_id = core.account_masters.account_master_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/2. transactions.verified_transaction_view.sql --<--<--
DROP VIEW IF EXISTS transactions.verified_transaction_view CASCADE;

CREATE VIEW transactions.verified_transaction_view
AS
SELECT * FROM transactions.transaction_view
WHERE verification_status_id > 0;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/3. transactions.trial_balance_view.sql --<--<--
DROP MATERIALIZED VIEW IF EXISTS transactions.trial_balance_view;
CREATE MATERIALIZED VIEW transactions.trial_balance_view
AS
SELECT core.get_account_name(account_id), 
    SUM(CASE transactions.verified_transaction_view.tran_type WHEN 'Dr' THEN amount_in_local_currency ELSE NULL END) AS debit,
    SUM(CASE transactions.verified_transaction_view.tran_type WHEN 'Cr' THEN amount_in_local_currency ELSE NULL END) AS Credit
FROM transactions.verified_transaction_view
GROUP BY account_id;

ALTER MATERIALIZED VIEW transactions.trial_balance_view
OWNER TO mix_erp;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/3. transactions.verified_transaction_mat_view.sql --<--<--
DROP MATERIALIZED VIEW IF EXISTS transactions.verified_transaction_mat_view CASCADE;

CREATE MATERIALIZED VIEW transactions.verified_transaction_mat_view
AS
SELECT * FROM transactions.verified_transaction_view;

ALTER MATERIALIZED VIEW transactions.verified_transaction_mat_view
OWNER TO mix_erp;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/4. transactions.stock_transaction_view.sql --<--<--
DROP VIEW IF EXISTS transactions.stock_transaction_view CASCADE;

CREATE VIEW transactions.stock_transaction_view
AS
SELECT
        transactions.transaction_master.transaction_master_id,
        transactions.stock_master.stock_master_id,
        transactions.stock_details.stock_detail_id,
        transactions.transaction_master.book,
        transactions.transaction_master.transaction_counter,
        transactions.transaction_master.transaction_code,
        transactions.transaction_master.value_date,
        transactions.transaction_master.transaction_ts,
        transactions.transaction_master.login_id,
        transactions.transaction_master.user_id,
        transactions.transaction_master.sys_user_id,
        transactions.transaction_master.office_id,
        transactions.transaction_master.cost_center_id,
        transactions.transaction_master.reference_number,
        transactions.transaction_master.statement_reference,
        transactions.transaction_master.last_verified_on,
        transactions.transaction_master.verified_by_user_id,
        transactions.transaction_master.verification_status_id,
        transactions.transaction_master.verification_reason,
        transactions.stock_master.party_id,
        core.parties.country_id,
        core.parties.state_id,
        transactions.stock_master.salesperson_id,
        transactions.stock_master.price_type_id,
        transactions.stock_master.is_credit,
        transactions.stock_master.shipper_id,
        transactions.stock_master.shipping_address_id,
        transactions.stock_master.shipping_charge,
        transactions.stock_master.store_id AS stock_master_store_id,
        transactions.stock_master.cash_repository_id,
        transactions.stock_details.tran_type,
        transactions.stock_details.store_id,
        transactions.stock_details.item_id,
        transactions.stock_details.quantity,
        transactions.stock_details.unit_id,
        transactions.stock_details.base_quantity,
        transactions.stock_details.base_unit_id,
        transactions.stock_details.price,
        transactions.stock_details.discount,
        transactions.stock_details.sales_tax_id,
        transactions.stock_details.tax
FROM transactions.stock_details
INNER JOIN transactions.stock_master
ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
INNER JOIN transactions.transaction_master
ON transactions.transaction_master.transaction_master_id = transactions.stock_master.transaction_master_id
INNER JOIN core.parties
ON transactions.stock_master.party_id = core.parties.party_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/5. transactions.verified_stock_transaction_view.sql --<--<--
DROP MATERIALIZED VIEW IF EXISTS transactions.verified_stock_transaction_view;

CREATE MATERIALIZED VIEW transactions.verified_stock_transaction_view
AS
SELECT * FROM transactions.stock_transaction_view
WHERE verification_status_id > 0;

ALTER MATERIALIZED VIEW transactions.verified_stock_transaction_view
OWNER TO mix_erp;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/6. transactions.verified_cash_transaction_mat_view.sql --<--<--
CREATE MATERIALIZED VIEW transactions.verified_cash_transaction_mat_view
AS
SELECT * FROM transactions.verified_transaction_mat_view
WHERE transactions.verified_transaction_mat_view.transaction_master_id
IN
(
    SELECT transactions.verified_transaction_mat_view.transaction_master_id 
    FROM transactions.verified_transaction_mat_view
    WHERE account_master_id IN(10101, 10102) --Cash and Bank A/C
);

ALTER MATERIALIZED VIEW transactions.verified_cash_transaction_mat_view
OWNER TO mix_erp;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/transactions.sales_by_country_view.sql --<--<--
CREATE VIEW transactions.sales_by_country_view
AS
WITH country_data
AS
(
SELECT country_id, SUM((price * quantity) - discount + tax + shipping_charge) AS sales
FROM transactions.verified_stock_transaction_view
WHERE book = ANY(ARRAY['Sales.Delivery', 'Sales.Direct'])
GROUP BY country_id
)

SELECT country_code, sales 
FROM country_data
INNER JOIN core.countries
ON country_data.country_id = core.countries.country_id;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/05.views/transactions/transactions.verified_stock_details_view.sql --<--<--
DROP VIEW IF EXISTS transactions.verified_stock_details_view;

CREATE VIEW transactions.verified_stock_details_view
AS
SELECT transactions.stock_details.* 
FROM transactions.stock_details
INNER JOIN transactions.stock_master
ON transactions.stock_master.stock_master_id = transactions.stock_details.stock_master_id
INNER JOIN transactions.transaction_master
ON transactions.transaction_master.transaction_master_id = transactions.stock_master.transaction_master_id
AND transactions.transaction_master.verification_status_id > 0;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/06.sample-data/0.menus.sql --<--<--
--This table should not be localized.
INSERT INTO core.menus(menu_text, url, menu_code, level)
SELECT 'Sales', '~/Modules/Sales/Index.mix', 'SA', 0 UNION ALL
SELECT 'Purchase', '~/Modules/Purchase/Index.mix', 'PU', 0 UNION ALL
SELECT 'Products & Items', '~/Modules/Inventory/Index.mix', 'ITM', 0 UNION ALL
SELECT 'Finance', '~/Modules/Finance/Index.mix', 'FI', 0 UNION ALL
SELECT 'Back Office', '~/Modules/BackOffice/Index.mix', 'BO', 0;


INSERT INTO core.menus(menu_text, url, menu_code, level, parent_menu_id)
          SELECT 'Sales & Quotation', NULL, 'SAQ', 1, core.get_menu_id('SA')
UNION ALL SELECT 'Direct Sales', '~/Modules/Sales/DirectSales.mix', 'DRS', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Sales Quotation', '~/Modules/Sales/Quotation.mix', 'SQ', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Sales Order', '~/Modules/Sales/Order.mix', 'SO', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Sales Delivery', '~/Modules/Sales/Delivery.mix', 'SD', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Receipt from Customer', '~/Modules/Sales/Receipt.mix', 'RFC', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Sales Return', '~/Modules/Sales/Return.mix', 'SR', 2, core.get_menu_id('SAQ')
UNION ALL SELECT 'Setup & Maintenance', NULL, 'SSM', 1, core.get_menu_id('SA')
UNION ALL SELECT 'Bonus Slab for Salespersons', '~/Modules/Sales/Setup/BonusSlabs.mix', 'ABS', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Bonus Slab Details', '~/Modules/Sales/Setup/BonusSlabDetails.mix', 'BSD', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Sales Teams', '~/Modules/Sales/Setup/Teams.mix', 'SST', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Salespersons', '~/Modules/Sales/Setup/Salespersons.mix', 'SSA', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Bonus Slab Assignment', '~/Modules/Sales/Setup/BonusSlabAssignment.mix', 'BSA', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Late Fees', '~/Modules/Sales/Setup/LateFees.mix', 'LF', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Payment Terms', '~/Modules/Sales/Setup/PaymentTerms.mix', 'PAT', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Recurring Invoices', '~/Modules/Sales/Setup/RecurringInvoices.mix', 'RI', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Recurring Invoice Setup', '~/Modules/Sales/Setup/RecurringInvoiceSetup.mix', 'RIS', 2, core.get_menu_id('SSM')
UNION ALL SELECT 'Sales Reports', NULL, 'SAR', 1, core.get_menu_id('SA')
UNION ALL SELECT 'Top Selling Items', '~/Modules/Sales/Reports/TopSellingItems.mix', 'SAR-TSI', 2, core.get_menu_id('SAR')
UNION ALL SELECT 'Purchase & Quotation', NULL, 'PUQ', 1, core.get_menu_id('PU')
UNION ALL SELECT 'Direct Purchase', '~/Modules/Purchase/DirectPurchase.mix', 'DRP', 2, core.get_menu_id('PUQ')
UNION ALL SELECT 'Purchase Order', '~/Modules/Purchase/Order.mix', 'PO', 2, core.get_menu_id('PUQ')
UNION ALL SELECT 'Purchase Reorder', '~/Modules/Purchase/Reorder.mix', 'PRO', 2, core.get_menu_id('PUQ')
UNION ALL SELECT 'GRN Entry', '~/Modules/Purchase/GRN.mix', 'GRN', 2, core.get_menu_id('PUQ')
UNION ALL SELECT 'Purchase Return', '~/Modules/Purchase/Return.mix', 'PR', 2, core.get_menu_id('PUQ')
UNION ALL SELECT 'Purchase Reports', NULL, 'PUR', 1, core.get_menu_id('PU')
UNION ALL SELECT 'Inventory Movements', NULL, 'IIM', 1, core.get_menu_id('ITM')
UNION ALL SELECT 'Stock Transfer Journal', '~/Modules/Inventory/Transfer.mix', 'STJ', 2, core.get_menu_id('IIM')
UNION ALL SELECT 'Stock Adjustments', '~/Modules/Inventory/Adjustment.mix', 'STA', 2, core.get_menu_id('IIM')
UNION ALL SELECT 'Setup & Maintenance', NULL, 'ISM', 1, core.get_menu_id('ITM')
UNION ALL SELECT 'Store Types', '~/Modules/Inventory/Setup/StoreTypes.mix', 'STT', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Stores', '~/Modules/Inventory/Setup/Stores.mix', 'STO', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Counter Setup', '~/Modules/BackOffice/Counters.mix', 'SCS', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Party Types', '~/Modules/Inventory/Setup/PartyTypes.mix', 'PT', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Party Accounts', '~/Modules/Inventory/Setup/Parties.mix', 'PA', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Shipping Addresses', '~/Modules/Inventory/Setup/ShippingAddresses.mix', 'PSA', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Item Maintenance', '~/Modules/Inventory/Setup/Items.mix', 'SSI', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Compound Items', '~/Modules/Inventory/Setup/CompoundItems.mix', 'SSC', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Compound Item Details', '~/Modules/Inventory/Setup/CompoundItemDetails.mix', 'SSCD', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Cost Prices', '~/Modules/Inventory/Setup/CostPrices.mix', 'ICP', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Selling Prices', '~/Modules/Inventory/Setup/SellingPrices.mix', 'ISP', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Item Groups', '~/Modules/Inventory/Setup/ItemGroups.mix', 'SIG', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Item Types', '~/Modules/Inventory/Setup/ItemTypes.mix', 'SIT', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Brands', '~/Modules/Inventory/Setup/Brands.mix', 'SSB', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Units of Measure', '~/Modules/Inventory/Setup/UOM.mix', 'UOM', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Compound Units of Measure', '~/Modules/Inventory/Setup/CUOM.mix', 'CUOM', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Shipper Information', '~/Modules/Inventory/Setup/Shippers.mix', 'SHI', 2, core.get_menu_id('ISM')
UNION ALL SELECT 'Reports', NULL, 'IR', 1, core.get_menu_id('ITM')
UNION ALL SELECT 'Inventory Account Statement', '~/Modules/Inventory/Reports/AccountStatement.mix', 'IAS', 2, core.get_menu_id('IR')
UNION ALL SELECT 'Transactions & Templates', NULL, 'FTT', 1, core.get_menu_id('FI')
UNION ALL SELECT 'Journal Voucher Entry', '~/Modules/Finance/JournalVoucher.mix', 'JVN', 2, core.get_menu_id('FTT')
UNION ALL SELECT 'Update Exchange Rates', '~/Modules/Finance/UpdateExchangeRates.mix', 'UER', 2, core.get_menu_id('FTT')
UNION ALL SELECT 'Voucher Verification', '~/Modules/Finance/VoucherVerification.mix', 'FVV', 2, core.get_menu_id('FTT')
UNION ALL SELECT 'End of Day Operation', '~/Modules/Finance/EODOperation.mix', 'EOD', 2, core.get_menu_id('FTT')
UNION ALL SELECT 'Setup & Maintenance', NULL, 'FSM', 1, core.get_menu_id('FI')
UNION ALL SELECT 'Chart of Accounts', '~/Modules/Finance/Setup/COA.mix', 'COA', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Currency Management', '~/Modules/Finance/Setup/Currencies.mix', 'CUR', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Bank Accounts', '~/Modules/Finance/Setup/BankAccounts.mix', 'CBA', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Ageing Slabs', '~/Modules/Finance/Setup/AgeingSlabs.mix', 'AGS', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Cash Flow Headings', '~/Modules/Finance/Setup/CashFlowHeadings.mix', 'CFH', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Cash Flow Setup', '~/Modules/Finance/Setup/CashFlowSetup.mix', 'CFS', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Cost Centers', '~/Modules/Finance/Setup/CostCenters.mix', 'CC', 2, core.get_menu_id('FSM')
UNION ALL SELECT 'Reports', NULL, 'FIR', 1, core.get_menu_id('FI')
UNION ALL SELECT 'Account Statement', '~/Modules/Finance/Reports/AccountStatement.mix', 'AS', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Trial Balance', '~/Modules/Finance/Reports/TrialBalance.mix', 'TB', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Profit & Loss Account', '~/Modules/Finance/Reports/ProfitAndLossAccount.mix', 'PLA', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Retained Earnings Statement', '~/Modules/Finance/Reports/RetainedEarnings.mix', 'RET', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Balance Sheet', '~/Modules/Finance/Reports/BalanceSheet.mix', 'BS', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Cash Flow', '~/Modules/Finance/Reports/CashFlow.mix', 'CF', 2, core.get_menu_id('FIR')
UNION ALL SELECT 'Tax Configuration', NULL, 'BOTC', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Tax Master', '~/Modules/BackOffice/Tax/TaxMaster.mix', 'TXM', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Tax Authorities', '~/Modules/BackOffice/Tax/TaxAuthorities.mix', 'TXA', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Sales Tax Types', '~/Modules/BackOffice/Tax/SalesTaxTypes.mix', 'STXT', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'State Sales Taxes', '~/Modules/BackOffice/Tax/StateSalesTaxes.mix', 'STST', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Counties Sales Taxes', '~/Modules/BackOffice/Tax/CountySalesTaxes.mix', 'CTST', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Sales Taxes', '~/Modules/BackOffice/Tax/SalesTaxes.mix', 'STX', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Sales Tax Details', '~/Modules/BackOffice/Tax/SalesTaxDetails.mix', 'STXD', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Tax Exempt Types', '~/Modules/BackOffice/Tax/TaxExemptTypes.mix', 'TXEXT', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Sales Tax Exempts', '~/Modules/BackOffice/Tax/SalesTaxExempts.mix', 'STXEX', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Sales Tax Exempt Details', '~/Modules/BackOffice/Tax/SalesTaxExemptDetails.mix', 'STXEXD', 2, core.get_menu_id('BOTC')
UNION ALL SELECT 'Miscellaneous Parameters', NULL, 'SMP', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Flags', '~/Modules/BackOffice/Flags.mix', 'TRF', 2, core.get_menu_id('SMP')
UNION ALL SELECT 'Audit Reports', NULL, 'SEAR', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Login View', '~/Reports/Office.Login.xml', 'SEAR-LV', 2, core.get_menu_id('SEAR')
UNION ALL SELECT 'Office Setup', NULL, 'SOS', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Office & Branch Setup', '~/Modules/BackOffice/Offices.mix', 'SOB', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Cash Repository Setup', '~/Modules/BackOffice/CashRepositories.mix', 'SCR', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Department Setup', '~/Modules/BackOffice/Departments.mix', 'SDS', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Role Management', '~/Modules/BackOffice/Roles.mix', 'SRM', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'User Management', '~/Modules/BackOffice/Users.mix', 'SUM', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Entity Setup', '~/Modules/BackOffice/Entities.mix', 'SES', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Industry Setup', '~/Modules/BackOffice/Industries.mix', 'SIS', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Country Setup', '~/Modules/BackOffice/Countries.mix', 'SCRS', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'State Setup', '~/Modules/BackOffice/States.mix', 'SSS', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'County Setup', '~/Modules/BackOffice/Counties.mix', 'SCTS', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Fiscal Year Information', '~/Modules/BackOffice/FiscalYear.mix', 'SFY', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Frequency & Fiscal Year Management', '~/Modules/BackOffice/Frequency.mix', 'SFR', 2, core.get_menu_id('SOS')
UNION ALL SELECT 'Policy Management', NULL, 'SPM', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Voucher Verification Policy', '~/Modules/BackOffice/Policy/VoucherVerification.mix', 'SVV', 2, core.get_menu_id('SPM')
UNION ALL SELECT 'Automatic Verification Policy', '~/Modules/BackOffice/Policy/AutoVerification.mix', 'SAV', 2, core.get_menu_id('SPM')
UNION ALL SELECT 'Menu Access Policy', '~/Modules/BackOffice/Policy/MenuAccess.mix', 'SMA', 2, core.get_menu_id('SPM')
UNION ALL SELECT 'GL Access Policy', '~/Modules/BackOffice/Policy/GLAccess.mix', 'SAP', 2, core.get_menu_id('SPM')
UNION ALL SELECT 'Store Policy', '~/Modules/BackOffice/Policy/Store.mix', 'SSP', 2, core.get_menu_id('SPM')
UNION ALL SELECT 'Admin Tools', NULL, 'SAT', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Database Statistics', '~/Modules/BackOffice/Admin/DatabaseStatistics.mix', 'DBSTAT', 2, core.get_menu_id('SAT')
UNION ALL SELECT 'Backup Database', '~/Modules/BackOffice/Admin/DatabaseBackup.mix', 'BAK', 2, core.get_menu_id('SAT')
UNION ALL SELECT 'Change User Password', '~/Modules/BackOffice/Admin/ChangePassword.mix', 'PWD', 2, core.get_menu_id('SAT')
UNION ALL SELECT 'Check Updates', '~/Modules/BackOffice/Admin/CheckUpdates.mix', 'UPD', 2, core.get_menu_id('SAT')
UNION ALL SELECT 'Translate MixERP', '~/Modules/BackOffice/Admin/LocalizeMixERP.mix', 'TRA', 2, core.get_menu_id('SAT')
UNION ALL SELECT 'One Time Setup', NULL, 'OTS', 1, core.get_menu_id('BO')
UNION ALL SELECT 'Opening Inventory', '~/Modules/BackOffice/OTS/OpeningInventory.mix', 'OTSI', 2, core.get_menu_id('OTS');


/********************************************************************************
Copyright (C) Binod Nepal, Mix Open Foundation (http://mixof.org).

This file is part of MixERP.

MixERP is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

MixERP is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with MixERP.  If not, see <http://www.gnu.org/licenses/>.
***********************************************************************************/
--FRENCH
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('SA'), 'fr', 'ventes' UNION ALL
SELECT core.get_menu_id('PU'), 'fr', 'achat' UNION ALL
SELECT core.get_menu_id('ITM'), 'fr', 'Produits et Articles' UNION ALL
SELECT core.get_menu_id('FI'), 'fr', 'financement' UNION ALL
SELECT core.get_menu_id('BO'), 'fr', 'Back-Office' UNION ALL
SELECT core.get_menu_id('SAQ'), 'fr', 'Sales & Devis' UNION ALL
SELECT core.get_menu_id('DRS'), 'fr', 'Ventes directes' UNION ALL
SELECT core.get_menu_id('SQ'), 'fr', 'Devis de vente' UNION ALL
SELECT core.get_menu_id('SO'), 'fr', 'Commande client' UNION ALL
SELECT core.get_menu_id('SD'), 'fr', 'Vente livraison' UNION ALL
SELECT core.get_menu_id('RFC'), 'fr', 'Réception du client' UNION ALL
SELECT core.get_menu_id('SR'), 'fr', 'Retour sur les ventes' UNION ALL
SELECT core.get_menu_id('SSM'), 'fr', 'Le programme d''installation & entretien' UNION ALL
SELECT core.get_menu_id('ABS'), 'fr', 'Dalle de bonus pour les vendeurs' UNION ALL
SELECT core.get_menu_id('BSD'), 'fr', 'Détails du bonus dalle' UNION ALL
SELECT core.get_menu_id('SST'), 'fr', 'Équipes de vente' UNION ALL
SELECT core.get_menu_id('SSA'), 'fr', 'Vendeurs/vendeuses' UNION ALL
SELECT core.get_menu_id('BSA'), 'fr', 'Affectation de dalle de bonus' UNION ALL
SELECT core.get_menu_id('LF'), 'fr', 'Frais de retard' UNION ALL
SELECT core.get_menu_id('PAT'), 'fr', 'Conditions de paiement' UNION ALL
SELECT core.get_menu_id('RI'), 'fr', 'Factures récurrentes' UNION ALL
SELECT core.get_menu_id('RIS'), 'fr', 'Paramètres des factures récurrentes' UNION ALL
SELECT core.get_menu_id('SAR'), 'fr', 'Rapports sur les ventes' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'fr', 'Haut de la page points de vente' UNION ALL
SELECT core.get_menu_id('PUQ'), 'fr', 'Achat & citation' UNION ALL
SELECT core.get_menu_id('DRP'), 'fr', 'Achat direct' UNION ALL
SELECT core.get_menu_id('PO'), 'fr', 'Bon de commande' UNION ALL
SELECT core.get_menu_id('PRO'), 'fr', 'Achat Reorder' UNION ALL
SELECT core.get_menu_id('GRN'), 'fr', 'Entrée GRN' UNION ALL
SELECT core.get_menu_id('PR'), 'fr', 'Achat de retour' UNION ALL
SELECT core.get_menu_id('PUR'), 'fr', 'Rapports d''achat' UNION ALL
SELECT core.get_menu_id('IIM'), 'fr', 'Mouvements de stock' UNION ALL
SELECT core.get_menu_id('STJ'), 'fr', 'Feuille de transfert de stock' UNION ALL
SELECT core.get_menu_id('STA'), 'fr', 'Ajustements de stocks' UNION ALL
SELECT core.get_menu_id('ISM'), 'fr', 'Le programme d''installation & entretien' UNION ALL
SELECT core.get_menu_id('STT'), 'fr', 'Types de magasins' UNION ALL
SELECT core.get_menu_id('STO'), 'fr', 'Magasins' UNION ALL
SELECT core.get_menu_id('SCS'), 'fr', 'Installation de compteur' UNION ALL
SELECT core.get_menu_id('PT'), 'fr', 'Types de partie' UNION ALL
SELECT core.get_menu_id('PA'), 'fr', 'Comptes de tiers' UNION ALL
SELECT core.get_menu_id('PSA'), 'fr', 'Adresses d''expédition' UNION ALL
SELECT core.get_menu_id('SSI'), 'fr', 'Gestion des Articles' UNION ALL
SELECT core.get_menu_id('SSC'), 'fr', 'Composé d''éléments' UNION ALL
SELECT core.get_menu_id('SSCD'), 'fr', 'Détails de l''élément composé' UNION ALL
SELECT core.get_menu_id('ICP'), 'fr', 'Prix de revient' UNION ALL
SELECT core.get_menu_id('ISP'), 'fr', 'Prix de vente' UNION ALL
SELECT core.get_menu_id('SIG'), 'fr', 'Groupes d''articles' UNION ALL
SELECT core.get_menu_id('SIT'), 'fr', 'Types d''éléments' UNION ALL
SELECT core.get_menu_id('SSB'), 'fr', 'Marques' UNION ALL
SELECT core.get_menu_id('UOM'), 'fr', 'Unités de mesure' UNION ALL
SELECT core.get_menu_id('CUOM'), 'fr', 'Composé d''unités de mesure' UNION ALL
SELECT core.get_menu_id('SHI'), 'fr', 'Informations de l''expéditeur' UNION ALL
SELECT core.get_menu_id('IR'), 'fr', 'Rapports' UNION ALL
SELECT core.get_menu_id('IAS'), 'fr', 'Relevé de compte de l''inventaire' UNION ALL
SELECT core.get_menu_id('FTT'), 'fr', 'Modèles de & de transactions' UNION ALL
SELECT core.get_menu_id('JVN'), 'fr', 'Bon écriture' UNION ALL
SELECT core.get_menu_id('UER'), 'fr', 'Mise à jour des taux de change' UNION ALL
SELECT core.get_menu_id('FVV'), 'fr', 'Vérification du bon' UNION ALL
SELECT core.get_menu_id('EOD'), 'fr', 'Fin de l''opération de la journée' UNION ALL
SELECT core.get_menu_id('FSM'), 'fr', 'Le programme d''installation & entretien' UNION ALL
SELECT core.get_menu_id('COA'), 'fr', 'Plan comptable' UNION ALL
SELECT core.get_menu_id('CUR'), 'fr', 'Gestion de la devise' UNION ALL
SELECT core.get_menu_id('CBA'), 'fr', 'Comptes bancaires' UNION ALL
SELECT core.get_menu_id('AGS'), 'fr', 'Vieillissement des dalles' UNION ALL
SELECT core.get_menu_id('CFH'), 'fr', 'Positions de trésorerie' UNION ALL
SELECT core.get_menu_id('CFS'), 'fr', 'Configuration des flux de trésorerie' UNION ALL
SELECT core.get_menu_id('CC'), 'fr', 'Centres de coûts' UNION ALL
SELECT core.get_menu_id('FIR'), 'fr', 'Rapports' UNION ALL
SELECT core.get_menu_id('AS'), 'fr', 'Relevé de compte' UNION ALL
SELECT core.get_menu_id('TB'), 'fr', 'Balance de vérification' UNION ALL
SELECT core.get_menu_id('PLA'), 'fr', 'Profit & compte de la perte' UNION ALL
SELECT core.get_menu_id('BS'), 'fr', 'Bilan' UNION ALL
SELECT core.get_menu_id('RET'), 'fr', 'Des Bénéfices Non Répartis' UNION ALL
SELECT core.get_menu_id('CF'), 'fr', 'Flux de trésorerie' UNION ALL
SELECT core.get_menu_id('BOTC'), 'fr', 'Configuration de l''impôt' UNION ALL
SELECT core.get_menu_id('TXM'), 'fr', 'Maître de l''impôt' UNION ALL
SELECT core.get_menu_id('TXA'), 'fr', 'Administration fiscale' UNION ALL
SELECT core.get_menu_id('STXT'), 'fr', 'Types de taxe de vente' UNION ALL
SELECT core.get_menu_id('STST'), 'fr', 'État des Taxes de vente' UNION ALL
SELECT core.get_menu_id('CTST'), 'fr', 'Taxes de vente de comtés' UNION ALL
SELECT core.get_menu_id('STX'), 'fr', 'Taxes de vente' UNION ALL
SELECT core.get_menu_id('STXD'), 'fr', 'Détails de la taxe de vente' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'fr', 'Types exonérés de taxe' UNION ALL
SELECT core.get_menu_id('STXEX'), 'fr', 'Exempte de la taxe de vente' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'fr', 'Détails exonéré de taxe de vente' UNION ALL
SELECT core.get_menu_id('SMP'), 'fr', 'Divers paramètres' UNION ALL
SELECT core.get_menu_id('TRF'), 'fr', 'Drapeaux' UNION ALL
SELECT core.get_menu_id('SEAR'), 'fr', 'Rapports d''audit' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'fr', 'Vue de l''ouverture de session' UNION ALL
SELECT core.get_menu_id('SOS'), 'fr', 'Installation de Office' UNION ALL
SELECT core.get_menu_id('SOB'), 'fr', 'Bureau & de la direction générale de la configuration' UNION ALL
SELECT core.get_menu_id('SCR'), 'fr', 'Installation de dépôt comptant' UNION ALL
SELECT core.get_menu_id('SDS'), 'fr', 'Département installation' UNION ALL
SELECT core.get_menu_id('SRM'), 'fr', 'Gestion des rôles' UNION ALL
SELECT core.get_menu_id('SUM'), 'fr', 'Gestion des utilisateurs' UNION ALL
SELECT core.get_menu_id('SES'), 'fr', 'Configuration de l''entité' UNION ALL
SELECT core.get_menu_id('SIS'), 'fr', 'Installation de l''industrie' UNION ALL
SELECT core.get_menu_id('SCRS'), 'fr', 'Programme d''installation de pays' UNION ALL
SELECT core.get_menu_id('SSS'), 'fr', 'Installation de l''État' UNION ALL
SELECT core.get_menu_id('SCTS'), 'fr', 'Comté de Setup' UNION ALL
SELECT core.get_menu_id('SFY'), 'fr', 'Informations de l''exercice' UNION ALL
SELECT core.get_menu_id('SFR'), 'fr', 'Fréquence & la gestion de l''exercice' UNION ALL
SELECT core.get_menu_id('SPM'), 'fr', 'Gestion des stratégies de' UNION ALL
SELECT core.get_menu_id('SVV'), 'fr', 'Politique sur la vérification bon' UNION ALL
SELECT core.get_menu_id('SAV'), 'fr', 'Politique sur la vérification automatique' UNION ALL
SELECT core.get_menu_id('SMA'), 'fr', 'Stratégie d''accès menu' UNION ALL
SELECT core.get_menu_id('SAP'), 'fr', 'Stratégie d''accès GL' UNION ALL
SELECT core.get_menu_id('SSP'), 'fr', 'Politique de boutique' UNION ALL
SELECT core.get_menu_id('SAT'), 'fr', 'Outils d''administration' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'fr', 'Outil de requête SQL' UNION ALL
SELECT core.get_menu_id('BAK'), 'fr', 'Sauvegarde base de données' UNION ALL
SELECT core.get_menu_id('PWD'), 'fr', 'Changer mot de passe utilisateur' UNION ALL
SELECT core.get_menu_id('UPD'), 'fr', 'Vérifiez Mise à jour' UNION ALL
SELECT core.get_menu_id('TRA'), 'fr', 'Traduire MixERP' UNION ALL
SELECT core.get_menu_id('OTS'), 'fr', 'Un réglage de l''heure' UNION ALL
SELECT core.get_menu_id('OTSI'), 'fr', 'Stock d''ouverture';

--GERMAN
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('STA'), 'de', 'Auf Anpassungen' UNION ALL
SELECT core.get_menu_id('PWD'), 'de', 'Benutzerpasswort ändern' UNION ALL
SELECT core.get_menu_id('UER'), 'de', 'Update Wechselkurse' UNION ALL
SELECT core.get_menu_id('BO'), 'de', 'Back Office' UNION ALL
SELECT core.get_menu_id('BAK'), 'de', 'Datenbank sichern' UNION ALL
SELECT core.get_menu_id('TB'), 'de', 'Rohbilanz' UNION ALL
SELECT core.get_menu_id('BS'), 'de', 'Bilanz' UNION ALL
SELECT core.get_menu_id('TRF'), 'de', 'Flaggen' UNION ALL
SELECT core.get_menu_id('BSA'), 'de', 'Bonus Slab Zuordnung' UNION ALL
SELECT core.get_menu_id('BSD'), 'de', 'Bonus Slab-Details' UNION ALL
SELECT core.get_menu_id('CC'), 'de', 'Kostenstellen' UNION ALL
SELECT core.get_menu_id('PU'), 'de', 'Kauf' UNION ALL
SELECT core.get_menu_id('PUQ'), 'de', 'Einkauf & Quotation' UNION ALL
SELECT core.get_menu_id('DRP'), 'de', 'Direktkauf' UNION ALL
SELECT core.get_menu_id('PRO'), 'de', 'Kauf Reorder' UNION ALL
SELECT core.get_menu_id('PR'), 'de', 'Kauf Return' UNION ALL
SELECT core.get_menu_id('SVV'), 'de', 'Gutschein Verification Politik' UNION ALL
SELECT core.get_menu_id('PAT'), 'de', 'Zahlungsbedingungen' UNION ALL
SELECT core.get_menu_id('BOTC'), 'de', 'Steuerkonfiguration' UNION ALL
SELECT core.get_menu_id('SSM'), 'de', 'Einrichtung und Wartung' UNION ALL
SELECT core.get_menu_id('ISM'), 'de', 'Einrichtung und Wartung' UNION ALL
SELECT core.get_menu_id('FSM'), 'de', 'Einrichtung und Wartung' UNION ALL
SELECT core.get_menu_id('CBA'), 'de', 'Bankkonten' UNION ALL
SELECT core.get_menu_id('PA'), 'de', 'Party-Accounts' UNION ALL
SELECT core.get_menu_id('SQ'), 'de', 'Vertrieb Quotation' UNION ALL
SELECT core.get_menu_id('SA'), 'de', 'Vertrieb' UNION ALL
SELECT core.get_menu_id('PLA'), 'de', 'Gewinn- und Verlustrechnung' UNION ALL
SELECT core.get_menu_id('SSCD'), 'de', 'Verbindung Einzelteil-Details' UNION ALL
SELECT core.get_menu_id('STXD'), 'de', 'Umsatzsteuer-Details' UNION ALL
SELECT core.get_menu_id('PSA'), 'de', 'Lieferadressen' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'de', 'Login Zeige' UNION ALL
SELECT core.get_menu_id('SD'), 'de', 'Vertrieb Lieferung' UNION ALL
SELECT core.get_menu_id('SST'), 'de', 'Vertriebsteams' UNION ALL
SELECT core.get_menu_id('SOB'), 'de', 'Büro & Filiale einrichten' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'de', 'Datenbankstatistik' UNION ALL
SELECT core.get_menu_id('IAS'), 'de', 'Bestandskontoauszug' UNION ALL
SELECT core.get_menu_id('AS'), 'de', 'Kontoauszug' UNION ALL
SELECT core.get_menu_id('RI'), 'de', 'Wiederkehrende Rechnungen' UNION ALL
SELECT core.get_menu_id('SAT'), 'de', 'Admin Tools' UNION ALL
SELECT core.get_menu_id('EOD'), 'de', 'End of Day Betrieb' UNION ALL
SELECT core.get_menu_id('FI'), 'de', 'Finanzen' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'de', 'Steuerbefreiung Typen' UNION ALL
SELECT core.get_menu_id('SFY'), 'de', 'Geschäftsjahresinformationen' UNION ALL
SELECT core.get_menu_id('TXA'), 'de', 'Steuerbehörden' UNION ALL
SELECT core.get_menu_id('CF'), 'de', 'Cashflow' UNION ALL
SELECT core.get_menu_id('CFH'), 'de', 'Kapitalflussüberschriften' UNION ALL
SELECT core.get_menu_id('SRM'), 'de', 'Rollenverwaltung' UNION ALL
SELECT core.get_menu_id('SUM'), 'de', 'Benutzerverwaltung' UNION ALL
SELECT core.get_menu_id('SFR'), 'de', 'Frequenz & Geschäftsjahr Verwaltung' UNION ALL
SELECT core.get_menu_id('CUR'), 'de', 'Währungsmanagement' UNION ALL
SELECT core.get_menu_id('SPM'), 'de', 'Policy Management' UNION ALL
SELECT core.get_menu_id('SAP'), 'de', 'Hauptbuch-Richtlinien' UNION ALL
SELECT core.get_menu_id('SIG'), 'de', 'Artikelgruppen' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'de', 'Sales Tax Exempt Einzelheiten' UNION ALL
SELECT core.get_menu_id('CTST'), 'de', 'Grafschaft Umsatzsteuer' UNION ALL
SELECT core.get_menu_id('STST'), 'de', 'State Sales Taxes' UNION ALL
SELECT core.get_menu_id('STX'), 'de', 'Umsatzsteuer' UNION ALL
SELECT core.get_menu_id('SHI'), 'de', 'Shipper Informationen' UNION ALL
SELECT core.get_menu_id('SOS'), 'de', 'Office Setup' UNION ALL
SELECT core.get_menu_id('OTSI'), 'de', 'Öffnungs Inventar' UNION ALL
SELECT core.get_menu_id('STXEX'), 'de', 'Umsatzsteuer befreit' UNION ALL
SELECT core.get_menu_id('SSI'), 'de', 'Artikelpflege' UNION ALL
SELECT core.get_menu_id('SSC'), 'de', 'Compound Artikel' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'de', 'Meistverkaufte Artikel' UNION ALL
SELECT core.get_menu_id('STJ'), 'de', 'Umlagerung Blatt' UNION ALL
SELECT core.get_menu_id('JVN'), 'de', 'Journal Gutschein Eintrag' UNION ALL
SELECT core.get_menu_id('AGS'), 'de', 'Ageing Brammen' UNION ALL
SELECT core.get_menu_id('SSB'), 'de', 'Brands' UNION ALL
SELECT core.get_menu_id('GRN'), 'de', 'Wareneingang Hinweis Eintrag' UNION ALL
SELECT core.get_menu_id('TXM'), 'de', 'Steuern Meister' UNION ALL
SELECT core.get_menu_id('IIM'), 'de', 'Lagerbewegungen' UNION ALL
SELECT core.get_menu_id('OTS'), 'de', 'Eine Zeiteinstellung' UNION ALL
SELECT core.get_menu_id('PO'), 'de', 'Auftragsbestätigung' UNION ALL
SELECT core.get_menu_id('ISP'), 'de', 'Verkaufs Preise' UNION ALL
SELECT core.get_menu_id('SMP'), 'de', 'Verschiedene Parameter' UNION ALL
SELECT core.get_menu_id('SO'), 'de', 'Sales Order' UNION ALL
SELECT core.get_menu_id('COA'), 'de', 'Kontenplan' UNION ALL
SELECT core.get_menu_id('SSP'), 'de', 'Speicher-Politik' UNION ALL
SELECT core.get_menu_id('SMA'), 'de', 'Menü-Richtlinien' UNION ALL
SELECT core.get_menu_id('SAV'), 'de', 'Automatische Verifikation Politik' UNION ALL
SELECT core.get_menu_id('ICP'), 'de', 'Kosten Preise' UNION ALL
SELECT core.get_menu_id('ITM'), 'de', 'Produkte & Angebote' UNION ALL
SELECT core.get_menu_id('RFC'), 'de', 'Empfang vom Kunden' UNION ALL
SELECT core.get_menu_id('IR'), 'de', 'Berichte' UNION ALL
SELECT core.get_menu_id('FIR'), 'de', 'Berichte' UNION ALL
SELECT core.get_menu_id('SEAR'), 'de', 'Prüfungsberichte' UNION ALL
SELECT core.get_menu_id('PUR'), 'de', 'Kauf Berichte' UNION ALL
SELECT core.get_menu_id('SAR'), 'de', 'Verkaufsberichte' UNION ALL
SELECT core.get_menu_id('SR'), 'de', 'Absatzertrag' UNION ALL
SELECT core.get_menu_id('SCS'), 'de', 'Zähler-Setup' UNION ALL
SELECT core.get_menu_id('SCTS'), 'de', 'Grafschaft-Setup' UNION ALL
SELECT core.get_menu_id('SDS'), 'de', 'Abteilung einrichten' UNION ALL
SELECT core.get_menu_id('SCR'), 'de', 'Barzahlung Repository einrichten' UNION ALL
SELECT core.get_menu_id('SES'), 'de', 'Entity-Setup' UNION ALL
SELECT core.get_menu_id('SSS'), 'de', 'staatliche Einrichtung' UNION ALL
SELECT core.get_menu_id('SIS'), 'de', 'Industrie-Setup' UNION ALL
SELECT core.get_menu_id('RIS'), 'de', 'Wiederkehrende Rechnung einrichten' UNION ALL
SELECT core.get_menu_id('SCRS'), 'de', 'Land-Setup' UNION ALL
SELECT core.get_menu_id('ABS'), 'de', 'Bonus Bramme für Aussendienst' UNION ALL
SELECT core.get_menu_id('STO'), 'de', 'Shops' UNION ALL
SELECT core.get_menu_id('LF'), 'de', 'Späte Gebühren' UNION ALL
SELECT core.get_menu_id('STT'), 'de', 'Shop Typen' UNION ALL
SELECT core.get_menu_id('STXT'), 'de', 'Umsatzsteuerarten' UNION ALL
SELECT core.get_menu_id('PT'), 'de', 'Party-Typen' UNION ALL
SELECT core.get_menu_id('FTT'), 'de', 'Transaktionen und Vorlagen' UNION ALL
SELECT core.get_menu_id('UOM'), 'de', 'Maßeinheiten' UNION ALL
SELECT core.get_menu_id('CUOM'), 'de', 'Verbindung Maßeinheiten' UNION ALL
SELECT core.get_menu_id('DRS'), 'de', 'Direct Sales' UNION ALL
SELECT core.get_menu_id('SAQ'), 'de', 'Vertrieb Quotation' UNION ALL
SELECT core.get_menu_id('SSA'), 'de', 'Aussendienst' UNION ALL
SELECT core.get_menu_id('FVV'), 'de', 'Gutschein Verification';

--RUSSIAN
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'ru', 'Бонус Плиты для продавцов' UNION ALL
SELECT core.get_menu_id('AGS'), 'ru', 'Старение плиты' UNION ALL
SELECT core.get_menu_id('AS'), 'ru', 'Выписка по счету' UNION ALL
SELECT core.get_menu_id('BAK'), 'ru', 'Резервное копирование базы данных' UNION ALL
SELECT core.get_menu_id('BO'), 'ru', 'бэк-офис' UNION ALL
SELECT core.get_menu_id('BOTC'), 'ru', 'Налоговый конфигурации' UNION ALL
SELECT core.get_menu_id('BS'), 'ru', 'баланс' UNION ALL
SELECT core.get_menu_id('BSA'), 'ru', 'Бонус Плиты Назначение' UNION ALL
SELECT core.get_menu_id('BSD'), 'ru', 'Бонус Плиты Подробности' UNION ALL
SELECT core.get_menu_id('CBA'), 'ru', 'Банковские счета' UNION ALL
SELECT core.get_menu_id('CC'), 'ru', 'МВЗ' UNION ALL
SELECT core.get_menu_id('CF'), 'ru', 'Денежный Поток' UNION ALL
SELECT core.get_menu_id('CFH'), 'ru', 'Денежные средства Заголовки потока' UNION ALL
SELECT core.get_menu_id('COA'), 'ru', 'План счетов' UNION ALL
SELECT core.get_menu_id('CTST'), 'ru', 'Графство налог с продаж' UNION ALL
SELECT core.get_menu_id('CUOM'), 'ru', 'Составные единицы измерения' UNION ALL
SELECT core.get_menu_id('CUR'), 'ru', 'Валюта управления' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'ru', 'Статистика базы данных' UNION ALL
SELECT core.get_menu_id('DRP'), 'ru', 'Прямая Покупка' UNION ALL
SELECT core.get_menu_id('DRS'), 'ru', 'Прямые продажи' UNION ALL
SELECT core.get_menu_id('EOD'), 'ru', 'Конец операционного дня' UNION ALL
SELECT core.get_menu_id('FI'), 'ru', 'финансы' UNION ALL
SELECT core.get_menu_id('FIR'), 'ru', 'Отчеты' UNION ALL
SELECT core.get_menu_id('FSM'), 'ru', 'Настройка и обслуживание' UNION ALL
SELECT core.get_menu_id('FTT'), 'ru', 'Операции и шаблоны' UNION ALL
SELECT core.get_menu_id('FVV'), 'ru', 'Ваучер Проверка' UNION ALL
SELECT core.get_menu_id('GRN'), 'ru', 'Товары Поступило Примечание Вступление' UNION ALL
SELECT core.get_menu_id('IAS'), 'ru', 'Выписка по счету Инвентарь' UNION ALL
SELECT core.get_menu_id('ICP'), 'ru', 'Стоимость Цены' UNION ALL
SELECT core.get_menu_id('IIM'), 'ru', 'Инвентаризация движения' UNION ALL
SELECT core.get_menu_id('IR'), 'ru', 'Отчеты' UNION ALL
SELECT core.get_menu_id('ISM'), 'ru', 'Настройка и обслуживание' UNION ALL
SELECT core.get_menu_id('ISP'), 'ru', 'Отпускные цены' UNION ALL
SELECT core.get_menu_id('ITM'), 'ru', 'Продукты и товары' UNION ALL
SELECT core.get_menu_id('JVN'), 'ru', 'Журнал Ваучер запись' UNION ALL
SELECT core.get_menu_id('LF'), 'ru', 'Штраф за просрочку платежей' UNION ALL
SELECT core.get_menu_id('OTS'), 'ru', 'Один Время установки' UNION ALL
SELECT core.get_menu_id('OTSI'), 'ru', 'Открытие Инвентарь' UNION ALL
SELECT core.get_menu_id('PA'), 'ru', 'Вечеринка счета' UNION ALL
SELECT core.get_menu_id('PAT'), 'ru', 'условия платежа' UNION ALL
SELECT core.get_menu_id('PLA'), 'ru', 'Прибыль и убытках' UNION ALL
SELECT core.get_menu_id('PO'), 'ru', 'Заказ На Покупку' UNION ALL
SELECT core.get_menu_id('PR'), 'ru', 'Покупка Возврат' UNION ALL
SELECT core.get_menu_id('PRO'), 'ru', 'Покупка Reorder' UNION ALL
SELECT core.get_menu_id('PSA'), 'ru', 'Доставка Адреса' UNION ALL
SELECT core.get_menu_id('PT'), 'ru', 'Вечеринка Типы' UNION ALL
SELECT core.get_menu_id('PU'), 'ru', 'покупка' UNION ALL
SELECT core.get_menu_id('PUQ'), 'ru', 'Покупка и цитаты' UNION ALL
SELECT core.get_menu_id('PUR'), 'ru', 'Покупка Отчеты' UNION ALL
SELECT core.get_menu_id('PWD'), 'ru', 'Изменить пользователя Пароль' UNION ALL
SELECT core.get_menu_id('RFC'), 'ru', 'Получении от клиента' UNION ALL
SELECT core.get_menu_id('RI'), 'ru', 'Повторяющиеся Счета' UNION ALL
SELECT core.get_menu_id('RIS'), 'ru', 'Повторяющиеся установки Счет' UNION ALL
SELECT core.get_menu_id('SA'), 'ru', 'продажа' UNION ALL
SELECT core.get_menu_id('SAP'), 'ru', 'Политика доступа GL' UNION ALL
SELECT core.get_menu_id('SAQ'), 'ru', 'Цитата продаж' UNION ALL
SELECT core.get_menu_id('SAR'), 'ru', 'Отчеты по продажам' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'ru', 'Самые продаваемые товары' UNION ALL
SELECT core.get_menu_id('SAT'), 'ru', 'Действия администратора Инструменты' UNION ALL
SELECT core.get_menu_id('SAV'), 'ru', 'Политика Автоматическая проверка' UNION ALL
SELECT core.get_menu_id('SCR'), 'ru', 'Настройка наличными Repository' UNION ALL
SELECT core.get_menu_id('SCRS'), 'ru', 'Страна Setup' UNION ALL
SELECT core.get_menu_id('SCS'), 'ru', 'Счетчик установки' UNION ALL
SELECT core.get_menu_id('SCTS'), 'ru', 'Настройка County' UNION ALL
SELECT core.get_menu_id('SD'), 'ru', 'продажи Доставка' UNION ALL
SELECT core.get_menu_id('SDS'), 'ru', 'Настройка Департамент' UNION ALL
SELECT core.get_menu_id('SEAR'), 'ru', 'Финансовые отчеты' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'ru', 'Войти Посмотреть' UNION ALL
SELECT core.get_menu_id('SES'), 'ru', 'Entity Setup' UNION ALL
SELECT core.get_menu_id('SFR'), 'ru', 'Управление частотой и финансовый год' UNION ALL
SELECT core.get_menu_id('SFY'), 'ru', 'Финансовый год Информация' UNION ALL
SELECT core.get_menu_id('SHI'), 'ru', 'Грузовладелец информация' UNION ALL
SELECT core.get_menu_id('SIG'), 'ru', 'Группы товаров' UNION ALL
SELECT core.get_menu_id('SIS'), 'ru', 'Настройка Промышленность' UNION ALL
SELECT core.get_menu_id('SMA'), 'ru', 'Меню политика доступа' UNION ALL
SELECT core.get_menu_id('SMP'), 'ru', 'Разное параметры' UNION ALL
SELECT core.get_menu_id('SO'), 'ru', 'продажи Заказать' UNION ALL
SELECT core.get_menu_id('SOB'), 'ru', 'Управление и отделения установки' UNION ALL
SELECT core.get_menu_id('SOS'), 'ru', 'Программа установки Office' UNION ALL
SELECT core.get_menu_id('SPM'), 'ru', 'Управление политиками' UNION ALL
SELECT core.get_menu_id('SQ'), 'ru', 'Цитата продаж' UNION ALL
SELECT core.get_menu_id('SR'), 'ru', 'продажи Вернуться' UNION ALL
SELECT core.get_menu_id('SRM'), 'ru', 'Роль управления' UNION ALL
SELECT core.get_menu_id('SSA'), 'ru', 'Продавцы' UNION ALL
SELECT core.get_menu_id('SSB'), 'ru', 'Бренды' UNION ALL
SELECT core.get_menu_id('SSC'), 'ru', 'Составные товары' UNION ALL
SELECT core.get_menu_id('SSCD'), 'ru', 'Соединение Пункт подробности' UNION ALL
SELECT core.get_menu_id('SSI'), 'ru', 'Пункт технического обслуживания' UNION ALL
SELECT core.get_menu_id('SSM'), 'ru', 'Настройка и обслуживание' UNION ALL
SELECT core.get_menu_id('SSP'), 'ru', 'Политика магазина' UNION ALL
SELECT core.get_menu_id('SSS'), 'ru', 'Государственный Setup' UNION ALL
SELECT core.get_menu_id('SST'), 'ru', 'Продажи команды' UNION ALL
SELECT core.get_menu_id('STA'), 'ru', 'Сток Корректировки' UNION ALL
SELECT core.get_menu_id('STJ'), 'ru', 'Перемещение запаса журнал' UNION ALL
SELECT core.get_menu_id('STO'), 'ru', 'магазины' UNION ALL
SELECT core.get_menu_id('STST'), 'ru', 'Государственные налогов с продаж' UNION ALL
SELECT core.get_menu_id('STT'), 'ru', 'Типы магазин' UNION ALL
SELECT core.get_menu_id('STX'), 'ru', 'налог с продаж' UNION ALL
SELECT core.get_menu_id('STXD'), 'ru', 'Налог на продажу Подробнее' UNION ALL
SELECT core.get_menu_id('STXEX'), 'ru', 'Налог на продажу льготников' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'ru', 'Налог на продажу Освобожденные Подробнее' UNION ALL
SELECT core.get_menu_id('STXT'), 'ru', 'Типы Налог на продажу' UNION ALL
SELECT core.get_menu_id('SUM'), 'ru', 'Управление пользователями' UNION ALL
SELECT core.get_menu_id('SVV'), 'ru', 'Политика Ваучер Проверка' UNION ALL
SELECT core.get_menu_id('TB'), 'ru', 'пробный баланс' UNION ALL
SELECT core.get_menu_id('TRF'), 'ru', 'Флаги' UNION ALL
SELECT core.get_menu_id('TXA'), 'ru', 'Налоговые органы' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'ru', 'Освобождаются от налогообложения Типы' UNION ALL
SELECT core.get_menu_id('TXM'), 'ru', 'Налоговый Мастер' UNION ALL
SELECT core.get_menu_id('UER'), 'ru', 'Update Wechselkurse' UNION ALL
SELECT core.get_menu_id('UOM'), 'ru', 'Единицы измерения';

--JAPANESE

INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'ja', '販売員のためのボーナススラブ' UNION ALL
SELECT core.get_menu_id('AGS'), 'ja', '高齢スラブ' UNION ALL
SELECT core.get_menu_id('AS'), 'ja', '取引明細書' UNION ALL
SELECT core.get_menu_id('BAK'), 'ja', 'バックアップ·データベース' UNION ALL
SELECT core.get_menu_id('BO'), 'ja', 'バックオフィス' UNION ALL
SELECT core.get_menu_id('BOTC'), 'ja', '税の設定' UNION ALL
SELECT core.get_menu_id('BS'), 'ja', 'バランスシート' UNION ALL
SELECT core.get_menu_id('BSA'), 'ja', 'ボーナススラブの割り当て' UNION ALL
SELECT core.get_menu_id('BSD'), 'ja', 'ボーナススラブ詳細' UNION ALL
SELECT core.get_menu_id('CBA'), 'ja', '銀行口座' UNION ALL
SELECT core.get_menu_id('CC'), 'ja', '原価センタ' UNION ALL
SELECT core.get_menu_id('CF'), 'ja', '現金流量' UNION ALL
SELECT core.get_menu_id('CFH'), 'ja', 'キャッシュフロー見出し' UNION ALL
SELECT core.get_menu_id('COA'), 'ja', '勘定科目一覧表' UNION ALL
SELECT core.get_menu_id('CTST'), 'ja', '郡の売上税' UNION ALL
SELECT core.get_menu_id('CUOM'), 'ja', 'メジャーの化合物単位' UNION ALL
SELECT core.get_menu_id('CUR'), 'ja', '通貨管理' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'ja', 'データベース統計' UNION ALL
SELECT core.get_menu_id('DRP'), 'ja', '直接購入' UNION ALL
SELECT core.get_menu_id('DRS'), 'ja', '直販' UNION ALL
SELECT core.get_menu_id('EOD'), 'ja', 'デイ操作の終了' UNION ALL
SELECT core.get_menu_id('FI'), 'ja', '金融' UNION ALL
SELECT core.get_menu_id('FIR'), 'ja', 'レポート' UNION ALL
SELECT core.get_menu_id('FSM'), 'ja', 'セットアップとメンテナンス' UNION ALL
SELECT core.get_menu_id('FTT'), 'ja', '取引＆テンプレート' UNION ALL
SELECT core.get_menu_id('FVV'), 'ja', 'バウチャーの検証' UNION ALL
SELECT core.get_menu_id('GRN'), 'ja', 'GRNエントリー' UNION ALL
SELECT core.get_menu_id('IAS'), 'ja', '在庫勘定書' UNION ALL
SELECT core.get_menu_id('ICP'), 'ja', 'コスト価格' UNION ALL
SELECT core.get_menu_id('IIM'), 'ja', '在庫変動' UNION ALL
SELECT core.get_menu_id('IR'), 'ja', 'レポート' UNION ALL
SELECT core.get_menu_id('ISM'), 'ja', 'セットアップとメンテナンス' UNION ALL
SELECT core.get_menu_id('ISP'), 'ja', '販売価格' UNION ALL
SELECT core.get_menu_id('ITM'), 'ja', '製品＆アイテム' UNION ALL
SELECT core.get_menu_id('JVN'), 'ja', 'ジャーナルバウチャーエントリー' UNION ALL
SELECT core.get_menu_id('LF'), 'ja', '延滞料' UNION ALL
SELECT core.get_menu_id('OTS'), 'ja', 'ワンタイムの設定' UNION ALL
SELECT core.get_menu_id('OTSI'), 'ja', 'オープニングインベントリ' UNION ALL
SELECT core.get_menu_id('PA'), 'ja', 'パーティーのアカウント' UNION ALL
SELECT core.get_menu_id('PAT'), 'ja', '支払条件' UNION ALL
SELECT core.get_menu_id('PLA'), 'ja', '損益勘定' UNION ALL
SELECT core.get_menu_id('PO'), 'ja', '注文書' UNION ALL
SELECT core.get_menu_id('PR'), 'ja', '購入戻る' UNION ALL
SELECT core.get_menu_id('PRO'), 'ja', '購入並べ替え' UNION ALL
SELECT core.get_menu_id('PSA'), 'ja', '配送先住所' UNION ALL
SELECT core.get_menu_id('PT'), 'ja', 'パーティーの種類' UNION ALL
SELECT core.get_menu_id('PU'), 'ja', '購入' UNION ALL
SELECT core.get_menu_id('PUQ'), 'ja', '購入＆見積' UNION ALL
SELECT core.get_menu_id('PUR'), 'ja', '購入レポート' UNION ALL
SELECT core.get_menu_id('PWD'), 'ja', 'ユーザーパスワードの変更' UNION ALL
SELECT core.get_menu_id('RFC'), 'ja', 'お客様からの領収書' UNION ALL
SELECT core.get_menu_id('RI'), 'ja', '定期的な請求書' UNION ALL
SELECT core.get_menu_id('RIS'), 'ja', '経常請求書のセットアップ' UNION ALL
SELECT core.get_menu_id('SA'), 'ja', 'セールス' UNION ALL
SELECT core.get_menu_id('SAP'), 'ja', 'GLアクセスポリシー' UNION ALL
SELECT core.get_menu_id('SAQ'), 'ja', 'セールス＆見積' UNION ALL
SELECT core.get_menu_id('SAR'), 'ja', '営業レポート' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'ja', '人気商品ランキング' UNION ALL
SELECT core.get_menu_id('SAT'), 'ja', '管理ツール' UNION ALL
SELECT core.get_menu_id('SAV'), 'ja', '自動検証ポリシー' UNION ALL
SELECT core.get_menu_id('SCR'), 'ja', '現金リポジトリのセットアップ' UNION ALL
SELECT core.get_menu_id('SCRS'), 'ja', '国のセットアップ' UNION ALL
SELECT core.get_menu_id('SCS'), 'ja', 'カウンターのセットアップ' UNION ALL
SELECT core.get_menu_id('SCTS'), 'ja', '郡のセットアップ' UNION ALL
SELECT core.get_menu_id('SD'), 'ja', '販売配達' UNION ALL
SELECT core.get_menu_id('SDS'), 'ja', '部署のセットアップ' UNION ALL
SELECT core.get_menu_id('SEAR'), 'ja', '監査レポート' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'ja', 'ログインを見る' UNION ALL
SELECT core.get_menu_id('SES'), 'ja', 'エンティティのセットアップ' UNION ALL
SELECT core.get_menu_id('SFR'), 'ja', '周波数＆会計年度の経営' UNION ALL
SELECT core.get_menu_id('SFY'), 'ja', '年度情報' UNION ALL
SELECT core.get_menu_id('SHI'), 'ja', '荷送人情報' UNION ALL
SELECT core.get_menu_id('SIG'), 'ja', 'アイテムのグループ' UNION ALL
SELECT core.get_menu_id('SIS'), 'ja', '業界のセットアップ' UNION ALL
SELECT core.get_menu_id('SMA'), 'ja', 'メニューアクセスポリシー' UNION ALL
SELECT core.get_menu_id('SMP'), 'ja', 'その他のパラメータ' UNION ALL
SELECT core.get_menu_id('SO'), 'ja', '販売注文' UNION ALL
SELECT core.get_menu_id('SOB'), 'ja', 'オフィス＆支店セットアップ' UNION ALL
SELECT core.get_menu_id('SOS'), 'ja', 'Officeセットアップ' UNION ALL
SELECT core.get_menu_id('SPM'), 'ja', '政策管理' UNION ALL
SELECT core.get_menu_id('SQ'), 'ja', '販売見積' UNION ALL
SELECT core.get_menu_id('SR'), 'ja', '販売戻る' UNION ALL
SELECT core.get_menu_id('SRM'), 'ja', 'ロール管理' UNION ALL
SELECT core.get_menu_id('SSA'), 'ja', '販売員' UNION ALL
SELECT core.get_menu_id('SSB'), 'ja', 'ブランド' UNION ALL
SELECT core.get_menu_id('SSC'), 'ja', '複合アイテム' UNION ALL
SELECT core.get_menu_id('SSCD'), 'ja', '複合商品詳細' UNION ALL
SELECT core.get_menu_id('SSI'), 'ja', 'アイテムのメンテナンス' UNION ALL
SELECT core.get_menu_id('SSM'), 'ja', 'セットアップとメンテナンス' UNION ALL
SELECT core.get_menu_id('SSP'), 'ja', 'ストアポリシー' UNION ALL
SELECT core.get_menu_id('SSS'), 'ja', '国家のセットアップ' UNION ALL
SELECT core.get_menu_id('SST'), 'ja', 'セールスチーム' UNION ALL
SELECT core.get_menu_id('STA'), 'ja', 'ストック調整' UNION ALL
SELECT core.get_menu_id('STJ'), 'ja', '株式移転ジャーナル' UNION ALL
SELECT core.get_menu_id('STO'), 'ja', 'ストア' UNION ALL
SELECT core.get_menu_id('STST'), 'ja', '状態の売上税' UNION ALL
SELECT core.get_menu_id('STT'), 'ja', 'ストア型' UNION ALL
SELECT core.get_menu_id('STX'), 'ja', '売上税' UNION ALL
SELECT core.get_menu_id('STXD'), 'ja', '消費税の詳細' UNION ALL
SELECT core.get_menu_id('STXEX'), 'ja', '売上税免除' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'ja', '売上税免除詳細' UNION ALL
SELECT core.get_menu_id('STXT'), 'ja', '売上税タイプ' UNION ALL
SELECT core.get_menu_id('SUM'), 'ja', 'ユーザー管理' UNION ALL
SELECT core.get_menu_id('SVV'), 'ja', 'バウチャーの検証方針' UNION ALL
SELECT core.get_menu_id('TB'), 'ja', '試算表' UNION ALL
SELECT core.get_menu_id('TRF'), 'ja', 'フラグ' UNION ALL
SELECT core.get_menu_id('TXA'), 'ja', '税務当局' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'ja', '税免除の種類' UNION ALL
SELECT core.get_menu_id('TXM'), 'ja', '税マスター' UNION ALL
SELECT core.get_menu_id('UER'), 'ja', '更新の為替レート' UNION ALL
SELECT core.get_menu_id('UOM'), 'ja', '測定の単位';


--SPANISH

INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'es', 'Losa bonificación sobre los Vendedores' UNION ALL
SELECT core.get_menu_id('AGS'), 'es', 'Losas Envejecimiento' UNION ALL
SELECT core.get_menu_id('AS'), 'es', 'Estado de Cuenta' UNION ALL
SELECT core.get_menu_id('BAK'), 'es', 'Base de datos de copia de seguridad' UNION ALL
SELECT core.get_menu_id('BO'), 'es', 'Back Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'es', 'Configuración de Impuestos' UNION ALL
SELECT core.get_menu_id('BS'), 'es', 'el balance' UNION ALL
SELECT core.get_menu_id('BSA'), 'es', 'Bono Slab Asignación' UNION ALL
SELECT core.get_menu_id('BSD'), 'es', 'Bono Slab Detalles' UNION ALL
SELECT core.get_menu_id('CBA'), 'es', 'Cuentas bancarias' UNION ALL
SELECT core.get_menu_id('CC'), 'es', 'Centros de costes' UNION ALL
SELECT core.get_menu_id('CF'), 'es', 'Flujo De Fondos' UNION ALL
SELECT core.get_menu_id('CFH'), 'es', 'Cash Flow encabezamientos' UNION ALL
SELECT core.get_menu_id('COA'), 'es', 'Plan General de Contabilidad' UNION ALL
SELECT core.get_menu_id('CTST'), 'es', 'Impuestos Condados de venta' UNION ALL
SELECT core.get_menu_id('CUOM'), 'es', 'Unidades compuestas de Medida' UNION ALL
SELECT core.get_menu_id('CUR'), 'es', 'Gestión de moneda' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'es', 'Base de Estadísticas' UNION ALL
SELECT core.get_menu_id('DRP'), 'es', 'Compra Directa' UNION ALL
SELECT core.get_menu_id('DRS'), 'es', 'Venta Directa' UNION ALL
SELECT core.get_menu_id('EOD'), 'es', 'Al final del día de operación' UNION ALL
SELECT core.get_menu_id('FI'), 'es', 'Finanzas' UNION ALL
SELECT core.get_menu_id('FIR'), 'es', 'Informes' UNION ALL
SELECT core.get_menu_id('FSM'), 'es', 'Creación y Mantenimiento' UNION ALL
SELECT core.get_menu_id('FTT'), 'es', 'Transacciones y plantillas' UNION ALL
SELECT core.get_menu_id('FVV'), 'es', 'Verificación Voucher' UNION ALL
SELECT core.get_menu_id('GRN'), 'es', 'Productos de Entrada Nota Recibido' UNION ALL
SELECT core.get_menu_id('IAS'), 'es', 'Estado de Cuenta de Inventario' UNION ALL
SELECT core.get_menu_id('ICP'), 'es', 'Los precios de coste' UNION ALL
SELECT core.get_menu_id('IIM'), 'es', 'Movimientos de Inventario' UNION ALL
SELECT core.get_menu_id('IR'), 'es', 'Informes' UNION ALL
SELECT core.get_menu_id('ISM'), 'es', 'Creación y Mantenimiento' UNION ALL
SELECT core.get_menu_id('ISP'), 'es', 'los precios de venta' UNION ALL
SELECT core.get_menu_id('ITM'), 'es', 'Productos y Artículos' UNION ALL
SELECT core.get_menu_id('JVN'), 'es', 'Entrada Comprobante de Diario' UNION ALL
SELECT core.get_menu_id('LF'), 'es', 'Recargos' UNION ALL
SELECT core.get_menu_id('OTS'), 'es', 'Una configuración de la hora' UNION ALL
SELECT core.get_menu_id('OTSI'), 'es', 'Inventario de apertura' UNION ALL
SELECT core.get_menu_id('PA'), 'es', 'Cuentas del Partido' UNION ALL
SELECT core.get_menu_id('PAT'), 'es', 'Condiciones de pago' UNION ALL
SELECT core.get_menu_id('PLA'), 'es', 'Winst- en verliesrekening...' UNION ALL
SELECT core.get_menu_id('PO'), 'es', 'Orden De Compra' UNION ALL
SELECT core.get_menu_id('PR'), 'es', 'Compra de Retorno' UNION ALL
SELECT core.get_menu_id('PRO'), 'es', 'Compra de reorden' UNION ALL
SELECT core.get_menu_id('PSA'), 'es', 'Direcciones de Envío' UNION ALL
SELECT core.get_menu_id('PT'), 'es', 'Tipos Party' UNION ALL
SELECT core.get_menu_id('PU'), 'es', 'Compra' UNION ALL
SELECT core.get_menu_id('PUQ'), 'es', 'Compra y Cotización' UNION ALL
SELECT core.get_menu_id('PUR'), 'es', 'Informes de Compra' UNION ALL
SELECT core.get_menu_id('PWD'), 'es', 'Cambiar contraseña de usuario' UNION ALL
SELECT core.get_menu_id('RFC'), 'es', 'Recibo del Cliente' UNION ALL
SELECT core.get_menu_id('RI'), 'es', 'facturas recurrentes' UNION ALL
SELECT core.get_menu_id('RIS'), 'es', 'Configuración Factura Recurrente' UNION ALL
SELECT core.get_menu_id('SA'), 'es', 'venta' UNION ALL
SELECT core.get_menu_id('SAP'), 'es', 'Política de Acceso General Ledger' UNION ALL
SELECT core.get_menu_id('SAQ'), 'es', 'Ventas y Cotización' UNION ALL
SELECT core.get_menu_id('SAR'), 'es', 'Informes de ventas' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'es', 'Top artículos más vendidos' UNION ALL
SELECT core.get_menu_id('SAT'), 'es', 'Herramientas de administración' UNION ALL
SELECT core.get_menu_id('SAV'), 'es', 'Política Automático de Verificación' UNION ALL
SELECT core.get_menu_id('SCR'), 'es', 'Configuración del depósito de efectivo' UNION ALL
SELECT core.get_menu_id('SCRS'), 'es', 'Configuración de país' UNION ALL
SELECT core.get_menu_id('SCS'), 'es', 'Configuración Contador' UNION ALL
SELECT core.get_menu_id('SCTS'), 'es', 'Configuración del Condado' UNION ALL
SELECT core.get_menu_id('SD'), 'es', 'Entrega Ventas' UNION ALL
SELECT core.get_menu_id('SDS'), 'es', 'afdeling Setup' UNION ALL
SELECT core.get_menu_id('SEAR'), 'es', 'Informes de Auditoría' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'es', 'Entrar Ver' UNION ALL
SELECT core.get_menu_id('SES'), 'es', 'Configuración entidad' UNION ALL
SELECT core.get_menu_id('SFR'), 'es', 'Gestión de Frecuencias y el año fiscal' UNION ALL
SELECT core.get_menu_id('SFY'), 'es', 'Información Fiscal Año' UNION ALL
SELECT core.get_menu_id('SHI'), 'es', 'Información Shipper' UNION ALL
SELECT core.get_menu_id('SIG'), 'es', 'los grupos de artículos' UNION ALL
SELECT core.get_menu_id('SIS'), 'es', 'Configuración de la Industria' UNION ALL
SELECT core.get_menu_id('SMA'), 'es', 'Menú política de acceso' UNION ALL
SELECT core.get_menu_id('SMP'), 'es', 'Parámetros Varios' UNION ALL
SELECT core.get_menu_id('SO'), 'es', 'Orden de Venta' UNION ALL
SELECT core.get_menu_id('SOB'), 'es', 'Instalación de Office y Poder' UNION ALL
SELECT core.get_menu_id('SOS'), 'es', 'instalación de Office' UNION ALL
SELECT core.get_menu_id('SPM'), 'es', 'Gestión de Políticas' UNION ALL
SELECT core.get_menu_id('SQ'), 'es', 'Cita Ventas' UNION ALL
SELECT core.get_menu_id('SR'), 'es', 'Volver Ventas' UNION ALL
SELECT core.get_menu_id('SRM'), 'es', 'Administración de funciones' UNION ALL
SELECT core.get_menu_id('SSA'), 'es', 'vendedores' UNION ALL
SELECT core.get_menu_id('SSB'), 'es', 'Marcas' UNION ALL
SELECT core.get_menu_id('SSC'), 'es', 'compuesto Artículos' UNION ALL
SELECT core.get_menu_id('SSCD'), 'es', 'Compuesto Detalles del artículo' UNION ALL
SELECT core.get_menu_id('SSI'), 'es', 'Mantenimiento de artículos' UNION ALL
SELECT core.get_menu_id('SSM'), 'es', 'Creación y Mantenimiento' UNION ALL
SELECT core.get_menu_id('SSP'), 'es', 'política de la tienda' UNION ALL
SELECT core.get_menu_id('SSS'), 'es', 'Configuración Estado' UNION ALL
SELECT core.get_menu_id('SST'), 'es', 'equipo de ventas' UNION ALL
SELECT core.get_menu_id('STA'), 'es', 'Ajustes de archivo' UNION ALL
SELECT core.get_menu_id('STJ'), 'es', 'Diario Stock Transfer' UNION ALL
SELECT core.get_menu_id('STO'), 'es', 'Tiendas' UNION ALL
SELECT core.get_menu_id('STST'), 'es', 'Impuestos estatales' UNION ALL
SELECT core.get_menu_id('STT'), 'es', 'Tipo de tienda' UNION ALL
SELECT core.get_menu_id('STX'), 'es', 'impuestos a las Ventas' UNION ALL
SELECT core.get_menu_id('STXD'), 'es', 'Detalles de impuesto sobre las ventas' UNION ALL
SELECT core.get_menu_id('STXEX'), 'es', 'Exime de impuestos de ventas' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'es', 'SalesTax Detalles Exentos' UNION ALL
SELECT core.get_menu_id('STXT'), 'es', 'Tipos de Impuestos de Ventas' UNION ALL
SELECT core.get_menu_id('SUM'), 'es', 'Gestión de usuarios' UNION ALL
SELECT core.get_menu_id('SVV'), 'es', 'Vale Política de Verificación' UNION ALL
SELECT core.get_menu_id('TB'), 'es', 'balance' UNION ALL
SELECT core.get_menu_id('TRF'), 'es', 'Banderas' UNION ALL
SELECT core.get_menu_id('TXA'), 'es', 'Agencia Tributaria' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'es', 'Impuestos Tipos Exentos' UNION ALL
SELECT core.get_menu_id('TXM'), 'es', 'Maestro de Impuestos' UNION ALL
SELECT core.get_menu_id('UER'), 'es', 'Actualización Cotizaciones' UNION ALL
SELECT core.get_menu_id('UOM'), 'es', 'Unidades de Medida';

--DUTCH
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'nl', 'Bonus Slab voor Verkopers' UNION ALL
SELECT core.get_menu_id('AGS'), 'nl', 'Vergrijzing Platen' UNION ALL
SELECT core.get_menu_id('AS'), 'nl', 'rekeningafschrift' UNION ALL
SELECT core.get_menu_id('BAK'), 'nl', 'backup Database' UNION ALL
SELECT core.get_menu_id('BO'), 'nl', 'Back Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'nl', 'belasting Configuratie' UNION ALL
SELECT core.get_menu_id('BS'), 'nl', 'balans' UNION ALL
SELECT core.get_menu_id('BSA'), 'nl', 'Bonus Slab Opdracht' UNION ALL
SELECT core.get_menu_id('BSD'), 'nl', 'Bonus Slab Details' UNION ALL
SELECT core.get_menu_id('CBA'), 'nl', 'bankrekeningen' UNION ALL
SELECT core.get_menu_id('CC'), 'nl', 'Kostenplaatsen' UNION ALL
SELECT core.get_menu_id('CF'), 'nl', 'Geldstroom' UNION ALL
SELECT core.get_menu_id('CFH'), 'nl', 'Cash Flow Koppen' UNION ALL
SELECT core.get_menu_id('COA'), 'nl', 'Rekeningschema' UNION ALL
SELECT core.get_menu_id('CTST'), 'nl', 'Provincies Sales Belastingen' UNION ALL
SELECT core.get_menu_id('CUOM'), 'nl', 'Verbinding meeteenheden' UNION ALL
SELECT core.get_menu_id('CUR'), 'nl', 'valuta management' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'nl', 'Database statistieken' UNION ALL
SELECT core.get_menu_id('DRP'), 'nl', 'direct Aankoop' UNION ALL
SELECT core.get_menu_id('DRS'), 'nl', 'Direct Sales' UNION ALL
SELECT core.get_menu_id('EOD'), 'nl', 'Einde van de dag Operatie' UNION ALL
SELECT core.get_menu_id('FI'), 'nl', 'Financiën' UNION ALL
SELECT core.get_menu_id('FIR'), 'nl', 'rapporten' UNION ALL
SELECT core.get_menu_id('FSM'), 'nl', 'Installatie & Onderhoud' UNION ALL
SELECT core.get_menu_id('FTT'), 'nl', 'Transactions & Templates' UNION ALL
SELECT core.get_menu_id('FVV'), 'nl', 'voucher Verificatie' UNION ALL
SELECT core.get_menu_id('GRN'), 'nl', 'Goederen Ontvangen Opmerking Entry' UNION ALL
SELECT core.get_menu_id('IAS'), 'nl', 'Inventaris rekeningafschrift' UNION ALL
SELECT core.get_menu_id('ICP'), 'nl', 'kostprijzen' UNION ALL
SELECT core.get_menu_id('IIM'), 'nl', 'inventaris Movements' UNION ALL
SELECT core.get_menu_id('IR'), 'nl', 'rapporten' UNION ALL
SELECT core.get_menu_id('ISM'), 'nl', 'Installatie & Onderhoud' UNION ALL
SELECT core.get_menu_id('ISP'), 'nl', 'verkoopprijs' UNION ALL
SELECT core.get_menu_id('ITM'), 'nl', 'Producten en Artikelen' UNION ALL
SELECT core.get_menu_id('JVN'), 'nl', 'Journal Voucher Entry' UNION ALL
SELECT core.get_menu_id('LF'), 'nl', 'late Vergoedingen' UNION ALL
SELECT core.get_menu_id('OTS'), 'nl', 'One Time Setup' UNION ALL
SELECT core.get_menu_id('OTSI'), 'nl', 'Het openen van Inventory' UNION ALL
SELECT core.get_menu_id('PA'), 'nl', 'partij Accounts' UNION ALL
SELECT core.get_menu_id('PAT'), 'nl', 'Betaalvoorwaarden' UNION ALL
SELECT core.get_menu_id('PLA'), 'nl', 'Winst- en verliesrekening' UNION ALL
SELECT core.get_menu_id('PO'), 'nl', 'direct Aankoop' UNION ALL
SELECT core.get_menu_id('PR'), 'nl', 'aankoop Return' UNION ALL
SELECT core.get_menu_id('PRO'), 'nl', 'aankoop opnieuw ordenen' UNION ALL
SELECT core.get_menu_id('PSA'), 'nl', 'afleveradres' UNION ALL
SELECT core.get_menu_id('PT'), 'nl', 'partij Types' UNION ALL
SELECT core.get_menu_id('PU'), 'nl', 'aankoop' UNION ALL
SELECT core.get_menu_id('PUQ'), 'nl', 'Inkoop & Offerte' UNION ALL
SELECT core.get_menu_id('PUR'), 'nl', 'aankoop Rapporten' UNION ALL
SELECT core.get_menu_id('PWD'), 'nl', 'Change User Password' UNION ALL
SELECT core.get_menu_id('RFC'), 'nl', 'Ontvangst van de klant' UNION ALL
SELECT core.get_menu_id('RI'), 'nl', 'terugkerende facturen' UNION ALL
SELECT core.get_menu_id('RIS'), 'nl', 'Terugkerende Invoice Setup' UNION ALL
SELECT core.get_menu_id('SA'), 'nl', 'Sales' UNION ALL
SELECT core.get_menu_id('SAP'), 'nl', 'GL Access Policy' UNION ALL
SELECT core.get_menu_id('SAQ'), 'nl', 'Sales & Quotation' UNION ALL
SELECT core.get_menu_id('SAR'), 'nl', 'Sales Reports' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'nl', 'Top Selling Items' UNION ALL
SELECT core.get_menu_id('SAT'), 'nl', 'Admin Tools' UNION ALL
SELECT core.get_menu_id('SAV'), 'nl', 'Automatisch Verificatie Beleid' UNION ALL
SELECT core.get_menu_id('SCR'), 'nl', 'Cash Repository Setup' UNION ALL
SELECT core.get_menu_id('SCRS'), 'nl', 'land Setup' UNION ALL
SELECT core.get_menu_id('SCS'), 'nl', 'Counter Setup' UNION ALL
SELECT core.get_menu_id('SCTS'), 'nl', 'County Setup' UNION ALL
SELECT core.get_menu_id('SD'), 'nl', 'Sales Delivery' UNION ALL
SELECT core.get_menu_id('SDS'), 'nl', 'afdeling Setup' UNION ALL
SELECT core.get_menu_id('SEAR'), 'nl', 'auditrapporten' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'nl', 'Inloggen View' UNION ALL
SELECT core.get_menu_id('SES'), 'nl', 'entiteit Setup' UNION ALL
SELECT core.get_menu_id('SFR'), 'nl', 'Frequentie & boekjaar management' UNION ALL
SELECT core.get_menu_id('SFY'), 'nl', 'Fiscale Jaar Informatie' UNION ALL
SELECT core.get_menu_id('SHI'), 'nl', 'verlader Informatie' UNION ALL
SELECT core.get_menu_id('SIG'), 'nl', 'Item Groepen' UNION ALL
SELECT core.get_menu_id('SIS'), 'nl', 'industrie Setup' UNION ALL
SELECT core.get_menu_id('SMA'), 'nl', 'Menu Access Policy' UNION ALL
SELECT core.get_menu_id('SMP'), 'nl', 'Diverse parameters' UNION ALL
SELECT core.get_menu_id('SO'), 'nl', 'Sales Order' UNION ALL
SELECT core.get_menu_id('SOB'), 'nl', 'Office & Branch Setup' UNION ALL
SELECT core.get_menu_id('SOS'), 'nl', 'Office Setup' UNION ALL
SELECT core.get_menu_id('SPM'), 'nl', 'Policy Management' UNION ALL
SELECT core.get_menu_id('SQ'), 'nl', 'Sales Offerte' UNION ALL
SELECT core.get_menu_id('SR'), 'nl', 'Sales Return' UNION ALL
SELECT core.get_menu_id('SRM'), 'nl', 'rol management' UNION ALL
SELECT core.get_menu_id('SSA'), 'nl', 'verkopers' UNION ALL
SELECT core.get_menu_id('SSB'), 'nl', 'merk' UNION ALL
SELECT core.get_menu_id('SSC'), 'nl', 'verbinding items' UNION ALL
SELECT core.get_menu_id('SSCD'), 'nl', 'Verbinding Item Details' UNION ALL
SELECT core.get_menu_id('SSI'), 'nl', 'Item Onderhoud' UNION ALL
SELECT core.get_menu_id('SSM'), 'nl', 'Installatie & Onderhoud' UNION ALL
SELECT core.get_menu_id('SSP'), 'nl', 'Store-beleid' UNION ALL
SELECT core.get_menu_id('SSS'), 'nl', 'Staat Setup' UNION ALL
SELECT core.get_menu_id('SST'), 'nl', 'Sales Teams' UNION ALL
SELECT core.get_menu_id('STA'), 'nl', 'Stock Aanpassingen' UNION ALL
SELECT core.get_menu_id('STJ'), 'nl', 'Stock Transfer Journal' UNION ALL
SELECT core.get_menu_id('STO'), 'nl', 'winkel' UNION ALL
SELECT core.get_menu_id('STST'), 'nl', 'Staat Sales Belastingen' UNION ALL
SELECT core.get_menu_id('STT'), 'nl', 'Store Type' UNION ALL
SELECT core.get_menu_id('STX'), 'nl', 'verkoop Belastingen' UNION ALL
SELECT core.get_menu_id('STXD'), 'nl', 'verkoop Belastingen Detail' UNION ALL
SELECT core.get_menu_id('STXEX'), 'nl', 'Verkoop Tax vrijstelt' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'nl', 'Verkoop vrijgesteld van belasting Details' UNION ALL
SELECT core.get_menu_id('STXT'), 'nl', 'Verkoop Belasting Types' UNION ALL
SELECT core.get_menu_id('SUM'), 'nl', 'user Management' UNION ALL
SELECT core.get_menu_id('SVV'), 'nl', 'Voucher Verificatie Beleid' UNION ALL
SELECT core.get_menu_id('TB'), 'nl', 'Trial Balance' UNION ALL
SELECT core.get_menu_id('TRF'), 'nl', 'vlaggen' UNION ALL
SELECT core.get_menu_id('TXA'), 'nl', 'Belastingdienst' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'nl', 'Vrijgesteld van belasting Types' UNION ALL
SELECT core.get_menu_id('TXM'), 'nl', 'belasting Master' UNION ALL
SELECT core.get_menu_id('UER'), 'nl', 'Bijwerken Wisselkoersen' UNION ALL
SELECT core.get_menu_id('UOM'), 'nl', 'Maateenheden';

--SIMPLIFIED CHINESE
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'zh', '奖金为平板销售人员' UNION ALL
SELECT core.get_menu_id('AGS'), 'zh', '老龄板坯' UNION ALL
SELECT core.get_menu_id('AS'), 'zh', '帐户对帐单' UNION ALL
SELECT core.get_menu_id('BAK'), 'zh', '备份数据库' UNION ALL
SELECT core.get_menu_id('BO'), 'zh', '后台' UNION ALL
SELECT core.get_menu_id('BOTC'), 'zh', '税务配置' UNION ALL
SELECT core.get_menu_id('BS'), 'zh', '资产负债表' UNION ALL
SELECT core.get_menu_id('BSA'), 'zh', '奖金分配板' UNION ALL
SELECT core.get_menu_id('BSD'), 'zh', '奖励板详细' UNION ALL
SELECT core.get_menu_id('CBA'), 'zh', '银行账户' UNION ALL
SELECT core.get_menu_id('CC'), 'zh', '成本中心' UNION ALL
SELECT core.get_menu_id('CF'), 'zh', '现金周转' UNION ALL
SELECT core.get_menu_id('CFH'), 'zh', '现金流标题' UNION ALL
SELECT core.get_menu_id('COA'), 'zh', '科目表' UNION ALL
SELECT core.get_menu_id('CTST'), 'zh', '县销售税' UNION ALL
SELECT core.get_menu_id('CUOM'), 'zh', '计量单位复合' UNION ALL
SELECT core.get_menu_id('CUR'), 'zh', '货币管理' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'zh', '数据库统计' UNION ALL
SELECT core.get_menu_id('DRP'), 'zh', '直接购买' UNION ALL
SELECT core.get_menu_id('DRS'), 'zh', '直销' UNION ALL
SELECT core.get_menu_id('EOD'), 'zh', '天运结束' UNION ALL
SELECT core.get_menu_id('FI'), 'zh', '金融' UNION ALL
SELECT core.get_menu_id('FIR'), 'zh', '报告' UNION ALL
SELECT core.get_menu_id('FSM'), 'zh', '安装与维护' UNION ALL
SELECT core.get_menu_id('FTT'), 'zh', '交易和模板' UNION ALL
SELECT core.get_menu_id('FVV'), 'zh', '优惠券验证' UNION ALL
SELECT core.get_menu_id('GRN'), 'zh', '收货票据' UNION ALL
SELECT core.get_menu_id('IAS'), 'zh', '库存帐户对帐单' UNION ALL
SELECT core.get_menu_id('ICP'), 'zh', '成本价格' UNION ALL
SELECT core.get_menu_id('IIM'), 'zh', '库存变动' UNION ALL
SELECT core.get_menu_id('IR'), 'zh', '报告' UNION ALL
SELECT core.get_menu_id('ISM'), 'zh', '安装与维护' UNION ALL
SELECT core.get_menu_id('ISP'), 'zh', '销售价格' UNION ALL
SELECT core.get_menu_id('ITM'), 'zh', '产品与项目' UNION ALL
SELECT core.get_menu_id('JVN'), 'zh', '杂志凭证录入' UNION ALL
SELECT core.get_menu_id('LF'), 'zh', '滞纳金' UNION ALL
SELECT core.get_menu_id('OTS'), 'zh', '一时间设置' UNION ALL
SELECT core.get_menu_id('OTSI'), 'zh', '期初库存' UNION ALL
SELECT core.get_menu_id('PA'), 'zh', '党的账户' UNION ALL
SELECT core.get_menu_id('PAT'), 'zh', '付款条款' UNION ALL
SELECT core.get_menu_id('PLA'), 'zh', '损益表' UNION ALL
SELECT core.get_menu_id('PO'), 'zh', '采购订单' UNION ALL
SELECT core.get_menu_id('PR'), 'zh', '购买返回' UNION ALL
SELECT core.get_menu_id('PRO'), 'zh', '购买重新排序' UNION ALL
SELECT core.get_menu_id('PSA'), 'zh', '送货地址' UNION ALL
SELECT core.get_menu_id('PT'), 'zh', '党的类型' UNION ALL
SELECT core.get_menu_id('PU'), 'zh', '购买' UNION ALL
SELECT core.get_menu_id('PUQ'), 'zh', '购买＆报价' UNION ALL
SELECT core.get_menu_id('PUR'), 'zh', '购买报告' UNION ALL
SELECT core.get_menu_id('PWD'), 'zh', '更改用户密码' UNION ALL
SELECT core.get_menu_id('RFC'), 'zh', '单据' UNION ALL
SELECT core.get_menu_id('RI'), 'zh', '经常性发票' UNION ALL
SELECT core.get_menu_id('RIS'), 'zh', '经常性发票设置' UNION ALL
SELECT core.get_menu_id('SA'), 'zh', '销售' UNION ALL
SELECT core.get_menu_id('SAP'), 'zh', '总帐访问策略' UNION ALL
SELECT core.get_menu_id('SAQ'), 'zh', '销售报价' UNION ALL
SELECT core.get_menu_id('SAR'), 'zh', '销售报告' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'zh', '最畅销的项目' UNION ALL
SELECT core.get_menu_id('SAT'), 'zh', '管理工具' UNION ALL
SELECT core.get_menu_id('SAV'), 'zh', '自动验证策略' UNION ALL
SELECT core.get_menu_id('SCR'), 'zh', '现金库安装' UNION ALL
SELECT core.get_menu_id('SCRS'), 'zh', '国家设置' UNION ALL
SELECT core.get_menu_id('SCS'), 'zh', '计数器设置' UNION ALL
SELECT core.get_menu_id('SCTS'), 'zh', '县设置' UNION ALL
SELECT core.get_menu_id('SD'), 'zh', '销售出库单' UNION ALL
SELECT core.get_menu_id('SDS'), 'zh', '部门设置' UNION ALL
SELECT core.get_menu_id('SEAR'), 'zh', '审计报告' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'zh', '登录查看' UNION ALL
SELECT core.get_menu_id('SES'), 'zh', '实体设置' UNION ALL
SELECT core.get_menu_id('SFR'), 'zh', '频率和会计年度管理' UNION ALL
SELECT core.get_menu_id('SFY'), 'zh', '财年资料' UNION ALL
SELECT core.get_menu_id('SHI'), 'zh', '发货人信息' UNION ALL
SELECT core.get_menu_id('SIG'), 'zh', '项目组' UNION ALL
SELECT core.get_menu_id('SIS'), 'zh', '行业设置' UNION ALL
SELECT core.get_menu_id('SMA'), 'zh', '菜单访问策略' UNION ALL
SELECT core.get_menu_id('SMP'), 'zh', '其他参数' UNION ALL
SELECT core.get_menu_id('SO'), 'zh', '销售订单' UNION ALL
SELECT core.get_menu_id('SOB'), 'zh', '办公室及分公司安装' UNION ALL
SELECT core.get_menu_id('SOS'), 'zh', '办公室 格局' UNION ALL
SELECT core.get_menu_id('SPM'), 'zh', '策略管理' UNION ALL
SELECT core.get_menu_id('SQ'), 'zh', '销售报价' UNION ALL
SELECT core.get_menu_id('SR'), 'zh', '销售退货' UNION ALL
SELECT core.get_menu_id('SRM'), 'zh', '角色管理' UNION ALL
SELECT core.get_menu_id('SSA'), 'zh', '营业员' UNION ALL
SELECT core.get_menu_id('SSB'), 'zh', '品牌' UNION ALL
SELECT core.get_menu_id('SSC'), 'zh', '复合项目' UNION ALL
SELECT core.get_menu_id('SSCD'), 'zh', '复合项目详情' UNION ALL
SELECT core.get_menu_id('SSI'), 'zh', '项目维护' UNION ALL
SELECT core.get_menu_id('SSM'), 'zh', '安装与维护' UNION ALL
SELECT core.get_menu_id('SSP'), 'zh', '存储策略' UNION ALL
SELECT core.get_menu_id('SSS'), 'zh', '国家设置' UNION ALL
SELECT core.get_menu_id('SST'), 'zh', '销售团队' UNION ALL
SELECT core.get_menu_id('STA'), 'zh', '库存调整' UNION ALL
SELECT core.get_menu_id('STJ'), 'zh', '股权转让杂志' UNION ALL
SELECT core.get_menu_id('STO'), 'zh', '店' UNION ALL
SELECT core.get_menu_id('STST'), 'zh', '州销售税' UNION ALL
SELECT core.get_menu_id('STT'), 'zh', '商铺类型' UNION ALL
SELECT core.get_menu_id('STX'), 'zh', '销售税' UNION ALL
SELECT core.get_menu_id('STXD'), 'zh', '销售税细节' UNION ALL
SELECT core.get_menu_id('STXEX'), 'zh', '销售税豁免' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'zh', '销售税豁免详细' UNION ALL
SELECT core.get_menu_id('STXT'), 'zh', '销售税类型' UNION ALL
SELECT core.get_menu_id('SUM'), 'zh', '用户管理' UNION ALL
SELECT core.get_menu_id('SVV'), 'zh', '券验证策略' UNION ALL
SELECT core.get_menu_id('TB'), 'zh', 'Trial Balance' UNION ALL
SELECT core.get_menu_id('TRF'), 'zh', '旗' UNION ALL
SELECT core.get_menu_id('TXA'), 'zh', '税务机关' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'zh', '免税类型' UNION ALL
SELECT core.get_menu_id('TXM'), 'zh', '税务硕士' UNION ALL
SELECT core.get_menu_id('UER'), 'zh', '更新汇率' UNION ALL
SELECT core.get_menu_id('UOM'), 'zh', '计量单位';

--PORTUGUESE

INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'pt', 'Slab Bonus para vendedores' UNION ALL
SELECT core.get_menu_id('AGS'), 'pt', 'Lajes Envelhecimento' UNION ALL
SELECT core.get_menu_id('AS'), 'pt', 'Extrato de Conta' UNION ALL
SELECT core.get_menu_id('BAK'), 'pt', 'backup Database' UNION ALL
SELECT core.get_menu_id('BO'), 'pt', 'Back Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'pt', 'Configuração do Imposto' UNION ALL
SELECT core.get_menu_id('BS'), 'pt', 'Balanço' UNION ALL
SELECT core.get_menu_id('BSA'), 'pt', 'Bonus Slab Assignment' UNION ALL
SELECT core.get_menu_id('BSD'), 'pt', 'Bonus Slab Detalhes' UNION ALL
SELECT core.get_menu_id('CBA'), 'pt', 'Contas Bancárias' UNION ALL
SELECT core.get_menu_id('CC'), 'pt', 'Centros de custo' UNION ALL
SELECT core.get_menu_id('CF'), 'pt', 'Fluxo De Caixa' UNION ALL
SELECT core.get_menu_id('CFH'), 'pt', 'Fluxo de Caixa Headings' UNION ALL
SELECT core.get_menu_id('COA'), 'pt', 'Plano de Contas' UNION ALL
SELECT core.get_menu_id('CTST'), 'pt', 'Impostos Concelhos de vendas' UNION ALL
SELECT core.get_menu_id('CUOM'), 'pt', 'Units compostas de medida' UNION ALL
SELECT core.get_menu_id('CUR'), 'pt', 'Gestão de moeda' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'pt', 'Estatísticas do Banco de Dados' UNION ALL
SELECT core.get_menu_id('DRP'), 'pt', 'Compra Direta' UNION ALL
SELECT core.get_menu_id('DRS'), 'pt', 'Vendas Diretas' UNION ALL
SELECT core.get_menu_id('EOD'), 'pt', 'Fim da Operação Dia' UNION ALL
SELECT core.get_menu_id('FI'), 'pt', 'finanças' UNION ALL
SELECT core.get_menu_id('FIR'), 'pt', 'relatórios' UNION ALL
SELECT core.get_menu_id('FSM'), 'pt', 'Configuração e Manutenção' UNION ALL
SELECT core.get_menu_id('FTT'), 'pt', 'Transactions & Templates' UNION ALL
SELECT core.get_menu_id('FVV'), 'pt', 'Verificação de Vouchers' UNION ALL
SELECT core.get_menu_id('GRN'), 'pt', 'Mercadorias entrada de nota recebida' UNION ALL
SELECT core.get_menu_id('IAS'), 'pt', 'Extrato da conta de estoques' UNION ALL
SELECT core.get_menu_id('ICP'), 'pt', 'preços de custo' UNION ALL
SELECT core.get_menu_id('IIM'), 'pt', 'Movimentos de inventário' UNION ALL
SELECT core.get_menu_id('IR'), 'pt', 'relatórios' UNION ALL
SELECT core.get_menu_id('ISM'), 'pt', 'Configuração e Manutenção' UNION ALL
SELECT core.get_menu_id('ISP'), 'pt', 'Os preços de venda' UNION ALL
SELECT core.get_menu_id('ITM'), 'pt', 'Produtos e Itens' UNION ALL
SELECT core.get_menu_id('JVN'), 'pt', 'Jornal Vale Entry' UNION ALL
SELECT core.get_menu_id('LF'), 'pt', 'taxas atrasadas' UNION ALL
SELECT core.get_menu_id('OTS'), 'pt', 'One Time Setup' UNION ALL
SELECT core.get_menu_id('OTSI'), 'pt', 'Inventário de abertura' UNION ALL
SELECT core.get_menu_id('PA'), 'pt', 'Contas do partido' UNION ALL
SELECT core.get_menu_id('PAT'), 'pt', 'Condições de pagamento' UNION ALL
SELECT core.get_menu_id('PLA'), 'pt', 'Demonstração de Resultados' UNION ALL
SELECT core.get_menu_id('PO'), 'pt', 'Ordem De Compra' UNION ALL
SELECT core.get_menu_id('PR'), 'pt', 'compra Retorno' UNION ALL
SELECT core.get_menu_id('PRO'), 'pt', 'compra Reordenar' UNION ALL
SELECT core.get_menu_id('PSA'), 'pt', 'Endereços para envio' UNION ALL
SELECT core.get_menu_id('PT'), 'pt', 'Tipos partido' UNION ALL
SELECT core.get_menu_id('PU'), 'pt', 'compra' UNION ALL
SELECT core.get_menu_id('PUQ'), 'pt', 'Compra & Cotação' UNION ALL
SELECT core.get_menu_id('PUR'), 'pt', 'Relatórios de compra' UNION ALL
SELECT core.get_menu_id('PWD'), 'pt', 'Alterar senha do usuário' UNION ALL
SELECT core.get_menu_id('RFC'), 'pt', 'Recibo do Cliente' UNION ALL
SELECT core.get_menu_id('RI'), 'pt', 'facturas recorrentes' UNION ALL
SELECT core.get_menu_id('RIS'), 'pt', 'Setup Invoice Recorrente' UNION ALL
SELECT core.get_menu_id('SA'), 'pt', 'de vendas' UNION ALL
SELECT core.get_menu_id('SAP'), 'pt', 'GL Política de Acesso' UNION ALL
SELECT core.get_menu_id('SAQ'), 'pt', 'Vendas e cotação' UNION ALL
SELECT core.get_menu_id('SAR'), 'pt', 'Relatórios de vendas' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'pt', 'Itens mais vendidos' UNION ALL
SELECT core.get_menu_id('SAT'), 'pt', 'Ferramentas de Administração' UNION ALL
SELECT core.get_menu_id('SAV'), 'pt', 'Política de verificação automática' UNION ALL
SELECT core.get_menu_id('SCR'), 'pt', 'Setup Dinheiro Repository' UNION ALL
SELECT core.get_menu_id('SCRS'), 'pt', 'Setup país' UNION ALL
SELECT core.get_menu_id('SCS'), 'pt', 'Setup contador' UNION ALL
SELECT core.get_menu_id('SCTS'), 'pt', 'Setup County' UNION ALL
SELECT core.get_menu_id('SD'), 'pt', 'Entrega de Vendas' UNION ALL
SELECT core.get_menu_id('SDS'), 'pt', 'Setup Departamento' UNION ALL
SELECT core.get_menu_id('SEAR'), 'pt', 'Relatórios de Auditoria' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'pt', 'Entrada Vista' UNION ALL
SELECT core.get_menu_id('SES'), 'pt', 'Setup Entity' UNION ALL
SELECT core.get_menu_id('SFR'), 'pt', 'Gestão de frequência e de Ano Fiscal' UNION ALL
SELECT core.get_menu_id('SFY'), 'pt', 'Fiscal Informações Ano' UNION ALL
SELECT core.get_menu_id('SHI'), 'pt', 'Informações shipper' UNION ALL
SELECT core.get_menu_id('SIG'), 'pt', 'Grupos de itens' UNION ALL
SELECT core.get_menu_id('SIS'), 'pt', 'Setup indústria' UNION ALL
SELECT core.get_menu_id('SMA'), 'pt', 'Política de acesso ao menu' UNION ALL
SELECT core.get_menu_id('SMP'), 'pt', 'Parâmetros Diversos' UNION ALL
SELECT core.get_menu_id('SO'), 'pt', 'pedido de Vendas' UNION ALL
SELECT core.get_menu_id('SOB'), 'pt', 'Escritório & Filial Setup' UNION ALL
SELECT core.get_menu_id('SOS'), 'pt', 'Instalação do Office' UNION ALL
SELECT core.get_menu_id('SPM'), 'pt', 'Gestão de Políticas' UNION ALL
SELECT core.get_menu_id('SQ'), 'pt', 'cotação de vendas' UNION ALL
SELECT core.get_menu_id('SR'), 'pt', 'Retorno de Vendas' UNION ALL
SELECT core.get_menu_id('SRM'), 'pt', 'Gerenciamento de funções' UNION ALL
SELECT core.get_menu_id('SSA'), 'pt', 'vendedores' UNION ALL
SELECT core.get_menu_id('SSB'), 'pt', 'marcas' UNION ALL
SELECT core.get_menu_id('SSC'), 'pt', 'Itens Composto' UNION ALL
SELECT core.get_menu_id('SSCD'), 'pt', 'Detalhes Composto item' UNION ALL
SELECT core.get_menu_id('SSI'), 'pt', 'item de manutenção' UNION ALL
SELECT core.get_menu_id('SSM'), 'pt', 'Configuração e Manutenção' UNION ALL
SELECT core.get_menu_id('SSP'), 'pt', 'Política da loja' UNION ALL
SELECT core.get_menu_id('SSS'), 'pt', 'Setup Estado' UNION ALL
SELECT core.get_menu_id('SST'), 'pt', 'equipes de Vendas' UNION ALL
SELECT core.get_menu_id('STA'), 'pt', 'ajuste de estoques' UNION ALL
SELECT core.get_menu_id('STJ'), 'pt', 'Jornal da Transferência' UNION ALL
SELECT core.get_menu_id('STO'), 'pt', 'Stores' UNION ALL
SELECT core.get_menu_id('STST'), 'pt', 'Impostos estaduais sobre vendas' UNION ALL
SELECT core.get_menu_id('STT'), 'pt', 'tipos de armazenamento' UNION ALL
SELECT core.get_menu_id('STX'), 'pt', 'Impostos sobre Vendas' UNION ALL
SELECT core.get_menu_id('STXD'), 'pt', 'Detalhes de imposto sobre vendas' UNION ALL
SELECT core.get_menu_id('STXEX'), 'pt', 'Isenta de imposto sobre vendas' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'pt', 'Imposto sobre vendas Detalhes Isentos' UNION ALL
SELECT core.get_menu_id('STXT'), 'pt', 'Tipos de imposto sobre vendas' UNION ALL
SELECT core.get_menu_id('SUM'), 'pt', 'Gerenciamento de usuários' UNION ALL
SELECT core.get_menu_id('SVV'), 'pt', 'Comprovante Política de Verificação' UNION ALL
SELECT core.get_menu_id('TB'), 'pt', 'Balancete' UNION ALL
SELECT core.get_menu_id('TRF'), 'pt', 'bandeiras' UNION ALL
SELECT core.get_menu_id('TXA'), 'pt', 'Fisco' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'pt', 'Fiscais Tipos Isentos' UNION ALL
SELECT core.get_menu_id('TXM'), 'pt', 'Mestre Tax' UNION ALL
SELECT core.get_menu_id('UER'), 'pt', 'Atualização de Taxas de Câmbio' UNION ALL
SELECT core.get_menu_id('UOM'), 'pt', 'Unidades de Medida';

--SWEDISH

INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'sv', 'Bonus Slab för Försäljare' UNION ALL
SELECT core.get_menu_id('AGS'), 'sv', 'åldrande Plattor' UNION ALL
SELECT core.get_menu_id('AS'), 'sv', 'Kontoutdrag' UNION ALL
SELECT core.get_menu_id('BAK'), 'sv', 'backup Database' UNION ALL
SELECT core.get_menu_id('BO'), 'sv', 'Tillbaka Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'sv', 'Skatte Konfiguration' UNION ALL
SELECT core.get_menu_id('BS'), 'sv', 'bALANSRÄKNING' UNION ALL
SELECT core.get_menu_id('BSA'), 'sv', 'Bonus Slab Assignment' UNION ALL
SELECT core.get_menu_id('BSD'), 'sv', 'Bonus Slab Detaljer' UNION ALL
SELECT core.get_menu_id('CBA'), 'sv', 'Bankkonton' UNION ALL
SELECT core.get_menu_id('CC'), 'sv', 'Kostnadsställen' UNION ALL
SELECT core.get_menu_id('CF'), 'sv', 'Cash Flow' UNION ALL
SELECT core.get_menu_id('CFH'), 'sv', 'Cash Flow Rubriker' UNION ALL
SELECT core.get_menu_id('COA'), 'sv', 'Kontoplan' UNION ALL
SELECT core.get_menu_id('CTST'), 'sv', 'Län Försäljnings Skatter' UNION ALL
SELECT core.get_menu_id('CUOM'), 'sv', 'Sammansatta måttenheter' UNION ALL
SELECT core.get_menu_id('CUR'), 'sv', 'Valutahantering' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'sv', 'databas Statistik' UNION ALL
SELECT core.get_menu_id('DRP'), 'sv', 'Direkt Inköp' UNION ALL
SELECT core.get_menu_id('DRS'), 'sv', 'direktförsäljning' UNION ALL
SELECT core.get_menu_id('EOD'), 'sv', 'Slut på Dag Operation' UNION ALL
SELECT core.get_menu_id('FI'), 'sv', 'Finans' UNION ALL
SELECT core.get_menu_id('FIR'), 'sv', 'Rapporter' UNION ALL
SELECT core.get_menu_id('FSM'), 'sv', 'Uppställning & Underhåll' UNION ALL
SELECT core.get_menu_id('FTT'), 'sv', 'Transaktioner & Mallar' UNION ALL
SELECT core.get_menu_id('FVV'), 'sv', 'Voucher Verifiering' UNION ALL
SELECT core.get_menu_id('GRN'), 'sv', 'Varor mottagna anteckning' UNION ALL
SELECT core.get_menu_id('IAS'), 'sv', 'Kontoutdrag Inventory' UNION ALL
SELECT core.get_menu_id('ICP'), 'sv', 'Kostnads Priser' UNION ALL
SELECT core.get_menu_id('IIM'), 'sv', 'Inventering Rörelser' UNION ALL
SELECT core.get_menu_id('IR'), 'sv', 'Rapporter' UNION ALL
SELECT core.get_menu_id('ISM'), 'sv', 'Uppställning & Underhåll' UNION ALL
SELECT core.get_menu_id('ISP'), 'sv', 'försäljningspriser' UNION ALL
SELECT core.get_menu_id('ITM'), 'sv', 'Produkter & Artiklar' UNION ALL
SELECT core.get_menu_id('JVN'), 'sv', 'Journal Voucher Entry' UNION ALL
SELECT core.get_menu_id('LF'), 'sv', 'förseningsavgifter' UNION ALL
SELECT core.get_menu_id('OTS'), 'sv', 'One Time Setup' UNION ALL
SELECT core.get_menu_id('OTSI'), 'sv', 'Öppning Inventory' UNION ALL
SELECT core.get_menu_id('PA'), 'sv', 'Party-konton' UNION ALL
SELECT core.get_menu_id('PAT'), 'sv', 'Betalningsvillkor' UNION ALL
SELECT core.get_menu_id('PLA'), 'sv', 'Resultaträkning' UNION ALL
SELECT core.get_menu_id('PO'), 'sv', 'Inköpsorder' UNION ALL
SELECT core.get_menu_id('PR'), 'sv', 'Inköps Return' UNION ALL
SELECT core.get_menu_id('PRO'), 'sv', 'Inköps Omsortera' UNION ALL
SELECT core.get_menu_id('PSA'), 'sv', 'Frakt Adresser' UNION ALL
SELECT core.get_menu_id('PT'), 'sv', 'Parti Typer' UNION ALL
SELECT core.get_menu_id('PU'), 'sv', 'Inköp' UNION ALL
SELECT core.get_menu_id('PUQ'), 'sv', 'Inköp & Offert' UNION ALL
SELECT core.get_menu_id('PUR'), 'sv', 'Inköps Rapporter' UNION ALL
SELECT core.get_menu_id('PWD'), 'sv', 'Ändra användarlösenord' UNION ALL
SELECT core.get_menu_id('RFC'), 'sv', 'Kvitto från kund' UNION ALL
SELECT core.get_menu_id('RI'), 'sv', 'Återkommande fakturor' UNION ALL
SELECT core.get_menu_id('RIS'), 'sv', 'Återkommande Faktura Setup' UNION ALL
SELECT core.get_menu_id('SA'), 'sv', 'Försäljning' UNION ALL
SELECT core.get_menu_id('SAP'), 'sv', 'GL Access Policy' UNION ALL
SELECT core.get_menu_id('SAQ'), 'sv', 'Försäljning & Offert' UNION ALL
SELECT core.get_menu_id('SAR'), 'sv', 'Försäljningsrapporter' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'sv', 'Top köpta' UNION ALL
SELECT core.get_menu_id('SAT'), 'sv', 'admin Tools' UNION ALL
SELECT core.get_menu_id('SAV'), 'sv', 'Automatisk Verifiering Policy' UNION ALL
SELECT core.get_menu_id('SCR'), 'sv', 'Cash Repository Setup' UNION ALL
SELECT core.get_menu_id('SCRS'), 'sv', 'Land Setup' UNION ALL
SELECT core.get_menu_id('SCS'), 'sv', 'Counter Setup' UNION ALL
SELECT core.get_menu_id('SCTS'), 'sv', 'län Setup' UNION ALL
SELECT core.get_menu_id('SD'), 'sv', 'Försäljnings Leverans' UNION ALL
SELECT core.get_menu_id('SDS'), 'sv', 'Department Setup' UNION ALL
SELECT core.get_menu_id('SEAR'), 'sv', 'revisionsrapporter' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'sv', 'Inloggning View' UNION ALL
SELECT core.get_menu_id('SES'), 'sv', 'Entity Setup' UNION ALL
SELECT core.get_menu_id('SFR'), 'sv', 'Frekvens & Räkenskapsårets Hantering' UNION ALL
SELECT core.get_menu_id('SFY'), 'sv', 'Räkenskapsårets Information' UNION ALL
SELECT core.get_menu_id('SHI'), 'sv', 'avsändaren Information' UNION ALL
SELECT core.get_menu_id('SIG'), 'sv', 'artikelgrupper' UNION ALL
SELECT core.get_menu_id('SIS'), 'sv', 'Bransch Setup' UNION ALL
SELECT core.get_menu_id('SMA'), 'sv', 'Meny Access Policy' UNION ALL
SELECT core.get_menu_id('SMP'), 'sv', 'Diverse parametrar' UNION ALL
SELECT core.get_menu_id('SO'), 'sv', 'kundorder' UNION ALL
SELECT core.get_menu_id('SOB'), 'sv', 'Kontor & Branch Setup' UNION ALL
SELECT core.get_menu_id('SOS'), 'sv', 'Office Setup' UNION ALL
SELECT core.get_menu_id('SPM'), 'sv', 'Principhantering' UNION ALL
SELECT core.get_menu_id('SQ'), 'sv', 'Försäljnings Offert' UNION ALL
SELECT core.get_menu_id('SR'), 'sv', 'Sales Return' UNION ALL
SELECT core.get_menu_id('SRM'), 'sv', 'Roll hantering' UNION ALL
SELECT core.get_menu_id('SSA'), 'sv', 'försäljare' UNION ALL
SELECT core.get_menu_id('SSB'), 'sv', 'varumärken' UNION ALL
SELECT core.get_menu_id('SSC'), 'sv', 'Sammansatta artiklar' UNION ALL
SELECT core.get_menu_id('SSCD'), 'sv', 'Förening Objekt Information' UNION ALL
SELECT core.get_menu_id('SSI'), 'sv', 'Punkt Underhåll' UNION ALL
SELECT core.get_menu_id('SSM'), 'sv', 'Uppställning & Underhåll' UNION ALL
SELECT core.get_menu_id('SSP'), 'sv', 'Affär Policy' UNION ALL
SELECT core.get_menu_id('SSS'), 'sv', 'State Setup' UNION ALL
SELECT core.get_menu_id('SST'), 'sv', 'Sälj Teams' UNION ALL
SELECT core.get_menu_id('STA'), 'sv', 'Aktie Justeringar' UNION ALL
SELECT core.get_menu_id('STJ'), 'sv', 'Omlagring Journal' UNION ALL
SELECT core.get_menu_id('STO'), 'sv', 'butiker' UNION ALL
SELECT core.get_menu_id('STST'), 'sv', 'Statliga Försäljnings Skatter' UNION ALL
SELECT core.get_menu_id('STT'), 'sv', 'Förvara Typer' UNION ALL
SELECT core.get_menu_id('STX'), 'sv', 'Försäljnings Skatter' UNION ALL
SELECT core.get_menu_id('STXD'), 'sv', 'Försäljningsskatte Detaljer' UNION ALL
SELECT core.get_menu_id('STXEX'), 'sv', 'Försäljningsskatte undantar' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'sv', 'Försäljnings skattefri Detaljer' UNION ALL
SELECT core.get_menu_id('STXT'), 'sv', 'Försäljningsskattetyper' UNION ALL
SELECT core.get_menu_id('SUM'), 'sv', 'Användarhantering' UNION ALL
SELECT core.get_menu_id('SVV'), 'sv', 'Voucher Verifiering Policy' UNION ALL
SELECT core.get_menu_id('TB'), 'sv', 'Trial Balance' UNION ALL
SELECT core.get_menu_id('TRF'), 'sv', 'Flaggor' UNION ALL
SELECT core.get_menu_id('TXA'), 'sv', 'Skatteverket' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'sv', 'Skatteundantagna Typer' UNION ALL
SELECT core.get_menu_id('TXM'), 'sv', 'Skatte ledar-' UNION ALL
SELECT core.get_menu_id('UER'), 'sv', 'Uppdatera valutakurser' UNION ALL
SELECT core.get_menu_id('UOM'), 'sv', 'Måttenheter';

--MALAYASIAN
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'ms', 'Slab Bonus untuk jurujual' UNION ALL
SELECT core.get_menu_id('AGS'), 'ms', 'papak Penuaan' UNION ALL
SELECT core.get_menu_id('AS'), 'ms', 'Penyata Akaun' UNION ALL
SELECT core.get_menu_id('BAK'), 'ms', 'sandaran Pangkalan Data' UNION ALL
SELECT core.get_menu_id('BO'), 'ms', 'Pejabat Kembali' UNION ALL
SELECT core.get_menu_id('BOTC'), 'ms', 'Konfigurasi cukai' UNION ALL
SELECT core.get_menu_id('BS'), 'ms', 'Kunci Kira-kira' UNION ALL
SELECT core.get_menu_id('BSA'), 'ms', 'Bonus Tugasan Slab' UNION ALL
SELECT core.get_menu_id('BSD'), 'ms', 'Bonus Slab Butiran' UNION ALL
SELECT core.get_menu_id('CBA'), 'ms', 'Akaun Bank' UNION ALL
SELECT core.get_menu_id('CC'), 'ms', 'Pusat kos' UNION ALL
SELECT core.get_menu_id('CF'), 'ms', 'Aliran tunai' UNION ALL
SELECT core.get_menu_id('CFH'), 'ms', 'Aliran Tunai Tajuk' UNION ALL
SELECT core.get_menu_id('COA'), 'ms', 'Carta Akaun' UNION ALL
SELECT core.get_menu_id('CTST'), 'ms', 'Daerah-daerah Jualan Cukai' UNION ALL
SELECT core.get_menu_id('CUOM'), 'ms', 'Unit perkarangan Langkah' UNION ALL
SELECT core.get_menu_id('CUR'), 'ms', 'Pengurusan mata Wang' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'ms', 'Statistik Pangkalan Data' UNION ALL
SELECT core.get_menu_id('DRP'), 'ms', 'Pembelian Terus' UNION ALL
SELECT core.get_menu_id('DRS'), 'ms', 'Jualan Langsung' UNION ALL
SELECT core.get_menu_id('EOD'), 'ms', 'Akhir Operasi Hari' UNION ALL
SELECT core.get_menu_id('FI'), 'ms', 'Kewangan' UNION ALL
SELECT core.get_menu_id('FIR'), 'ms', 'laporan' UNION ALL
SELECT core.get_menu_id('FSM'), 'ms', 'Persediaan & Penyelenggaraan' UNION ALL
SELECT core.get_menu_id('FTT'), 'ms', 'Urusniaga & Templates' UNION ALL
SELECT core.get_menu_id('FVV'), 'ms', 'baucer Pengesahan' UNION ALL
SELECT core.get_menu_id('GRN'), 'ms', 'Barang Diterima Nota Entry' UNION ALL
SELECT core.get_menu_id('IAS'), 'ms', 'Penyata Akaun Inventori' UNION ALL
SELECT core.get_menu_id('ICP'), 'ms', 'Harga kos' UNION ALL
SELECT core.get_menu_id('IIM'), 'ms', 'Pergerakan inventori' UNION ALL
SELECT core.get_menu_id('IR'), 'ms', 'laporan' UNION ALL
SELECT core.get_menu_id('ISM'), 'ms', 'Persediaan & Penyelenggaraan' UNION ALL
SELECT core.get_menu_id('ISP'), 'ms', 'Menjual Harga' UNION ALL
SELECT core.get_menu_id('ITM'), 'ms', 'Produk & Barangan' UNION ALL
SELECT core.get_menu_id('JVN'), 'ms', 'Journal Voucher Entry' UNION ALL
SELECT core.get_menu_id('LF'), 'ms', 'Bayaran Lewat' UNION ALL
SELECT core.get_menu_id('OTS'), 'ms', 'Satu Persediaan Masa' UNION ALL
SELECT core.get_menu_id('OTSI'), 'ms', 'Inventori membuka' UNION ALL
SELECT core.get_menu_id('PA'), 'ms', 'Akaun Pihak' UNION ALL
SELECT core.get_menu_id('PAT'), 'ms', 'Terma pembayaran' UNION ALL
SELECT core.get_menu_id('PLA'), 'ms', 'Untung & Rugi' UNION ALL
SELECT core.get_menu_id('PO'), 'ms', 'Pesanan Pembelian' UNION ALL
SELECT core.get_menu_id('PR'), 'ms', 'pembelian Pulangan' UNION ALL
SELECT core.get_menu_id('PRO'), 'ms', 'pembelian Pesanan Semula' UNION ALL
SELECT core.get_menu_id('PSA'), 'ms', 'Alamat Penghantaran' UNION ALL
SELECT core.get_menu_id('PT'), 'ms', 'Jenis parti' UNION ALL
SELECT core.get_menu_id('PU'), 'ms', 'pembelian' UNION ALL
SELECT core.get_menu_id('PUQ'), 'ms', 'Pembelian & Sebut Harga' UNION ALL
SELECT core.get_menu_id('PUR'), 'ms', 'Laporan pembelian' UNION ALL
SELECT core.get_menu_id('PWD'), 'ms', 'Tukar Pengguna Kata Laluan' UNION ALL
SELECT core.get_menu_id('RFC'), 'ms', 'Penerimaan daripada Pelanggan' UNION ALL
SELECT core.get_menu_id('RI'), 'ms', 'Invois berulang' UNION ALL
SELECT core.get_menu_id('RIS'), 'ms', 'Berulang Persediaan Invois' UNION ALL
SELECT core.get_menu_id('SA'), 'ms', 'jualan' UNION ALL
SELECT core.get_menu_id('SAP'), 'ms', 'Dasar Akses GL' UNION ALL
SELECT core.get_menu_id('SAQ'), 'ms', 'Jualan & Sebut Harga' UNION ALL
SELECT core.get_menu_id('SAR'), 'ms', 'jualan Laporan' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'ms', 'Item Jualan Top' UNION ALL
SELECT core.get_menu_id('SAT'), 'ms', 'Alat admin' UNION ALL
SELECT core.get_menu_id('SAV'), 'ms', 'Dasar Pengesahan automatik' UNION ALL
SELECT core.get_menu_id('SCR'), 'ms', 'Repository Tunai Persediaan' UNION ALL
SELECT core.get_menu_id('SCRS'), 'ms', 'negara Persediaan' UNION ALL
SELECT core.get_menu_id('SCS'), 'ms', 'Persediaan kaunter' UNION ALL
SELECT core.get_menu_id('SCTS'), 'ms', 'County Persediaan' UNION ALL
SELECT core.get_menu_id('SD'), 'ms', 'Penghantaran jualan' UNION ALL
SELECT core.get_menu_id('SDS'), 'ms', 'Jabatan Persediaan' UNION ALL
SELECT core.get_menu_id('SEAR'), 'ms', 'Laporan Audit' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'ms', 'Log masuk View' UNION ALL
SELECT core.get_menu_id('SES'), 'ms', 'entiti Persediaan' UNION ALL
SELECT core.get_menu_id('SFR'), 'ms', 'Pengurusan Frekuensi & Tahun Anggaran' UNION ALL
SELECT core.get_menu_id('SFY'), 'ms', 'Tahun fiskal Maklumat' UNION ALL
SELECT core.get_menu_id('SHI'), 'ms', 'penghantar Maklumat' UNION ALL
SELECT core.get_menu_id('SIG'), 'ms', 'Kumpulan Perkara' UNION ALL
SELECT core.get_menu_id('SIS'), 'ms', 'industri Persediaan' UNION ALL
SELECT core.get_menu_id('SMA'), 'ms', 'Dasar Akses Menu' UNION ALL
SELECT core.get_menu_id('SMP'), 'ms', 'Parameter Pelbagai' UNION ALL
SELECT core.get_menu_id('SO'), 'ms', 'Perintah jualan' UNION ALL
SELECT core.get_menu_id('SOB'), 'ms', 'Pejabat & Cawangan Persediaan' UNION ALL
SELECT core.get_menu_id('SOS'), 'ms', 'Pejabat Persediaan' UNION ALL
SELECT core.get_menu_id('SPM'), 'ms', 'Pengurusan Polisi' UNION ALL
SELECT core.get_menu_id('SQ'), 'ms', 'Sebut Harga jualan' UNION ALL
SELECT core.get_menu_id('SR'), 'ms', 'jualan Pulangan' UNION ALL
SELECT core.get_menu_id('SRM'), 'ms', 'Pengurusan peranan' UNION ALL
SELECT core.get_menu_id('SSA'), 'ms', 'jurujual' UNION ALL
SELECT core.get_menu_id('SSB'), 'ms', 'jenama' UNION ALL
SELECT core.get_menu_id('SSC'), 'ms', 'Item kompaun' UNION ALL
SELECT core.get_menu_id('SSCD'), 'ms', 'Butiran Kompaun Perkara' UNION ALL
SELECT core.get_menu_id('SSI'), 'ms', 'Penyelenggaraan Perkara' UNION ALL
SELECT core.get_menu_id('SSM'), 'ms', 'Persediaan & Penyelenggaraan' UNION ALL
SELECT core.get_menu_id('SSP'), 'ms', 'Dasar Store' UNION ALL
SELECT core.get_menu_id('SSS'), 'ms', 'Persediaan Negeri' UNION ALL
SELECT core.get_menu_id('SST'), 'ms', 'Pasukan jualan' UNION ALL
SELECT core.get_menu_id('STA'), 'ms', 'Pelarasan saham' UNION ALL
SELECT core.get_menu_id('STJ'), 'ms', 'Pemindahan Saham Journal' UNION ALL
SELECT core.get_menu_id('STO'), 'ms', 'kedai' UNION ALL
SELECT core.get_menu_id('STST'), 'ms', 'Negeri Cukai Jualan' UNION ALL
SELECT core.get_menu_id('STT'), 'ms', 'Jenis kedai' UNION ALL
SELECT core.get_menu_id('STX'), 'ms', 'Cukai jualan' UNION ALL
SELECT core.get_menu_id('STXD'), 'ms', 'Butiran Cukai Jualan' UNION ALL
SELECT core.get_menu_id('STXEX'), 'ms', 'Mengecualikan Cukai Jualan' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'ms', 'Cukai Jualan Butiran Dikecualikan' UNION ALL
SELECT core.get_menu_id('STXT'), 'ms', 'Jenis Cukai Jualan' UNION ALL
SELECT core.get_menu_id('SUM'), 'ms', 'Pengurusan Pengguna' UNION ALL
SELECT core.get_menu_id('SVV'), 'ms', 'Dasar Pengesahan baucar' UNION ALL
SELECT core.get_menu_id('TB'), 'ms', 'Imbangan Duga' UNION ALL
SELECT core.get_menu_id('TRF'), 'ms', 'bendera' UNION ALL
SELECT core.get_menu_id('TXA'), 'ms', 'Pihak Berkuasa cukai' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'ms', 'Cukai Jenis Dikecualikan' UNION ALL
SELECT core.get_menu_id('TXM'), 'ms', 'Master cukai' UNION ALL
SELECT core.get_menu_id('UER'), 'ms', 'Kadar Pertukaran Update' UNION ALL
SELECT core.get_menu_id('UOM'), 'ms', 'Unit Tindakan';

--INDONESIAN
INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'id', 'Slab bonus untuk Staf Penjualan' UNION ALL
SELECT core.get_menu_id('AGS'), 'id', 'Lempengan Penuaan' UNION ALL
SELECT core.get_menu_id('AS'), 'id', 'rekening' UNION ALL
SELECT core.get_menu_id('BAK'), 'id', 'backup database' UNION ALL
SELECT core.get_menu_id('BO'), 'id', 'Back Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'id', 'Konfigurasi pajak' UNION ALL
SELECT core.get_menu_id('BS'), 'id', 'neraca Keuangan' UNION ALL
SELECT core.get_menu_id('BSA'), 'id', 'Bonus Slab Tugas' UNION ALL
SELECT core.get_menu_id('BSD'), 'id', 'Bonus Slab Detail' UNION ALL
SELECT core.get_menu_id('CBA'), 'id', 'Rekening Bank' UNION ALL
SELECT core.get_menu_id('CC'), 'id', 'Pusat biaya' UNION ALL
SELECT core.get_menu_id('CF'), 'id', 'Arus Kas' UNION ALL
SELECT core.get_menu_id('CFH'), 'id', 'Arus Kas Pos' UNION ALL
SELECT core.get_menu_id('COA'), 'id', 'Bagan Akun' UNION ALL
SELECT core.get_menu_id('CTST'), 'id', 'Kabupaten Penjualan Pajak' UNION ALL
SELECT core.get_menu_id('CUOM'), 'id', 'Unit senyawa Ukur' UNION ALL
SELECT core.get_menu_id('CUR'), 'id', 'Manajemen Mata Uang' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'id', 'Statistik database' UNION ALL
SELECT core.get_menu_id('DRP'), 'id', 'Pembelian langsung' UNION ALL
SELECT core.get_menu_id('DRS'), 'id', 'Penjualan Langsung' UNION ALL
SELECT core.get_menu_id('EOD'), 'id', 'Akhir Hari Operasi' UNION ALL
SELECT core.get_menu_id('FI'), 'id', 'keuangan' UNION ALL
SELECT core.get_menu_id('FIR'), 'id', 'laporan' UNION ALL
SELECT core.get_menu_id('FSM'), 'id', 'Pengaturan & Maintenance' UNION ALL
SELECT core.get_menu_id('FTT'), 'id', 'Transaksi & Template' UNION ALL
SELECT core.get_menu_id('FVV'), 'id', 'Verifikasi voucher' UNION ALL
SELECT core.get_menu_id('GRN'), 'id', 'GRN masuk' UNION ALL
SELECT core.get_menu_id('IAS'), 'id', 'Rekening persediaan' UNION ALL
SELECT core.get_menu_id('ICP'), 'id', 'Harga biaya' UNION ALL
SELECT core.get_menu_id('IIM'), 'id', 'Mutasi persediaan' UNION ALL
SELECT core.get_menu_id('IR'), 'id', 'laporan' UNION ALL
SELECT core.get_menu_id('ISM'), 'id', 'Pengaturan & Maintenance' UNION ALL
SELECT core.get_menu_id('ISP'), 'id', 'Jual Harga' UNION ALL
SELECT core.get_menu_id('ITM'), 'id', 'Produk & Produk' UNION ALL
SELECT core.get_menu_id('JVN'), 'id', 'Jurnal Voucher Masuk' UNION ALL
SELECT core.get_menu_id('LF'), 'id', 'akhir Biaya' UNION ALL
SELECT core.get_menu_id('OTS'), 'id', 'One Time Pengaturan' UNION ALL
SELECT core.get_menu_id('OTSI'), 'id', 'membuka Persediaan' UNION ALL
SELECT core.get_menu_id('PA'), 'id', 'Akun Partai' UNION ALL
SELECT core.get_menu_id('PAT'), 'id', 'Syarat Pembayaran' UNION ALL
SELECT core.get_menu_id('PLA'), 'id', 'Laba & Rugi' UNION ALL
SELECT core.get_menu_id('PO'), 'id', 'Purchase Order' UNION ALL
SELECT core.get_menu_id('PR'), 'id', 'pembelian Kembali' UNION ALL
SELECT core.get_menu_id('PRO'), 'id', 'pembelian perekam' UNION ALL
SELECT core.get_menu_id('PSA'), 'id', 'Alamat pengiriman' UNION ALL
SELECT core.get_menu_id('PT'), 'id', 'Jenis Partai' UNION ALL
SELECT core.get_menu_id('PU'), 'id', 'pembelian' UNION ALL
SELECT core.get_menu_id('PUQ'), 'id', 'Pembelian & Quotation' UNION ALL
SELECT core.get_menu_id('PUR'), 'id', 'Laporan pembelian' UNION ALL
SELECT core.get_menu_id('PWD'), 'id', 'Ubah Password Pengguna' UNION ALL
SELECT core.get_menu_id('RFC'), 'id', 'Penerimaan dari Pelanggan' UNION ALL
SELECT core.get_menu_id('RI'), 'id', 'Faktur berulang' UNION ALL
SELECT core.get_menu_id('RIS'), 'id', 'Berulang Faktur Pengaturan' UNION ALL
SELECT core.get_menu_id('SA'), 'id', 'penjualan' UNION ALL
SELECT core.get_menu_id('SAP'), 'id', 'GL Kebijakan Access' UNION ALL
SELECT core.get_menu_id('SAQ'), 'id', 'Penjualan & Quotation' UNION ALL
SELECT core.get_menu_id('SAR'), 'id', 'Laporan penjualan' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'id', 'Top Selling Produk' UNION ALL
SELECT core.get_menu_id('SAT'), 'id', 'Alat admin' UNION ALL
SELECT core.get_menu_id('SAV'), 'id', 'Kebijakan Verifikasi Otomatis' UNION ALL
SELECT core.get_menu_id('SCR'), 'id', 'Repository kas Pengaturan' UNION ALL
SELECT core.get_menu_id('SCRS'), 'id', 'negara Pengaturan' UNION ALL
SELECT core.get_menu_id('SCS'), 'id', 'kontra Pengaturan' UNION ALL
SELECT core.get_menu_id('SCTS'), 'id', 'county Pengaturan' UNION ALL
SELECT core.get_menu_id('SD'), 'id', 'penjualan Pengiriman' UNION ALL
SELECT core.get_menu_id('SDS'), 'id', 'Departemen Pengaturan' UNION ALL
SELECT core.get_menu_id('SEAR'), 'id', 'Laporan Audit' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'id', 'Login View' UNION ALL
SELECT core.get_menu_id('SES'), 'id', 'entitas Pengaturan' UNION ALL
SELECT core.get_menu_id('SFR'), 'id', 'Manajemen Frekuensi & Fiskal Tahun' UNION ALL
SELECT core.get_menu_id('SFY'), 'id', 'Fiskal Informasi Tahun' UNION ALL
SELECT core.get_menu_id('SHI'), 'id', 'pengirim Informasi' UNION ALL
SELECT core.get_menu_id('SIG'), 'id', 'Item Grup' UNION ALL
SELECT core.get_menu_id('SIS'), 'id', 'Pengaturan industri' UNION ALL
SELECT core.get_menu_id('SMA'), 'id', 'Menu Akses Kebijakan' UNION ALL
SELECT core.get_menu_id('SMP'), 'id', 'Parameter lain-lain' UNION ALL
SELECT core.get_menu_id('SO'), 'id', 'Pesanan penjualan' UNION ALL
SELECT core.get_menu_id('SOB'), 'id', 'Kantor Cabang & Pengaturan' UNION ALL
SELECT core.get_menu_id('SOS'), 'id', 'kantor Pengaturan' UNION ALL
SELECT core.get_menu_id('SPM'), 'id', 'Kebijakan Manajemen' UNION ALL
SELECT core.get_menu_id('SQ'), 'id', 'sales Quotation' UNION ALL
SELECT core.get_menu_id('SR'), 'id', 'penjualan Kembali' UNION ALL
SELECT core.get_menu_id('SRM'), 'id', 'Manajemen peran' UNION ALL
SELECT core.get_menu_id('SSA'), 'id', 'penjual' UNION ALL
SELECT core.get_menu_id('SSB'), 'id', 'merek' UNION ALL
SELECT core.get_menu_id('SSC'), 'id', 'senyawa Item' UNION ALL
SELECT core.get_menu_id('SSCD'), 'id', 'Senyawa Item detail' UNION ALL
SELECT core.get_menu_id('SSI'), 'id', 'Item Maintenance' UNION ALL
SELECT core.get_menu_id('SSM'), 'id', 'Pengaturan & Maintenance' UNION ALL
SELECT core.get_menu_id('SSP'), 'id', 'Kebijakan toko' UNION ALL
SELECT core.get_menu_id('SSS'), 'id', 'Pengaturan negara' UNION ALL
SELECT core.get_menu_id('SST'), 'id', 'penjualan Tim' UNION ALL
SELECT core.get_menu_id('STA'), 'id', 'Penyesuaian saham' UNION ALL
SELECT core.get_menu_id('STJ'), 'id', 'Jurnal transfer saham' UNION ALL
SELECT core.get_menu_id('STO'), 'id', 'toko' UNION ALL
SELECT core.get_menu_id('STST'), 'id', 'Penjualan negara Pajak' UNION ALL
SELECT core.get_menu_id('STT'), 'id', 'Jenis toko' UNION ALL
SELECT core.get_menu_id('STX'), 'id', 'penjualan Pajak' UNION ALL
SELECT core.get_menu_id('STXD'), 'id', 'Rincian Pajak Penjualan' UNION ALL
SELECT core.get_menu_id('STXEX'), 'id', 'Membebaskan Pajak Penjualan' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'id', 'Pajak Penjualan Detail Bebaskan' UNION ALL
SELECT core.get_menu_id('STXT'), 'id', 'Jenis Pajak Penjualan' UNION ALL
SELECT core.get_menu_id('SUM'), 'id', 'Manajemen pengguna' UNION ALL
SELECT core.get_menu_id('SVV'), 'id', 'Kebijakan Verifikasi Voucher' UNION ALL
SELECT core.get_menu_id('TB'), 'id', 'Neraca Saldo' UNION ALL
SELECT core.get_menu_id('TRF'), 'id', 'Flags' UNION ALL
SELECT core.get_menu_id('TXA'), 'id', 'Kantor Pajak' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'id', 'Jenis Bebaskan Pajak' UNION ALL
SELECT core.get_menu_id('TXM'), 'id', 'Guru pajak' UNION ALL
SELECT core.get_menu_id('UER'), 'id', 'Perbarui Tukar' UNION ALL
SELECT core.get_menu_id('UOM'), 'id', 'Satuan Ukur';

--FILIPINO

INSERT INTO core.menu_locale(menu_id, culture, menu_text)
SELECT core.get_menu_id('ABS'), 'fil', 'Bonus laha para sa Salesperson' UNION ALL
SELECT core.get_menu_id('AGS'), 'fil', 'Pagtanda Slabs' UNION ALL
SELECT core.get_menu_id('AS'), 'fil', 'Statement ng Account' UNION ALL
SELECT core.get_menu_id('BAK'), 'fil', 'backup Database' UNION ALL
SELECT core.get_menu_id('BO'), 'fil', 'Bumalik Office' UNION ALL
SELECT core.get_menu_id('BOTC'), 'fil', 'Configuration ng Buwis' UNION ALL
SELECT core.get_menu_id('BS'), 'fil', 'balanse Sheet' UNION ALL
SELECT core.get_menu_id('BSA'), 'fil', 'Bonus tilad Pagtatalaga' UNION ALL
SELECT core.get_menu_id('BSD'), 'fil', 'Mga Detalye ng Bonus na tilad' UNION ALL
SELECT core.get_menu_id('CBA'), 'fil', 'bank Account' UNION ALL
SELECT core.get_menu_id('CC'), 'fil', 'Sentro ng Gastos' UNION ALL
SELECT core.get_menu_id('CF'), 'fil', 'Daloy ng cash' UNION ALL
SELECT core.get_menu_id('CFH'), 'fil', 'Mga Heading Daloy ng Cash' UNION ALL
SELECT core.get_menu_id('COA'), 'fil', 'Tsart ng Account' UNION ALL
SELECT core.get_menu_id('CTST'), 'fil', 'Mga county Sales Buwis' UNION ALL
SELECT core.get_menu_id('CUOM'), 'fil', 'Compound Unit ng Pagsukat' UNION ALL
SELECT core.get_menu_id('CUR'), 'fil', 'Pamamahala ng Salapi' UNION ALL
SELECT core.get_menu_id('DBSTAT'), 'fil', 'Istatistika ng Database' UNION ALL
SELECT core.get_menu_id('DRP'), 'fil', 'Direktang Pagbili' UNION ALL
SELECT core.get_menu_id('DRS'), 'fil', 'Direktang Benta' UNION ALL
SELECT core.get_menu_id('EOD'), 'fil', 'Katapusan ng Araw ng operasyon' UNION ALL
SELECT core.get_menu_id('FI'), 'fil', 'pananalapi' UNION ALL
SELECT core.get_menu_id('FIR'), 'fil', 'Mga Ulat' UNION ALL
SELECT core.get_menu_id('FSM'), 'fil', 'Pag-setup at Pagpapanatili' UNION ALL
SELECT core.get_menu_id('FTT'), 'fil', 'Mga transaksyon at Template' UNION ALL
SELECT core.get_menu_id('FVV'), 'fil', 'voucher Pag-verify' UNION ALL
SELECT core.get_menu_id('GRN'), 'fil', 'GRN Entry' UNION ALL
SELECT core.get_menu_id('IAS'), 'fil', 'Pahayag Imbentaryo Account' UNION ALL
SELECT core.get_menu_id('ICP'), 'fil', 'Ang mga presyo ng Gastos' UNION ALL
SELECT core.get_menu_id('IIM'), 'fil', 'mga paggalaw ng Imbentaryo' UNION ALL
SELECT core.get_menu_id('IR'), 'fil', 'Mga Ulat' UNION ALL
SELECT core.get_menu_id('ISM'), 'fil', 'Pag-setup at Pagpapanatili' UNION ALL
SELECT core.get_menu_id('ISP'), 'fil', 'Pagbebenta ng Mga Presyo' UNION ALL
SELECT core.get_menu_id('ITM'), 'fil', 'Mga Produkto at Mga Item' UNION ALL
SELECT core.get_menu_id('JVN'), 'fil', 'Journal Entry Voucher' UNION ALL
SELECT core.get_menu_id('LF'), 'fil', 'Mga huling Bayarin' UNION ALL
SELECT core.get_menu_id('OTS'), 'fil', 'Isang Oras sa Pag-setup' UNION ALL
SELECT core.get_menu_id('OTSI'), 'fil', 'Pagbubukas ng Imbentaryo' UNION ALL
SELECT core.get_menu_id('PA'), 'fil', 'Party Account' UNION ALL
SELECT core.get_menu_id('PAT'), 'fil', 'Mga Tuntunin sa Pagbabayad' UNION ALL
SELECT core.get_menu_id('PLA'), 'fil', 'Profit & Pagkawala ng Account' UNION ALL
SELECT core.get_menu_id('PO'), 'fil', 'Purchase Order' UNION ALL
SELECT core.get_menu_id('PR'), 'fil', 'Bumili ng Return' UNION ALL
SELECT core.get_menu_id('PRO'), 'fil', 'Bumili ng Muling mag-order' UNION ALL
SELECT core.get_menu_id('PSA'), 'fil', 'Address ng Pagpapadala' UNION ALL
SELECT core.get_menu_id('PT'), 'fil', 'Mga Uri ng Party' UNION ALL
SELECT core.get_menu_id('PU'), 'fil', 'pagbili' UNION ALL
SELECT core.get_menu_id('PUQ'), 'fil', 'Pagbili at panipi' UNION ALL
SELECT core.get_menu_id('PUR'), 'fil', 'Ulat ng Pagbili' UNION ALL
SELECT core.get_menu_id('PWD'), 'fil', 'Baguhin ang User Password' UNION ALL
SELECT core.get_menu_id('RFC'), 'fil', 'Resibo mula sa Customer' UNION ALL
SELECT core.get_menu_id('RI'), 'fil', 'umuulit na mga Invoice' UNION ALL
SELECT core.get_menu_id('RIS'), 'fil', 'Umuulit na Pag-setup ng Invoice' UNION ALL
SELECT core.get_menu_id('SA'), 'fil', 'Sales' UNION ALL
SELECT core.get_menu_id('SAP'), 'fil', 'GL Patakaran sa Pag-access' UNION ALL
SELECT core.get_menu_id('SAQ'), 'fil', 'Benta at panipi' UNION ALL
SELECT core.get_menu_id('SAR'), 'fil', 'Mga Ulat sa Benta' UNION ALL
SELECT core.get_menu_id('SAR-TSI'), 'fil', 'Pinakamabentang Item' UNION ALL
SELECT core.get_menu_id('SAT'), 'fil', 'Mga Tool ng Admin' UNION ALL
SELECT core.get_menu_id('SAV'), 'fil', 'Patakaran sa Awtomatikong Pag-verify' UNION ALL
SELECT core.get_menu_id('SCR'), 'fil', 'Cash imbakan Setup' UNION ALL
SELECT core.get_menu_id('SCRS'), 'fil', 'Setup bansa' UNION ALL
SELECT core.get_menu_id('SCS'), 'fil', 'counter-setup' UNION ALL
SELECT core.get_menu_id('SCTS'), 'fil', 'Setup ng county' UNION ALL
SELECT core.get_menu_id('SD'), 'fil', 'Paghahatid ng Sales' UNION ALL
SELECT core.get_menu_id('SDS'), 'fil', 'Kagawaran Setup' UNION ALL
SELECT core.get_menu_id('SEAR'), 'fil', 'Ulat ng pag-audit' UNION ALL
SELECT core.get_menu_id('SEAR-LV'), 'fil', 'Tingnan ang Pag-login' UNION ALL
SELECT core.get_menu_id('SES'), 'fil', 'entity Setup' UNION ALL
SELECT core.get_menu_id('SFR'), 'fil', 'Pamamahala Taon Dalas & Pananalapi' UNION ALL
SELECT core.get_menu_id('SFY'), 'fil', 'Tama sa Pananalapi Impormasyon Taon' UNION ALL
SELECT core.get_menu_id('SHI'), 'fil', 'embarkador Impormasyon' UNION ALL
SELECT core.get_menu_id('SIG'), 'fil', 'Mga Pangkat item' UNION ALL
SELECT core.get_menu_id('SIS'), 'fil', 'Setup ng industriya' UNION ALL
SELECT core.get_menu_id('SMA'), 'fil', 'Menu Patakaran sa Pag-access' UNION ALL
SELECT core.get_menu_id('SMP'), 'fil', 'Sari-saring Parameter' UNION ALL
SELECT core.get_menu_id('SO'), 'fil', 'Pagkakasunod-sunod ng Sales' UNION ALL
SELECT core.get_menu_id('SOB'), 'fil', 'Setup ng Opisina at Sangay' UNION ALL
SELECT core.get_menu_id('SOS'), 'fil', 'Setup ng Office' UNION ALL
SELECT core.get_menu_id('SPM'), 'fil', 'Pamamahala ng patakaran' UNION ALL
SELECT core.get_menu_id('SQ'), 'fil', 'Sales panipi' UNION ALL
SELECT core.get_menu_id('SR'), 'fil', 'Sales Return' UNION ALL
SELECT core.get_menu_id('SRM'), 'fil', 'Pamamahala ng Tungkulin' UNION ALL
SELECT core.get_menu_id('SSA'), 'fil', 'Mga Salesperson' UNION ALL
SELECT core.get_menu_id('SSB'), 'fil', 'Mga Tatak' UNION ALL
SELECT core.get_menu_id('SSC'), 'fil', 'Compound Item' UNION ALL
SELECT core.get_menu_id('SSCD'), 'fil', 'Mga Detalye Compound Item' UNION ALL
SELECT core.get_menu_id('SSI'), 'fil', 'Pagpapanatili item' UNION ALL
SELECT core.get_menu_id('SSM'), 'fil', 'Pag-setup at Pagpapanatili' UNION ALL
SELECT core.get_menu_id('SSP'), 'fil', 'Patakaran sa Store' UNION ALL
SELECT core.get_menu_id('SSS'), 'fil', 'Setup ng estado' UNION ALL
SELECT core.get_menu_id('SST'), 'fil', 'Sales Mga Koponan' UNION ALL
SELECT core.get_menu_id('STA'), 'fil', 'stock Adjustments' UNION ALL
SELECT core.get_menu_id('STJ'), 'fil', 'Stock Transfer Journal' UNION ALL
SELECT core.get_menu_id('STO'), 'fil', 'Tindahan' UNION ALL
SELECT core.get_menu_id('STST'), 'fil', 'Benta ng estado ang mga buwis' UNION ALL
SELECT core.get_menu_id('STT'), 'fil', 'Mga Uri ng Store' UNION ALL
SELECT core.get_menu_id('STX'), 'fil', 'Sales Buwis' UNION ALL
SELECT core.get_menu_id('STXD'), 'fil', 'Mga Detalye ng Buwis sa Pagbebenta' UNION ALL
SELECT core.get_menu_id('STXEX'), 'fil', 'Hindi isinasama ang mga Buwis sa Pagbebenta' UNION ALL
SELECT core.get_menu_id('STXEXD'), 'fil', 'Mga Detalye Exempt Buwis sa Pagbebenta' UNION ALL
SELECT core.get_menu_id('STXT'), 'fil', 'Mga Uri ng Buwis sa Pagbebenta' UNION ALL
SELECT core.get_menu_id('SUM'), 'fil', 'Pamamahala ng Gumagamit' UNION ALL
SELECT core.get_menu_id('SVV'), 'fil', 'Patakaran sa Pag-verify ng Voucher' UNION ALL
SELECT core.get_menu_id('TB'), 'fil', 'Pagsubok Balanse' UNION ALL
SELECT core.get_menu_id('TRF'), 'fil', 'Ang Flag' UNION ALL
SELECT core.get_menu_id('TXA'), 'fil', 'Awtoridad ng Buwis' UNION ALL
SELECT core.get_menu_id('TXEXT'), 'fil', 'Tax Exempt Mga Uri' UNION ALL
SELECT core.get_menu_id('TXM'), 'fil', 'Buwis Master' UNION ALL
SELECT core.get_menu_id('UER'), 'fil', 'I-update ang mga rate Exchange' UNION ALL
SELECT core.get_menu_id('UOM'), 'fil', 'Unit ng Pagsukat';


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.disable_editing_sys_type.sql --<--<--
CREATE OR REPLACE FUNCTION core.disable_editing_sys_type()
RETURNS TRIGGER
AS
$$
BEGIN
    IF TG_OP='UPDATE' OR TG_OP='DELETE' THEN
        IF EXISTS
        (
            SELECT *
            FROM core.accounts
            WHERE (sys_type=true)
            AND account_id=OLD.account_id
        ) THEN
            RAISE EXCEPTION 'You are not allowed to change system accounts.'
            USING ERRCODE='P8990';
        END IF;
    END IF;
    
    IF TG_OP='INSERT' THEN
        IF (NEW.sys_type=true) THEN
            RAISE EXCEPTION 'You are not allowed to add system accounts.'
            USING ERRCODE='P8991';
        END IF;
    END IF;

    IF TG_OP='DELETE' THEN
        RETURN OLD;
    END IF;

    RETURN NEW; 
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.items_unit_check_trigger.sql --<--<--
DROP FUNCTION IF EXISTS core.items_unit_check_trigger() CASCADE;

CREATE FUNCTION core.items_unit_check_trigger()
RETURNS TRIGGER
AS
$$        
BEGIN
        IF(core.get_root_unit_id(NEW.unit_id) != core.get_root_unit_id(NEW.reorder_unit_id)) THEN
            RAISE EXCEPTION 'The reorder unit is incompatible with the base unit.'
            USING ERRCODE='P3054';
        END IF;
        RETURN NEW;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER items_unit_check_trigger
AFTER INSERT OR UPDATE
ON core.items
FOR EACH ROW EXECUTE PROCEDURE core.items_unit_check_trigger();

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.party_after_insert_trigger.sql --<--<--
CREATE FUNCTION core.party_after_insert_trigger()
RETURNS TRIGGER
AS
$$
    DECLARE _parent_account_id bigint;
    DECLARE _party_code text;
    DECLARE _account_id bigint;
BEGIN
    _party_code             := core.get_party_code(NEW.first_name, NEW.middle_name, NEW.last_name);
    _parent_account_id      := core.get_account_id_by_party_type_id(NEW.party_type_id);

    IF(COALESCE(NEW.party_name, '') = '') THEN
        NEW.party_name := REPLACE(TRIM(COALESCE(NEW.last_name, '') || ', ' || NEW.first_name || ' ' || COALESCE(NEW.middle_name, '')), ' ', '');
    END IF;

    --Create a new account
    IF(NEW.account_id IS NULL) THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name, parent_account_id)
        SELECT core.get_account_master_id_by_account_id(_parent_account_id), _party_code, NEW.currency_code, _party_code || ' (' || NEW.party_name || ')', _parent_account_id
        RETURNING account_id INTO _account_id;
    
        UPDATE core.parties
        SET 
            account_id=_account_id, 
            party_code=_party_code
        WHERE core.parties.party_id=NEW.party_id;

        RETURN NEW;
    END IF;

    UPDATE core.parties
    SET 
        party_code=_party_code
    WHERE core.parties.party_id=NEW.party_id;

    RETURN NEW;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER party_after_insert_trigger
AFTER INSERT
ON core.parties
FOR EACH ROW EXECUTE PROCEDURE core.party_after_insert_trigger();

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.party_before_update_trigger.sql --<--<--
CREATE FUNCTION core.party_before_update_trigger()
RETURNS TRIGGER
AS
$$
    DECLARE _parent_currency_code text;
BEGIN
    
    --Get currency code of associated GL head.
    _parent_currency_code := core.get_currency_code_by_party_id(NEW.party_id);


    IF(NEW.currency_code != _parent_currency_code) THEN
        RAISE EXCEPTION 'You cannot have a different currency on the mapped GL account.'
        USING ERRCODE='P8003';
    END IF;

    IF(NEW.account_id IS NULL) THEN
        RAISE EXCEPTION 'The column account_id cannot be null.'
        USING ERRCODE='P3501';
    END IF;
    
    RETURN NEW;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER party_before_update_trigger
BEFORE UPDATE
ON core.parties
FOR EACH ROW EXECUTE PROCEDURE core.party_before_update_trigger();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.shippers_after_insert_trigger.sql --<--<--
CREATE FUNCTION core.shippers_after_insert_trigger()
RETURNS trigger
AS
$$
BEGIN
    UPDATE core.shippers
    SET 
        shipper_code=core.get_shipper_code(NEW.company_name)
    WHERE core.shippers.shipper_id=NEW.shipper_id;
    
    RETURN NEW;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER shippers_after_insert_trigger
AFTER INSERT
ON core.shippers
FOR EACH ROW EXECUTE PROCEDURE core.shippers_after_insert_trigger();


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/core/core.update_shipping_address_code_trigger.sql --<--<--
CREATE FUNCTION core.update_shipping_address_code_trigger()
RETURNS TRIGGER
AS
$$
DECLARE _counter integer;
BEGIN
    IF TG_OP='INSERT' THEN

        SELECT COALESCE(MAX(shipping_address_code::integer), 0) + 1
        INTO _counter
        FROM core.shipping_addresses
        WHERE party_id=NEW.party_id;

        NEW.shipping_address_code := trim(to_char(_counter, '000'));
        
        RETURN NEW;
    END IF;
END
$$
LANGUAGE plpgsql;


CREATE TRIGGER update_shipping_address_code_trigger
BEFORE INSERT
ON core.shipping_addresses
FOR EACH ROW EXECUTE PROCEDURE core.update_shipping_address_code_trigger();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/office/office.hash_password.sql --<--<--
DROP FUNCTION IF EXISTS office.hash_password() CASCADE;

CREATE FUNCTION office.hash_password()
RETURNS trigger
AS
$$
    DECLARE _password   text;
    DECLARE _is_sys     boolean;
BEGIN
    _is_sys     := office.is_sys_user(NEW.user_id);
    _password   := encode(digest(NEW.user_name || NEW.password, 'sha512'), 'hex');

    IF(NOT _is_sys) THEN
        UPDATE office.users
        SET password = _password
        WHERE office.users.user_name=NEW.user_name;
    END IF;
    
    RETURN new;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER hash_password
AFTER INSERT ON office.users
FOR EACH ROW
EXECUTE PROCEDURE office.hash_password();

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/office/office.user_trigger.sql --<--<--
DROP FUNCTION IF EXISTS office.user_trigger() CASCADE;

CREATE FUNCTION office.user_trigger()
RETURNS trigger
AS
$$
BEGIN
    IF(office.is_sys(NEW.user_id) AND NEW.password != '') THEN
        RAISE EXCEPTION 'A sys user cannot have a password.'
        USING ERRCODE='P8992';
    END IF; 

    RETURN new;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER user_trigger
AFTER INSERT OR UPDATE ON office.users
FOR EACH ROW
EXECUTE PROCEDURE office.user_trigger();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/policy/policy.perform_lock_out.sql --<--<--
--TODO: Create a lockout policy.
CREATE FUNCTION policy.perform_lock_out()
RETURNS TRIGGER
AS
$$
BEGIN
    IF(
        SELECT COUNT(*) FROM audit.failed_logins
        WHERE audit.failed_logins.user_id=NEW.user_id
        AND audit.failed_logins.failed_date_time 
        BETWEEN NOW()-'5minutes'::interval 
        AND NOW()
    )::integer>5 THEN

    INSERT INTO policy.lock_outs(user_id)SELECT NEW.user_id;
END IF;
RETURN NEW;
END
$$
LANGUAGE plpgsql;

CREATE TRIGGER lockout_user
AFTER INSERT
ON audit.failed_logins
FOR EACH ROW EXECUTE PROCEDURE policy.perform_lock_out();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/transactions/transactions.restrict_delete_trigger.sql --<--<--
DROP FUNCTION IF EXISTS transactions.restrict_delete_trigger() CASCADE;
CREATE FUNCTION transactions.restrict_delete_trigger()
RETURNS TRIGGER
AS
$$
BEGIN
    IF TG_OP='DELETE' THEN
        RAISE EXCEPTION 'Deleting a transaction is not allowed. Mark the transaction as rejected instead.'
        USING ERRCODE='P5800';
    END IF;
END
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER restrict_delete_trigger
BEFORE DELETE
ON transactions.transaction_details
FOR EACH ROW 
EXECUTE PROCEDURE transactions.restrict_delete_trigger();


CREATE TRIGGER restrict_delete_trigger
BEFORE DELETE
ON transactions.stock_master
FOR EACH ROW 
EXECUTE PROCEDURE transactions.restrict_delete_trigger();


CREATE TRIGGER restrict_delete_trigger
BEFORE DELETE
ON transactions.stock_details
FOR EACH ROW 
EXECUTE PROCEDURE transactions.restrict_delete_trigger();



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/10.triggers/transactions/transactions.verify_stock_master_integrity_trigger.sql --<--<--
DROP FUNCTION IF EXISTS transactions.verify_stock_master_integrity_trigger() CASCADE;

CREATE FUNCTION transactions.verify_stock_master_integrity_trigger()
RETURNS TRIGGER
AS
$$
        DECLARE _office_id integer=0;
BEGIN
        SELECT office_id INTO _office_id
        FROM transactions.transaction_master
        WHERE transactions.transaction_master.transaction_master_id = NEW.transaction_master_id;
        
        IF(office.get_office_id_by_store_id(NEW.store_id) != _office_id) THEN
                RAISE EXCEPTION 'Invalid store.'
                USING ERRCODE='P3012';
        END IF;

        IF(office.get_office_id_by_cash_repository_id(NEW.cash_repository_id)  != _office_id) THEN
                RAISE EXCEPTION 'Invalid cash repository.'
                USING ERRCODE='P3013';
        END IF;
                
        RETURN NEW;
END
$$
LANGUAGE plpgsql;


CREATE TRIGGER verify_stock_master_integrity_trigger_after_insert
AFTER INSERT
ON transactions.stock_master
FOR EACH ROW 
EXECUTE PROCEDURE transactions.verify_stock_master_integrity_trigger();


CREATE TRIGGER verify_stock_master_integrity_trigger_after_update
AFTER UPDATE
ON transactions.stock_master
FOR EACH ROW 
EXECUTE PROCEDURE transactions.verify_stock_master_integrity_trigger();






-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/core/parties/unit_tests.check_party_currency_code_mismatch.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.check_party_currency_code_mismatch();

CREATE FUNCTION unit_tests.check_party_currency_code_mismatch()
RETURNS public.test_result
AS
$$
    DECLARE message test_result;
BEGIN
    IF EXISTS
    (
        SELECT party_code FROM core.parties
        INNER JOIN core.accounts
        ON core.parties.account_id = core.accounts.account_id
        WHERE core.parties.currency_code != core.accounts.currency_code
        LIMIT 1
    ) THEN
        SELECT assert.fail('Some party accounts have different currency setup on their mapped GL heads.') INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/core/parties/unit_tests.check_party_null_account_id.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.check_party_null_account_id();

CREATE FUNCTION unit_tests.check_party_null_account_id()
RETURNS public.test_result
AS
$$
    DECLARE message test_result;
BEGIN
    IF EXISTS
    (
        SELECT party_code FROM core.parties
        WHERE core.parties.account_id IS NULL
        LIMIT 1
    ) THEN
        SELECT assert.fail('Some party accounts don''t have mapped GL heads.') INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/core/parties/unit_tests.test_transactions_post_receipt_function.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.test_transactions_post_receipt_function();

CREATE FUNCTION unit_tests.test_transactions_post_receipt_function()
RETURNS public.test_result
AS
$$
    DECLARE message                 test_result;
    DECLARE _user_id                integer;
    DECLARE _office_id              integer; 
    DECLARE _login_id               bigint;
    DECLARE _party_code             national character varying(12); 
    DECLARE _currency_code          national character varying(12); 
    DECLARE _amount                 money_strict; 
    DECLARE _exchange_rate_debit    decimal_strict; 
    DECLARE _exchange_rate_credit   decimal_strict;
    DECLARE _reference_number       national character varying(24); 
    DECLARE _statement_reference    national character varying(128); 
    DECLARE _cost_center_id         integer;
    DECLARE _cash_repository_id     integer;
    DECLARE _posted_date            date;
    DECLARE _bank_account_id        integer;
    DECLARE _bank_instrument_code   national character varying(128);
    DECLARE _bank_tran_code         national character varying(128);
    DECLARE _result                 bigint;
BEGIN
    PERFORM unit_tests.create_mock();
    PERFORM unit_tests.sign_in_test();

    _office_id                      := office.get_office_id_by_office_code('dummy-off01');
    _user_id                        := office.get_user_id_by_user_name('plpgunit-test-user-000001');
    _login_id                       := office.get_login_id(_user_id);
    _party_code                     := 'dummy-pr01';
    _currency_code                  := 'USD';
    _amount                         := 1000.00;
    _exchange_rate_debit            := 100.00;
    _exchange_rate_credit           := 100.00;
    _reference_number               := 'PL-PG-UNIT-TEST';
    _statement_reference            := 'This transaction should have been rollbacked already.';
    _cost_center_id                 := office.get_cost_center_id_by_cost_center_code('dummy-cs01');
    _cash_repository_id             := office.get_cash_repository_id_by_cash_repository_code('dummy-cr01');
    _posted_date                    := NULL;
    _bank_account_id                := NULL;
    _bank_instrument_code           := NULL;
    _bank_tran_code                 := NULL;
                                                        
    _result                         := transactions.post_receipt_function
                                    (
                                        _user_id, 
                                        _office_id, 
                                        _login_id,
                                        _party_code, 
                                        _currency_code, 
                                        _amount, 
                                        _exchange_rate_debit, 
                                        _exchange_rate_credit,
                                        _reference_number, 
                                        _statement_reference, 
                                        _cost_center_id,
                                        _cash_repository_id,
                                        _posted_date,
                                        _bank_account_id,
                                        _bank_instrument_code,
                                        _bank_tran_code 
                                    );

    IF(_result <= 0) THEN
        SELECT assert.fail('Cannot compile transactions.post_receipt_function.') INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/office/unit_tests.sign_in_test.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.sign_in_test();

CREATE FUNCTION unit_tests.sign_in_test()
RETURNS public.test_result
AS
$$
    DECLARE _office_id          integer;
    DECLARE _user_name          text='plpgunit-test-user-000001';
    DECLARE _password           text = encode(digest(encode(digest('plpgunit-test-user-000001thoushaltnotlogin', 'sha512'), 'hex') || 'common', 'sha512'), 'hex');
    DECLARE _culture            text='en-US';
    DECLARE _login_id           bigint;
    DECLARE _sing_in_message    text;
    DECLARE message             test_result;
BEGIN
    PERFORM unit_tests.create_dummy_offices();
    PERFORM unit_tests.create_dummy_users();

    _office_id := office.get_office_id_by_office_code('dummy-off01');
    
    SELECT * FROM office.sign_in(_office_id, _user_name, _password, 'Plpgunit', '127.0.0.1', 'Plpgunit/plpgunit-test-user-000001', _culture, 'common')    
    INTO _login_id, _sing_in_message;
    
    IF(COALESCE(_login_id, 0) = 0) THEN
        SELECT assert.fail(_sing_in_message) INTO message;
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/others/unit_tests.if_functions_compile.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.if_functions_compile();

CREATE FUNCTION unit_tests.if_functions_compile()
RETURNS test_result
AS
$$
    DECLARE schemas text[];
    DECLARE message test_result;
    DECLARE result  boolean;
BEGIN

    schemas := ARRAY(
                SELECT nspname::text
                FROM pg_namespace
                WHERE nspname NOT LIKE 'pg%'
                AND nspname NOT IN('assert', 'unit_tests', 'information_schema')
                ORDER BY nspname
                );


    SELECT * FROM assert.if_functions_compile(VARIADIC schemas) INTO message, result;
    
    IF(result=false) THEN
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message; 
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/others/unit_tests.if_views_compile.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.if_views_compile();

CREATE FUNCTION unit_tests.if_views_compile()
RETURNS test_result
AS
$$
    DECLARE schemas text[];
    DECLARE message test_result;
    DECLARE result  boolean;
BEGIN

    schemas := ARRAY(
                SELECT nspname::text
                FROM pg_namespace
                WHERE nspname NOT LIKE 'pg%'
                AND nspname NOT IN('assert', 'unit_tests', 'information_schema')
                ORDER BY nspname
                );


    SELECT * FROM assert.if_views_compile(VARIADIC schemas) INTO message, result;
    
    IF(result=false) THEN
        RETURN message;
    END IF;

    SELECT assert.ok('End of test.') INTO message;  
    RETURN message; 
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests/unit_tests.create_mock.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_mock();

CREATE FUNCTION unit_tests.create_mock()
RETURNS void
AS
$$
BEGIN
    PERFORM unit_tests.create_dummy_offices();
    PERFORM unit_tests.create_dummy_users();
    PERFORM unit_tests.create_dummy_accounts();
    PERFORM unit_tests.create_dummy_sales_taxes();
    PERFORM unit_tests.create_dummy_countries();
    PERFORM unit_tests.create_dummy_states();
    PERFORM unit_tests.create_dummy_party_types();
    PERFORM unit_tests.create_dummy_item_groups();
    PERFORM unit_tests.create_dummy_item_types();
    PERFORM unit_tests.create_dummy_units();
    PERFORM unit_tests.create_dummy_brands();
    PERFORM unit_tests.create_dummy_parties();
    PERFORM unit_tests.create_dummy_items();
    PERFORM unit_tests.create_dummy_cost_centers();
    PERFORM unit_tests.create_dummy_late_fees();
    PERFORM unit_tests.create_dummy_sales_teams();
    PERFORM unit_tests.create_dummy_salespersons();
    PERFORM unit_tests.create_dummy_shippers();
    PERFORM unit_tests.create_dummy_cash_repositories();
    PERFORM unit_tests.create_dummy_store_types();
    PERFORM unit_tests.create_dummy_stores();
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_accounts.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_accounts();

CREATE FUNCTION unit_tests.create_dummy_accounts()
RETURNS void 
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc01') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('BSA'), 'dummy-acc01', 'NPR', 'Test Mock Account 1';
    END IF;

    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc02') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('BSA'), 'dummy-acc02', 'NPR', 'Test Mock Account 2';
    END IF;

    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc03') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('BSA'), 'dummy-acc03', 'NPR', 'Test Mock Account 3';
    END IF;

    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc04') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('BSA'), 'dummy-acc04', 'NPR', 'Test Mock Account 4';
    END IF;

    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc05') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('BSA'), 'dummy-acc05', 'NPR', 'Test Mock Account 5';
    END IF;

    IF NOT EXISTS(SELECT 1 FROM core.accounts WHERE account_number = 'dummy-acc06') THEN
        INSERT INTO core.accounts(account_master_id, account_number, currency_code, account_name)
        SELECT core.get_account_master_id_by_account_master_code('CAS'), 'dummy-acc06', 'NPR', 'Test Mock Account 6';
    END IF;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_auto_verification_policy.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_auto_verification_policy
(
        _user_id integer, 
        _verify_sales_transactions boolean, 
        _sales_verification_limit money_strict2, 
        _verify_purchase_transactions boolean, 
        _purchase_verification_limit money_strict2, 
        _verify_gl_transactions boolean,
        _gl_verification_limit money_strict2,
        _effective_from date,
        _ends_on date,
        _is_active boolean
);

CREATE FUNCTION unit_tests.create_dummy_auto_verification_policy
(
        _user_id integer, 
        _verify_sales_transactions boolean, 
        _sales_verification_limit money_strict2, 
        _verify_purchase_transactions boolean, 
        _purchase_verification_limit money_strict2, 
        _verify_gl_transactions boolean,
        _gl_verification_limit money_strict2,
        _effective_from date,
        _ends_on date,
        _is_active boolean
)
RETURNS void 
AS
$$
BEGIN
        IF NOT EXISTS(SELECT 1 FROM policy.auto_verification_policy WHERE user_id=_user_id) THEN
                INSERT INTO policy.auto_verification_policy(user_id, verify_sales_transactions, sales_verification_limit, verify_purchase_transactions, purchase_verification_limit, verify_gl_transactions, gl_verification_limit, effective_from, ends_on, is_active)
                SELECT _user_id, _verify_sales_transactions, _sales_verification_limit, _verify_purchase_transactions, _purchase_verification_limit, _verify_gl_transactions, _gl_verification_limit, _effective_from, _ends_on, _is_active;
                RETURN;
        END IF;

        UPDATE policy.auto_verification_policy
        SET 
                verify_sales_transactions = _verify_sales_transactions,
                sales_verification_limit = _sales_verification_limit,
                verify_purchase_transactions = _verify_purchase_transactions,
                purchase_verification_limit = _purchase_verification_limit,
                verify_gl_transactions = _verify_gl_transactions, 
                gl_verification_limit = _gl_verification_limit, 
                effective_from = _effective_from, 
                ends_on = _ends_on, 
                is_active = _is_active                
        WHERE user_id=_user_id;
        
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_brands.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_brands();

CREATE FUNCTION unit_tests.create_dummy_brands()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.brands WHERE brand_code='dummy-br01') THEN        
        INSERT INTO core.brands(brand_code, brand_name)
        SELECT 'dummy-br01', 'Test Mock Brand';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_cash_repositories.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_cash_repositories();

CREATE FUNCTION unit_tests.create_dummy_cash_repositories()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.cash_repositories WHERE cash_repository_code='dummy-cr01') THEN        
        INSERT INTO office.cash_repositories(cash_repository_code, cash_repository_name, office_id)
        SELECT 'dummy-cr01', 'Test Mock Cash Repository', office.get_office_id_by_office_code('dummy-off01');
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_cost_centers.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_cost_centers();

CREATE FUNCTION unit_tests.create_dummy_cost_centers()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.cost_centers WHERE cost_center_code='dummy-cs01') THEN        
        INSERT INTO office.cost_centers(cost_center_code, cost_center_name)
        SELECT 'dummy-cs01', 'Test Mock Cost Center';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_countries.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_countries();

CREATE FUNCTION unit_tests.create_dummy_countries()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.countries WHERE country_code='dummy-co01') THEN        
        INSERT INTO core.countries(country_code, country_name)
        SELECT 'dummy-co01', 'Test Mock Country';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_item_groups.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_item_groups();

CREATE FUNCTION unit_tests.create_dummy_item_groups()
RETURNS void
AS
$$
    DECLARE _dummy_account_id bigint;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.item_groups WHERE item_group_code='dummy-ig01') THEN

        _dummy_account_id := core.get_account_id_by_account_number('dummy-acc01');
        
        INSERT INTO core.item_groups(item_group_code, item_group_name, sales_tax_id, sales_account_id, sales_discount_account_id, sales_return_account_id, purchase_account_id, purchase_discount_account_id, inventory_account_id, cost_of_goods_sold_account_id)
        SELECT 'dummy-ig01', 'Test Mock Item Group', core.get_sales_tax_id_by_sales_tax_code('dummy-stx01'), _dummy_account_id, _dummy_account_id, _dummy_account_id, _dummy_account_id, _dummy_account_id, _dummy_account_id, _dummy_account_id;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_item_types.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_item_types();

CREATE FUNCTION unit_tests.create_dummy_item_types()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.item_types WHERE item_type_code='dummy-it01') THEN
        INSERT INTO core.item_types(item_type_code, item_type_name)
        SELECT 'dummy-it01', 'Test Mock Item Type';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_items.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_items();

CREATE FUNCTION unit_tests.create_dummy_items()
RETURNS void
AS
$$
    DECLARE _dummy_unit_id integer;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.items WHERE item_code='dummy-it01') THEN

        _dummy_unit_id := core.get_unit_id_by_unit_code('dummy-uni01');
    
        INSERT INTO core.items
        (
            item_code, 
            item_name, 
            item_group_id,
            item_type_id,
            brand_id,
            preferred_supplier_id,
            lead_time_in_days,
            unit_id,
            hot_item,
            cost_price,
            selling_price,
            sales_tax_id,
            reorder_unit_id,
            reorder_level,
            reorder_quantity,
            maintain_stock
        )
        SELECT 
            'dummy-it01'                                            AS item_code, 
            'Test Mock Item'                                        AS item_name,
            core.get_item_group_id_by_item_group_code('dummy-ig01') AS item_group_id,
            core.get_item_type_id_by_item_type_code('dummy-it01')   AS item_type_id,
            core.get_brand_id_by_brand_code('dummy-br01')           AS brand_id, 
            core.get_party_id_by_party_code('dummy-pr01')           AS preferred_supplier_id,
            10                                                      AS lead_time,
            _dummy_unit_id                                          AS unit_id,
            false                                                   AS hot_item,
            3000                                                    AS cost_price,
            4000                                                    AS selling_price,
            core.get_sales_tax_id_by_sales_tax_code('dummy-stx01')  AS sales_tax_id,
            _dummy_unit_id                                          AS reorder_unit_id,
            10                                                      AS reorder_level,
            100                                                     AS reorder_quantity,
            false                                                   AS maintain_stock
        UNION ALL
        SELECT 
            'dummy-it02'                                            AS item_code, 
            'Test Mock Item2'                                       AS item_name,
            core.get_item_group_id_by_item_group_code('dummy-ig01') AS item_group_id,
            core.get_item_type_id_by_item_type_code('dummy-it01')   AS item_type_id,
            core.get_brand_id_by_brand_code('dummy-br01')           AS brand_id, 
            core.get_party_id_by_party_code('dummy-pr01')           AS preferred_supplier_id,
            17                                                      AS lead_time,
            _dummy_unit_id                                          AS unit_id,
            false                                                   AS hot_item,
            1400                                                    AS cost_price,
            1800                                                    AS selling_price,
            core.get_sales_tax_id_by_sales_tax_code('dummy-stx01')  AS sales_tax_id,
            _dummy_unit_id                                          AS reorder_unit_id,
            10                                                      AS reorder_level,
            50                                                      AS reorder_quantity,
            false                                                   AS maintain_stock;        
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_late_fees.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_late_fees();

CREATE FUNCTION unit_tests.create_dummy_late_fees()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.late_fee WHERE late_fee_code='dummy-lf01') THEN        
        INSERT INTO core.late_fee(late_fee_code, late_fee_name, is_flat_amount, rate)
        SELECT 'dummy-lf01', 'Test Mock Late Fee', false, 22;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_offices.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_offices();

CREATE FUNCTION unit_tests.create_dummy_offices()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.offices WHERE office_code='dummy-off01') THEN
        INSERT INTO office.offices(office_code, office_name, nick_name, registration_date, currency_code, allow_transaction_posting)
        SELECT 'dummy-off01', 'PLPGUnit Test Office', 'PTO-DUMMY-0001', NOW()::date, 'NPR', true;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_parties.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_parties();

CREATE FUNCTION unit_tests.create_dummy_parties()
RETURNS void
AS
$$
    DECLARE _dummy_account_id   bigint;
    DECLARE _party_id           bigint;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.parties WHERE party_code='dummy-pr01') THEN        
        _dummy_account_id := core.get_account_id_by_account_number('dummy-acc01');

        INSERT INTO core.parties(party_type_id, first_name, last_name, country_id, state_id, currency_code, account_id)
        SELECT            
            core.get_party_type_id_by_party_type_code('dummy-pt01'), 
            'Test Mock party', 
            'Test', 
            core.get_country_id_by_country_code('dummy-co01'),
            core.get_state_id_by_state_code('dummy-st01'),
            'NPR',
            _dummy_account_id
       RETURNING party_id INTO _party_id;

    UPDATE core.parties
    SET party_code = 'dummy-pr01'
    WHERE party_id = _party_id;
       
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_party_types.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_party_types();

CREATE FUNCTION unit_tests.create_dummy_party_types()
RETURNS void
AS
$$
    DECLARE _dummy_account_id bigint;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.party_types WHERE party_type_code='dummy-pt01') THEN        
        _dummy_account_id := core.get_account_id_by_account_number('dummy-acc01');

        INSERT INTO core.party_types(party_type_code, party_type_name, is_supplier, account_id)
        SELECT 'dummy-pt01', 'Test Mock Party Type', false, _dummy_account_id;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_payment_terms.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_payment_terms();

CREATE FUNCTION unit_tests.create_dummy_payment_terms()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.payment_terms WHERE payment_term_code='dummy-pt01') THEN        
        INSERT INTO core.payment_terms(payment_term_code, payment_term_name, due_on_date, due_days, grace_peiod, late_fee_id, late_fee_posting_frequency_id)
        SELECT 'dummy-pt01', 'Test Mock Payment Term', false, 10, 5, core.get_late_fee_id_by_late_fee_code('dummy-lf01'), core.get_frequency_id_by_frequency_code('EOM');
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_sales_taxes.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_sales_taxes();

CREATE FUNCTION unit_tests.create_dummy_sales_taxes()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.tax_master WHERE tax_master_code='dummy-tm01') THEN
        INSERT INTO core.tax_master(tax_master_code, tax_master_name)
        SELECT 'dummy-tm01', 'Dummy Tax Master';
    END IF;
    
    IF NOT EXISTS(SELECT 1 FROM core.sales_taxes WHERE sales_tax_code='dummy-stx01') THEN
        INSERT INTO core.sales_taxes(tax_master_id, office_id, sales_tax_code, sales_tax_name, is_exemption, tax_base_amount_type_code, rate)
        SELECT 
            core.get_tax_master_id_by_tax_master_code('dummy-tm01'), 
            office.get_office_id_by_office_code('dummy-off01'),
            'dummy-stx01',
            'Dummy Sales Tax',
            false,
            'P',
            12.4;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;

--SELECT * FROM unit_tests.create_dummy_sales_tax()

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_sales_teams.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_sales_teams();

CREATE FUNCTION unit_tests.create_dummy_sales_teams()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.sales_teams WHERE sales_team_code='dummy-st01') THEN        
        INSERT INTO core.sales_teams(sales_team_code, sales_team_name)
        SELECT 'dummy-st01', 'Test Mock Sales Team';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_salespersons.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_salespersons();

CREATE FUNCTION unit_tests.create_dummy_salespersons()
RETURNS void
AS
$$
    DECLARE _dummy_account_id bigint;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.salespersons WHERE salesperson_code='dummy-sp01') THEN        
        _dummy_account_id := core.get_account_id_by_account_number('dummy-acc01');

        INSERT INTO core.salespersons(salesperson_code, salesperson_name, sales_team_id, address, contact_number, account_id)
        SELECT 'dummy-sp01', 'Test Mock Salesperson', core.get_sales_team_id_by_sales_team_code('dummy-st01'), '', '', _dummy_account_id;
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_shippers.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_shippers();

CREATE FUNCTION unit_tests.create_dummy_shippers()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.shippers WHERE shipper_code='dummy-sh01') THEN        
        INSERT INTO core.shippers(shipper_code, shipper_name, company_name, account_id)
        SELECT 'dummy-sh01', 'Test Mock Shipper', 'Test Mock Shipper', core.get_account_id_by_account_number('dummy-acc01');
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_states.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_states();

CREATE FUNCTION unit_tests.create_dummy_states()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.states WHERE state_code='dummy-st01') THEN        
        INSERT INTO core.states(state_code, state_name, country_id)
        SELECT 'dummy-st01', 'Test Mock State', core.get_country_id_by_country_code('dummy-co01');
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_store_types.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_store_types();

CREATE FUNCTION unit_tests.create_dummy_store_types()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.store_types WHERE store_type_code='dummy-st01') THEN
        INSERT INTO office.store_types(store_type_code, store_type_name)
        SELECT 'dummy-st01', 'Test Mock Store Type';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_stores.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_stores();

CREATE FUNCTION unit_tests.create_dummy_stores()
RETURNS void
AS
$$
    DECLARE _cash_account_id bigint;
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.stores WHERE store_code='dummy-st01') THEN
        INSERT INTO office.stores(store_code, store_name, office_id, store_type_id, allow_sales, sales_tax_id, default_cash_account_id, default_cash_repository_id)
        SELECT 
            'dummy-st01', 
            'Test Mock Store',
            office.get_office_id_by_office_code('dummy-off01'),
            office.get_store_type_id_by_store_type_code('dummy-st01'),
            true,
            core.get_sales_tax_id_by_sales_tax_code('dummy-stx01'),
            core.get_account_id_by_account_number('dummy-acc06'),
            office.get_cash_repository_id_by_cash_repository_code('dummy-cr01');
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_units.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_units();

CREATE FUNCTION unit_tests.create_dummy_units()
RETURNS void
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM core.units WHERE unit_code='dummy-uni01') THEN        
        INSERT INTO core.units(unit_code, unit_name)
        SELECT 'dummy-uni01', 'Test Mock Unit';
    END IF;

    RETURN;
END
$$
LANGUAGE plpgsql;



-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/12.plpgunit-tests-mock/unit_tests.create_dummy_users.sql --<--<--
DROP FUNCTION IF EXISTS unit_tests.create_dummy_users();

CREATE FUNCTION unit_tests.create_dummy_users()
RETURNS void 
AS
$$
BEGIN
    IF NOT EXISTS(SELECT 1 FROM office.users WHERE user_name='plpgunit-test-user-000001') THEN
        INSERT INTO office.users(role_id, user_name, full_name, password, office_id)
        SELECT office.get_role_id_by_role_code('USER'), 'plpgunit-test-user-000001', 'PLPGUnit Test User', 'thoushaltnotlogin', office.get_office_id_by_office_code('dummy-off01');
    END IF;
END
$$
LANGUAGE plpgsql;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/13.triggers/transactions/transactions.check_cash_balance_trigger.sql --<--<--
DROP FUNCTION IF EXISTS transactions.check_cash_balance_trigger() CASCADE;
CREATE FUNCTION transactions.check_cash_balance_trigger()
RETURNS TRIGGER
AS
$$
    DECLARE cash_balance DECIMAL(24, 4);
BEGIN
    IF(NEW.cash_repository_id IS NOT NULL) THEN
        IF(TG_OP='UPDATE') THEN
            IF (OLD.amount_in_currency != NEW.amount_in_currency) OR (OLD.amount_in_local_currency != NEW.amount_in_local_currency) THEN
                RAISE EXCEPTION 'Acess is denied. You cannot update the "transaction_details" table.'
                USING ERRCODE='P9201';
            END IF;
        END IF;

        IF(TG_OP='INSERT') THEN
            IF(NEW.tran_type = 'Cr' AND NEW.cash_repository_id IS NOT NULL) THEN
                cash_balance := transactions.get_cash_repository_balance(NEW.cash_repository_id, NEW.currency_code);

                IF(cash_balance < NEW.amount_in_currency) THEN
                    RAISE EXCEPTION 'Posting this transaction would produce a negative cash balance.'
                    USING ERRCODE='P5002';
                END IF;
            END IF;
        END IF;
    END IF;

    RETURN NEW;
END
$$
LANGUAGE 'plpgsql';


CREATE TRIGGER check_cash_balance_trigger
BEFORE INSERT OR UPDATE
ON transactions.transaction_details
FOR EACH ROW 
EXECUTE PROCEDURE transactions.check_cash_balance_trigger();




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/14.constraints/core.sql --<--<--
ALTER TABLE core.compound_item_details
DROP CONSTRAINT IF EXISTS compound_item_details_unit_chk;

ALTER TABLE core.compound_item_details
ADD CONSTRAINT compound_item_details_unit_chk
CHECK(core.is_valid_unit(item_id, unit_id));

ALTER TABLE core.item_cost_prices
DROP CONSTRAINT IF EXISTS item_cost_prices_unit_chk;

ALTER TABLE core.item_cost_prices
ADD CONSTRAINT item_cost_prices_unit_chk
CHECK(core.is_valid_unit(item_id, unit_id));


ALTER TABLE core.item_selling_prices
DROP CONSTRAINT IF EXISTS item_selling_prices_unit_chk;

ALTER TABLE core.item_selling_prices
ADD CONSTRAINT item_selling_prices_unit_chk
CHECK(core.is_valid_unit(item_id, unit_id));

ALTER TABLE core.items
DROP CONSTRAINT IF EXISTS items_reorder_quantity_chk;

ALTER TABLE core.items
ADD CONSTRAINT items_reorder_quantity_chk
CHECK
(
core.convert_unit(reorder_unit_id, unit_id) * reorder_quantity >= reorder_level
);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/14.constraints/transactions.sql --<--<--

ALTER TABLE transactions.stock_details
DROP CONSTRAINT IF EXISTS stock_details_unit_chk;

ALTER TABLE transactions.stock_details
ADD CONSTRAINT stock_details_unit_chk
CHECK(core.is_valid_unit(item_id, unit_id));


ALTER TABLE transactions.non_gl_stock_details
DROP CONSTRAINT IF EXISTS non_gl_stock_details_unit_chk;

ALTER TABLE transactions.non_gl_stock_details
ADD CONSTRAINT non_gl_stock_details_unit_chk
CHECK(core.is_valid_unit(item_id, unit_id));

ALTER TABLE transactions.transaction_master
DROP CONSTRAINT IF EXISTS transaction_master_sys_user_id_chk ;

ALTER TABLE transactions.transaction_master
ADD CONSTRAINT transaction_master_sys_user_id_chk 
CHECK(sys_user_id IS NULL OR office.is_sys_user(sys_user_id)=true);


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/80.2nd-quadrant-audit-trigger.sql --<--<--
-- An audit history is important on most tables. Provide an audit trigger that logs to
-- a dedicated audit table for the major relations.
--
-- This file should be generic and not depend on application roles or structures,
-- as it's being listed here:
--
--    https://wiki.postgresql.org/wiki/Audit_trigger_91plus    
--
-- This trigger was originally based on
--   http://wiki.postgresql.org/wiki/Audit_trigger
-- but has been completely rewritten.
--
-- Should really be converted into a relocatable EXTENSION, with control and upgrade files.

CREATE EXTENSION IF NOT EXISTS hstore;

-- CREATE SCHEMA audit; --Removed
-- REVOKE ALL ON SCHEMA audit FROM public; --Removed

COMMENT ON SCHEMA audit IS 'Out-of-table audit/history logging tables and trigger functions';

--
-- Audited data. Lots of information is available, it's just a matter of how much
-- you really want to record. See:
--
--   http://www.postgresql.org/docs/9.1/static/functions-info.html
--
-- Remember, every column you add takes up more audit table space and slows audit
-- inserts.
--
-- Every index you add has a big impact too, so avoid adding indexes to the
-- audit table unless you REALLY need them. The hstore GIST indexes are
-- particularly expensive.
--
-- It is sometimes worth copying the audit table, or a coarse subset of it that
-- you're interested in, into a temporary table where you CREATE any useful
-- indexes and do your analysis.
--
DROP TABLE IF EXISTS audit.logged_actions; --Added

CREATE TABLE audit.logged_actions (
    event_id bigserial primary key,
    schema_name text not null,
    table_name text not null,
    relid oid not null,
    session_user_name text,
    application_user_name text, --Added
    action_tstamp_tx TIMESTAMP WITH TIME ZONE NOT NULL,
    action_tstamp_stm TIMESTAMP WITH TIME ZONE NOT NULL,
    action_tstamp_clk TIMESTAMP WITH TIME ZONE NOT NULL,
    transaction_id bigint,
    application_name text,
    client_addr inet,
    client_port integer,
    client_query text,
    action TEXT NOT NULL CHECK (action IN ('I','D','U', 'T')),
    row_data hstore,
    changed_fields hstore,
    statement_only boolean not null
);

REVOKE ALL ON audit.logged_actions FROM public;

COMMENT ON TABLE audit.logged_actions IS 'History of auditable actions on audited tables, from audit.if_modified_func()';
COMMENT ON COLUMN audit.logged_actions.event_id IS 'Unique identifier for each auditable event';
COMMENT ON COLUMN audit.logged_actions.schema_name IS 'Database schema audited table for this event is in';
COMMENT ON COLUMN audit.logged_actions.table_name IS 'Non-schema-qualified table name of table event occured in';
COMMENT ON COLUMN audit.logged_actions.relid IS 'Table OID. Changes with drop/create. Get with ''tablename''::regclass';
COMMENT ON COLUMN audit.logged_actions.session_user_name IS 'Login / session user whose statement caused the audited event';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_tx IS 'Transaction start timestamp for tx in which audited event occurred';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_stm IS 'Statement start timestamp for tx in which audited event occurred';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_clk IS 'Wall clock time at which audited event''s trigger call occurred';
COMMENT ON COLUMN audit.logged_actions.transaction_id IS 'Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.';
COMMENT ON COLUMN audit.logged_actions.client_addr IS 'IP address of client that issued query. Null for unix domain socket.';
COMMENT ON COLUMN audit.logged_actions.client_port IS 'Remote peer IP port address of client that issued query. Undefined for unix socket.';
COMMENT ON COLUMN audit.logged_actions.client_query IS 'Top-level query that caused this auditable event. May be more than one statement.';
COMMENT ON COLUMN audit.logged_actions.application_name IS 'Application name set when this audit event occurred. Can be changed in-session by client.';
COMMENT ON COLUMN audit.logged_actions.action IS 'Action type; I = insert, D = delete, U = update, T = truncate';
COMMENT ON COLUMN audit.logged_actions.row_data IS 'Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.';
COMMENT ON COLUMN audit.logged_actions.changed_fields IS 'New values of fields changed by UPDATE. Null except for row-level UPDATE events.';
COMMENT ON COLUMN audit.logged_actions.statement_only IS '''t'' if audit event is from an FOR EACH STATEMENT trigger, ''f'' for FOR EACH ROW';

CREATE INDEX logged_actions_relid_idx ON audit.logged_actions(relid);
CREATE INDEX logged_actions_action_tstamp_tx_stm_idx ON audit.logged_actions(action_tstamp_stm);
CREATE INDEX logged_actions_action_idx ON audit.logged_actions(action);


CREATE OR REPLACE FUNCTION audit.if_modified_func() RETURNS TRIGGER AS $body$
DECLARE
    application_user_name text = 'N/A'; --Added
    audit_row audit.logged_actions;
    include_values boolean;
    log_diffs boolean;
    h_old hstore;
    h_new hstore;
    excluded_cols text[] = ARRAY[]::text[];
BEGIN
    IF TG_WHEN <> 'AFTER' THEN
        RAISE EXCEPTION 'audit.if_modified_func() may only run as an AFTER trigger';
    END IF;
    

        IF (TG_OP != 'DELETE') THEN --Added
                IF(hstore(NEW) ? 'audit_user_id' = true) THEN --Added
                        application_user_name:= office.get_user_name_by_user_id((hstore(NEW.*) -> 'audit_user_id')::int); --Added
                END IF; --Added
        END IF; --Added

    audit_row = ROW(
        nextval('audit.logged_actions_event_id_seq'), -- event_id
        TG_TABLE_SCHEMA::text,                        -- schema_name
        TG_TABLE_NAME::text,                          -- table_name
        TG_RELID,                                     -- relation OID for much quicker searches
        session_user::text,                           -- session_user_name
        application_user_name::text,                  -- application_user_name  --Added
        current_timestamp,                            -- action_tstamp_tx
        statement_timestamp(),                        -- action_tstamp_stm
        clock_timestamp(),                            -- action_tstamp_clk
        txid_current(),                               -- transaction ID
        current_setting('application_name'),          -- client application
        inet_client_addr(),                           -- client_addr
        inet_client_port(),                           -- client_port
        current_query(),                              -- top-level query or queries (if multistatement) from client
        substring(TG_OP,1,1),                         -- action
        NULL, NULL,                                   -- row_data, changed_fields
        'f'                                           -- statement_only
        );

    IF NOT TG_ARGV[0]::boolean IS DISTINCT FROM 'f'::boolean THEN
        audit_row.client_query = NULL;
    END IF;

    IF TG_ARGV[1] IS NOT NULL THEN
        excluded_cols = TG_ARGV[1]::text[];
    END IF;
    
    IF (TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*);
        audit_row.changed_fields =  (hstore(NEW.*) - audit_row.row_data) - excluded_cols;
        IF audit_row.changed_fields = hstore('') THEN
            -- All changed fields are ignored. Skip this update.
            RETURN NULL;
        END IF;
    ELSIF (TG_OP = 'DELETE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*) - excluded_cols;
    ELSIF (TG_OP = 'INSERT' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(NEW.*) - excluded_cols;
    ELSIF (TG_LEVEL = 'STATEMENT' AND TG_OP IN ('INSERT','UPDATE','DELETE','TRUNCATE')) THEN
        audit_row.statement_only = 't';
    ELSE
        RAISE EXCEPTION '[audit.if_modified_func] - Trigger func added as trigger for unhandled case: %, %',TG_OP, TG_LEVEL;
        RETURN NULL;
    END IF;
    INSERT INTO audit.logged_actions VALUES (audit_row.*);
    RETURN NULL;
END;
$body$
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public;



COMMENT ON FUNCTION audit.if_modified_func() IS $body$
Track changes to a table at the statement and/or row level.

Optional parameters to trigger in CREATE TRIGGER call:

param 0: boolean, whether to log the query text. Default 't'.

param 1: text[], columns to ignore in updates. Default [].

         Updates to ignored cols are omitted from changed_fields.

         Updates with only ignored cols changed are not inserted
         into the audit log.

         Almost all the processing work is still done for updates
         that ignored. If you need to save the load, you need to use
         WHEN clause on the trigger instead.

         No warning or error is issued if ignored_cols contains columns
         that do not exist in the target table. This lets you specify
         a standard set of ignored columns.

There is no parameter to disable logging of values. Add this trigger as
a 'FOR EACH STATEMENT' rather than 'FOR EACH ROW' trigger if you do not
want to log row values.

Note that the user name logged is the login role for the session. The audit trigger
cannot obtain the active role because it is reset by the SECURITY DEFINER invocation
of the audit trigger its self.
$body$;



CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]) RETURNS void AS $body$
DECLARE
  stm_targets text = 'INSERT OR UPDATE OR DELETE OR TRUNCATE';
  _q_txt text;
  _ignored_cols_snip text = '';
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_row ON ' || target_table;
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_stm ON ' || target_table;

    IF audit_rows THEN
        IF array_length(ignored_cols,1) > 0 THEN
            _ignored_cols_snip = ', ' || quote_literal(ignored_cols);
        END IF;
        _q_txt = 'CREATE TRIGGER audit_trigger_row AFTER INSERT OR UPDATE OR DELETE ON ' || 
                 target_table || 
                 ' FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func(' ||
                 quote_literal(audit_query_text) || _ignored_cols_snip || ');';
        RAISE NOTICE '%',_q_txt;
        EXECUTE _q_txt;
        stm_targets = 'TRUNCATE';
    ELSE
    END IF;

    _q_txt = 'CREATE TRIGGER audit_trigger_stm AFTER ' || stm_targets || ' ON ' ||
             target_table ||
             ' FOR EACH STATEMENT EXECUTE PROCEDURE audit.if_modified_func('||
             quote_literal(audit_query_text) || ');';
    RAISE NOTICE '%',_q_txt;
    EXECUTE _q_txt;

END;
$body$
language 'plpgsql';

COMMENT ON FUNCTION audit.audit_table(regclass, boolean, boolean, text[]) IS $body$
Add auditing support to a table.

Arguments:
   target_table:     Table name, schema qualified if not on search_path
   audit_rows:       Record each row change, or only audit at a statement level
   audit_query_text: Record the text of the client query that triggered the audit event?
   ignored_cols:     Columns to exclude from update diffs, ignore updates that change only ignored cols.
$body$;

-- Pg doesn't allow variadic calls with 0 params, so provide a wrapper
CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean) RETURNS void AS $body$
SELECT audit.audit_table($1, $2, $3, ARRAY[]::text[]);
$body$ LANGUAGE SQL;

-- And provide a convenience call wrapper for the simplest case
-- of row-level logging with no excluded cols and query logging enabled.
--
CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass) RETURNS void AS $$
SELECT audit.audit_table($1, BOOLEAN 't', BOOLEAN 't');
$$ LANGUAGE 'sql';

COMMENT ON FUNCTION audit.audit_table(regclass) IS $body$
Add auditing support to the given table. Row-level changes will be logged with full client query text. No cols are ignored.
$body$;


-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/81.audit-all-tables.sql --<--<--
-- DO
-- $$
        -- DECLARE sql text;
-- BEGIN
        -- SELECT array_to_string(
        -- ARRAY(
        -- SELECT 
        -- 'SELECT audit.audit_table(''' || table_schema || '.' || table_name || '''::regclass, true, true, null);'
        -- FROM information_schema.tables
        -- WHERE table_schema NOT IN('pg_catalog', 'information_schema', 'unit_tests')
        -- AND table_name NOT IN('logged_actions')
        -- AND table_type='BASE TABLE'
        -- ORDER BY table_schema), '')
        -- INTO sql;

        -- EXECUTE sql;
        
-- END
-- $$
-- LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/99.sample-data/05.config.sql --<--<--
DO
$$
BEGIN
    IF(core.get_locale() = 'en-US') THEN
        INSERT INTO office.configuration(config_id, office_id, value, configuration_details)
        SELECT 1, office_id, 'Perpetual', ''
        FROM office.offices
        WHERE parent_office_id IS NOT NULL;


        INSERT INTO office.configuration(config_id, office_id, value, configuration_details)
        SELECT 2, office_id, 'LIFO', ''
        FROM office.offices
        WHERE parent_office_id IS NOT NULL;
    END IF;
END
$$
LANGUAGE plpgsql;

-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/db-documentation.sql --<--<--
COMMENT ON TABLE core.account_masters IS 
'This table contains categories in which General Ledger (G.L) Account belongs to & collectively they form the Chart of Accounts.
The category in this table cannot be edited by users. Thus, a user-interface for this table is not available.
This table facilitates creating useful reports such as Profit & Loss A/c. and Balance Sheet.';
COMMENT ON COLUMN core.account_masters.account_master_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.account_masters.account_master_code IS 'The unique alphanumeric code that generally abbreviates the value of account master name.';
COMMENT ON COLUMN core.account_masters.account_master_name IS 'The name of account master, which is also a unique field.';
COMMENT ON COLUMN core.account_masters.parent_account_master_id IS 'The name of account master, which is also a unique field.';
COMMENT ON COLUMN core.account_masters.normally_debit IS 'Select "Yes" if the account has nature of Debit balance or vice-versa.';



COMMENT ON TABLE core.accounts IS 'This table stores information on General Ledger (G.L) Account.';
COMMENT ON COLUMN core.accounts.account_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN core.accounts.account_master_id IS 'The foreign key to table core.account_masters.';
COMMENT ON COLUMN core.accounts.account_number IS 'The unique numeric value assigned to the account name which is similar to account id.';
COMMENT ON COLUMN core.accounts.external_code IS '';
COMMENT ON COLUMN core.accounts.confidential IS 'Limits the access to the particular account among various uesers.';
COMMENT ON COLUMN core.accounts.currency_code IS 'Foreign key to the table core.currencies.';
COMMENT ON COLUMN core.accounts.account_name IS 'The name of account master, which is also a unique field.';
COMMENT ON COLUMN core.accounts.description IS 'Description about the account.';
COMMENT ON COLUMN core.accounts.sys_type IS '';
COMMENT ON COLUMN core.accounts.parent_account_id IS 'Foreign key to the table core.accounts.';
COMMENT ON COLUMN core.accounts.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.accounts.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.ageing_slabs IS '';
COMMENT ON COLUMN core.ageing_slabs.ageing_slab_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.ageing_slabs.ageing_slab_name IS '';
COMMENT ON COLUMN core.ageing_slabs.from_days IS '';
COMMENT ON COLUMN core.ageing_slabs.to_days IS '';


COMMENT ON TABLE core.attachment_lookup IS '';
COMMENT ON COLUMN core.attachment_lookup.attachment_lookup_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.attachment_lookup.book IS '';
COMMENT ON COLUMN core.attachment_lookup.resource IS '';
COMMENT ON COLUMN core.attachment_lookup.resource_key IS '';


COMMENT ON TABLE core.attachments IS '';
COMMENT ON COLUMN core.attachments.attachment_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN core.attachments.user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN core.attachments.resource IS '';
COMMENT ON COLUMN core.attachments.resource_key IS '';
COMMENT ON COLUMN core.attachments.resource_id IS '';
COMMENT ON COLUMN core.attachments.original_file_name IS 'The name given to the attached file, which is also a unique field ';
COMMENT ON COLUMN core.attachments.file_extension IS 'The extension of the attached file.';
COMMENT ON COLUMN core.attachments.file_path IS 'The location of the file.';
COMMENT ON COLUMN core.attachments.comment IS 'Comment on the attachment.';
COMMENT ON COLUMN core.attachments.added_on IS 'Time & date when the attachment was added.';


COMMENT ON TABLE policy.auto_verification_policy IS '';
COMMENT ON COLUMN policy.auto_verification_policy.user_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN policy.auto_verification_policy.verify_sales_transactions IS '';
COMMENT ON COLUMN policy.auto_verification_policy.sales_verification_limit IS '';
COMMENT ON COLUMN policy.auto_verification_policy.verify_purchase_transactions IS '';
COMMENT ON COLUMN policy.auto_verification_policy.purchase_verification_limit IS '';
COMMENT ON COLUMN policy.auto_verification_policy.verify_gl_transactions IS '';
COMMENT ON COLUMN policy.auto_verification_policy.gl_verification_limit IS '';
COMMENT ON COLUMN policy.auto_verification_policy.effective_from IS '';
COMMENT ON COLUMN policy.auto_verification_policy.ends_on IS '';
COMMENT ON COLUMN policy.auto_verification_policy.is_active IS '';
COMMENT ON COLUMN policy.auto_verification_policy.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN policy.auto_verification_policy.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';

 
COMMENT ON TABLE core.bank_accounts IS 'This table stores information on various Bank A/cs and other associated information.';
COMMENT ON COLUMN core.bank_accounts.account_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.bank_accounts.maintained_by_user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN core.bank_accounts.bank_name IS 'The name of the bank.';
COMMENT ON COLUMN core.bank_accounts.bank_branch IS 'The name of the branch.';
COMMENT ON COLUMN core.bank_accounts.bank_contact_number IS 'The contact number of the bank.';
COMMENT ON COLUMN core.bank_accounts.bank_address IS 'The address of the bank.';
COMMENT ON COLUMN core.bank_accounts.bank_account_number IS 'The bank account number.';
COMMENT ON COLUMN core.bank_accounts.bank_account_type IS 'The type of bank account.';
COMMENT ON COLUMN core.bank_accounts.relationship_officer_name IS 'The name of  the relationship officer.';
COMMENT ON COLUMN core.bank_accounts.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.bank_accounts.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.bonus_slab_details IS 'This table stores information on various rate of bonus.';
COMMENT ON COLUMN core.bonus_slab_details.bonus_slab_detail_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.bonus_slab_details.bonus_slab_id IS 'Foreign key to this table.';
COMMENT ON COLUMN core.bonus_slab_details.amount_from IS 'The minimum amount of sales to qualify for the bonus slab.';
COMMENT ON COLUMN core.bonus_slab_details.amount_to IS 'The maximum amount in the bonus slab.';
COMMENT ON COLUMN core.bonus_slab_details.bonus_rate IS 'The rate of bonus assigned to the bonus slab.';
COMMENT ON COLUMN core.bonus_slab_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.bonus_slab_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.bonus_slabs IS 'This table stores information on bonus slabs.';
COMMENT ON COLUMN core.bonus_slabs.bonus_slab_id IS 'The primary key of the table, which is also a serial field';
COMMENT ON COLUMN core.bonus_slabs.bonus_slab_code IS 'Code given to the column.';
COMMENT ON COLUMN core.bonus_slabs.bonus_slab_name IS 'Name of the colum, which is a also unique field.';
COMMENT ON COLUMN core.bonus_slabs.effective_from IS 'The effective date of the bonus slab.';
COMMENT ON COLUMN core.bonus_slabs.ends_on IS 'The ending date of the bonus slab.';
COMMENT ON COLUMN core.bonus_slabs.checking_frequency_id IS 'Time-interval for calculation of bonus';
COMMENT ON COLUMN core.bonus_slabs.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.bonus_slabs.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.brands IS 'This table stores information on various brands the entity is dealing.';
COMMENT ON COLUMN core.brands.brand_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.brands.brand_code IS 'The code of the brand, which is also a unique field.';
COMMENT ON COLUMN core.brands.brand_name IS 'The name of the brand.';
COMMENT ON COLUMN core.brands.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.brands.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.cash_flow_headings IS 'This table stores information on various categories in the Cash Flow Statement.';
COMMENT ON COLUMN core.cash_flow_headings.cash_flow_heading_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.cash_flow_headings.cash_flow_heading_code IS 'The code given to the Cash Flow heading.';
COMMENT ON COLUMN core.cash_flow_headings.cash_flow_heading_name IS 'The name of the Cash Flow heading, which is also a unique field,';
COMMENT ON COLUMN core.cash_flow_headings.cash_flow_heading_type IS 'A single character assigned to Cash Flow heading, which define its type.';


COMMENT ON TABLE office.cash_repositories IS 'This table stores information related to cash repositories.';
COMMENT ON COLUMN office.cash_repositories.cash_repository_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN office.cash_repositories.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN office.cash_repositories.cash_repository_code IS 'The code given to cash repository.';
COMMENT ON COLUMN office.cash_repositories.cash_repository_name IS 'The  name given to cash repository,which is also a unique field.';
COMMENT ON COLUMN office.cash_repositories.parent_cash_repository_id IS 'Foreign key to the table office.cash_repositories.';
COMMENT ON COLUMN office.cash_repositories.description IS 'Description on cash repository.';
COMMENT ON COLUMN office.cash_repositories.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.cash_repositories.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.cashiers IS 'This table stores information related to cashier.';
COMMENT ON COLUMN office.cashiers.cashier_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN office.cashiers.counter_id IS 'Foreign key to the table office.counters.';
COMMENT ON COLUMN office.cashiers.user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN office.cashiers.assigned_by_user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN office.cashiers.transaction_date IS 'The date on which the transaction occured.';
COMMENT ON COLUMN office.cashiers.closed IS '';


COMMENT ON TABLE core.compound_item_details IS 'This table stores information on compound item and combination of items which composites compound item.';
COMMENT ON COLUMN core.compound_item_details.compound_item_detail_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.compound_item_details.compound_item_id IS 'Foreign key to the table core.comound_items';
COMMENT ON COLUMN core.compound_item_details.item_id IS 'Foreign key to the table core.items';
COMMENT ON COLUMN core.compound_item_details.unit_id IS 'Foreign key to the table core.units.';
COMMENT ON COLUMN core.compound_item_details.quantity IS 'The quantity composition of compound items.';
COMMENT ON COLUMN core.compound_item_details.price IS 'The price detail of compound items.';
COMMENT ON COLUMN core.compound_item_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.compound_item_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.compound_items IS 'This table stores information on combination on compund items and other associated information to it.';
COMMENT ON COLUMN core.compound_items.compound_item_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.compound_items.compound_item_code IS 'Code given to the compound item.';
COMMENT ON COLUMN core.compound_items.compound_item_name IS 'The name given to compound item, which is a unique field';
COMMENT ON COLUMN core.compound_items.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.compound_items.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.compound_units IS 'This table stores information on the units, value of the items that forms the compound items.';
COMMENT ON COLUMN core.compound_units.compound_unit_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.compound_units.base_unit_id IS 'Foreign key to the table core.units.';
COMMENT ON COLUMN core.compound_units.value IS '';
COMMENT ON COLUMN core.compound_units.compare_unit_id IS '';
COMMENT ON COLUMN core.compound_units.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.compound_units.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';

/* THIS TABLE*/
COMMENT ON TABLE core.config IS '';
COMMENT ON COLUMN core.config.config_id IS 'The primary key of this table.';
COMMENT ON COLUMN core.config.config_name IS 'The name given to the , which is also a unique field.';


COMMENT ON TABLE office.configuration IS '';
COMMENT ON COLUMN office.configuration.configuration_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.configuration.config_id IS 'Foreign key to the table core.config.';
COMMENT ON COLUMN office.configuration.office_id IS '';
COMMENT ON COLUMN office.configuration.value IS '';
COMMENT ON COLUMN office.configuration.configuration_details IS 'Details on configuration.';
COMMENT ON COLUMN office.configuration.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.configuration.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.cost_centers IS '';
COMMENT ON COLUMN office.cost_centers.cost_center_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.cost_centers.cost_center_code IS '';
COMMENT ON COLUMN office.cost_centers.cost_center_name IS '';
COMMENT ON COLUMN office.cost_centers.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.cost_centers.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.counters IS '';
COMMENT ON COLUMN office.counters.counter_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.counters.store_id IS '';
COMMENT ON COLUMN office.counters.cash_repository_id IS '';
COMMENT ON COLUMN office.counters.counter_code IS '';
COMMENT ON COLUMN office.counters.counter_name IS '';
COMMENT ON COLUMN office.counters.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.counters.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.counties IS 'This table stores information on counties, their code, the state they belong etc.';
COMMENT ON COLUMN core.counties.county_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.counties.county_code IS 'The code given to the county,which is a unique field.';
COMMENT ON COLUMN core.counties.county_name IS 'The name of the county, which is a unique field.';
COMMENT ON COLUMN core.counties.state_id IS 'State code of the county.';
COMMENT ON COLUMN core.counties.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.counties.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.countries IS 'This table stores information on list of countries and their their code.';
COMMENT ON COLUMN core.countries.country_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.countries.country_code IS 'The code of the country.';
COMMENT ON COLUMN core.countries.country_name IS 'The name of the country.';
COMMENT ON COLUMN core.countries.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.countries.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.county_sales_taxes IS 'This table stores information on sales tax of the county.';
COMMENT ON COLUMN core.county_sales_taxes.county_sales_tax_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.county_sales_taxes.county_sales_tax_code IS 'The code given to county sale tax.';
COMMENT ON COLUMN core.county_sales_taxes.county_sales_tax_name IS 'The name given to county sales tax, which is a unique field';
COMMENT ON COLUMN core.county_sales_taxes.county_id IS 'Foreign key to the table core.counties.';
COMMENT ON COLUMN core.county_sales_taxes.entity_id IS 'Foreign key to the table core.entities.';
COMMENT ON COLUMN core.county_sales_taxes.industry_id IS 'Foreign key to the table core.industries.';
COMMENT ON COLUMN core.county_sales_taxes.item_group_id IS 'Foreign key to the table core.item_groups.';
COMMENT ON COLUMN core.county_sales_taxes.rate IS 'Rate of sales tax of the county.';
COMMENT ON COLUMN core.county_sales_taxes.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.county_sales_taxes.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.currencies IS 'This table stores information on currency.';
COMMENT ON COLUMN core.currencies.currency_code IS 'The primary key of this table, code of the currency.';
COMMENT ON COLUMN core.currencies.currency_symbol IS 'Symbol of the currency.';
COMMENT ON COLUMN core.currencies.currency_name IS 'Name of the currency.';
COMMENT ON COLUMN core.currencies.hundredth_name IS 'Name given to hundredth part of the currency.';
COMMENT ON COLUMN core.currencies.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.currencies.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.customer_receipts IS 'This table stores information on receipts from customers.';
COMMENT ON COLUMN transactions.customer_receipts.receipt_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN transactions.customer_receipts.transaction_master_id IS 'Foreign key to the table transactions.transaction_master.';
COMMENT ON COLUMN transactions.customer_receipts.party_id IS 'Foreign key to the table core.parties.';
COMMENT ON COLUMN transactions.customer_receipts.currency_code IS 'Foreign key to the table core.currencies.';
COMMENT ON COLUMN transactions.customer_receipts.amount IS 'Amount received from the customer.';
COMMENT ON COLUMN transactions.customer_receipts.er_debit IS '';
COMMENT ON COLUMN transactions.customer_receipts.er_credit IS '';
COMMENT ON COLUMN transactions.customer_receipts.cash_repository_id IS 'The id of the cash repository used.';
COMMENT ON COLUMN transactions.customer_receipts.posted_date IS 'The date on which the transaction was posted.';
COMMENT ON COLUMN transactions.customer_receipts.bank_account_id IS 'Foreign key to the table core.bank_accounts.';
COMMENT ON COLUMN transactions.customer_receipts.bank_instrument_code IS 'Code of the cheque received.';
COMMENT ON COLUMN transactions.customer_receipts.bank_tran_code IS 'The transaction code while the cheque is received.';


COMMENT ON TABLE transactions.day_operation IS 'This table stores information on the transaction, date & time of its occurance.';
COMMENT ON COLUMN transactions.day_operation.day_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.day_operation.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN transactions.day_operation.value_date IS '';
COMMENT ON COLUMN transactions.day_operation.started_on IS 'Date & Time when the transaction was started.';
COMMENT ON COLUMN transactions.day_operation.started_by IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN transactions.day_operation.completed_on IS 'Date & Time when the tranaction was completed.';
COMMENT ON COLUMN transactions.day_operation.completed_by IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN transactions.day_operation.completed IS 'Select "Yes" if the opration is completed or vice-versa.';


COMMENT ON TABLE transactions.day_operation_routines IS '';
COMMENT ON COLUMN transactions.day_operation_routines.day_operation_routine_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.day_operation_routines.day_id IS 'Foreign key to the transactions_routines.';
COMMENT ON COLUMN transactions.day_operation_routines.routine_id IS '';
COMMENT ON COLUMN transactions.day_operation_routines.started_on IS '';
COMMENT ON COLUMN transactions.day_operation_routines.completed_on IS '';


COMMENT ON TABLE office.departments IS 'This table stores information on lists of deparments and other associated information.';
COMMENT ON COLUMN office.departments.department_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.departments.department_code IS 'Code given to the department, which is a unique field.';
COMMENT ON COLUMN office.departments.department_name IS 'Name given to the department, which is a unique field.';
COMMENT ON COLUMN office.departments.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.departments.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.entities IS 'List of entities.';
COMMENT ON COLUMN core.entities.entity_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.entities.entity_name IS 'The name of the type of entity, which is a unique field.';
COMMENT ON COLUMN core.entities.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.entities.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.exchange_rate_details IS 'Details on exchange rate.';
COMMENT ON COLUMN core.exchange_rate_details.exchange_rate_detail_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN core.exchange_rate_details.exchange_rate_id IS 'Foreign key to the table core.exchange_rates.';
COMMENT ON COLUMN core.exchange_rate_details.local_currency_code IS 'Foreign key to the table core.currencies';
COMMENT ON COLUMN core.exchange_rate_details.foreign_currency_code IS 'Foreign key to the table core.currencies';/* there is no cloumn foreign currency code in core.currencies */
COMMENT ON COLUMN core.exchange_rate_details.unit IS '';
COMMENT ON COLUMN core.exchange_rate_details.exchange_rate IS '';


COMMENT ON TABLE core.exchange_rates IS 'Update exchange rates.';
COMMENT ON COLUMN core.exchange_rates.exchange_rate_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.exchange_rates.updated_on IS 'Date & time of the last update of exchange rate.';
COMMENT ON COLUMN core.exchange_rates.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN core.exchange_rates.status IS '';


COMMENT ON TABLE audit.failed_logins IS '';
COMMENT ON COLUMN audit.failed_logins.failed_login_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN audit.failed_logins.user_id IS '';
COMMENT ON COLUMN audit.failed_logins.user_name IS '';
COMMENT ON COLUMN audit.failed_logins.office_id IS '';
COMMENT ON COLUMN audit.failed_logins.browser IS '';
COMMENT ON COLUMN audit.failed_logins.ip_address IS '';
COMMENT ON COLUMN audit.failed_logins.failed_date_time IS '';
COMMENT ON COLUMN audit.failed_logins.remote_user IS '';
COMMENT ON COLUMN audit.failed_logins.details IS '';


COMMENT ON TABLE core.fiscal_year IS 'Information on fiscal year.';
COMMENT ON COLUMN core.fiscal_year.fiscal_year_code IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.fiscal_year.fiscal_year_name IS 'Current fiscal year, which is a unique field.';
COMMENT ON COLUMN core.fiscal_year.starts_from IS 'The date fiscal year begins.';
COMMENT ON COLUMN core.fiscal_year.ends_on IS 'The date fiscal year ends.';
COMMENT ON COLUMN core.fiscal_year.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.fiscal_year.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.flag_types IS 'Mark rows of a table with difernt color, so that viewing is easier.';
COMMENT ON COLUMN core.flag_types.flag_type_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.flag_types.flag_type_name IS 'Name of the flag.';
COMMENT ON COLUMN core.flag_types.background_color IS 'Back-ground color of the flagged transaction.';
COMMENT ON COLUMN core.flag_types.foreground_color IS 'The foreground color of the flagged transaction.';
COMMENT ON COLUMN core.flag_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.flag_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.flags IS 'Flags are used by users to mark transactions. The flags created by a user is not visible to others.';
COMMENT ON COLUMN core.flags.flag_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.flags.user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN core.flags.flag_type_id IS 'Foreign key to the table core.flag_types.';
COMMENT ON COLUMN core.flags.resource IS '';
COMMENT ON COLUMN core.flags.resource_key IS '';
COMMENT ON COLUMN core.flags.resource_id IS '';
COMMENT ON COLUMN core.flags.flagged_on IS '';


COMMENT ON TABLE core.frequencies IS 'Interval of time for posting a transaction.';
COMMENT ON COLUMN core.frequencies.frequency_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.frequencies.frequency_code IS 'The code given to the interval of time.';
COMMENT ON COLUMN core.frequencies.frequency_name IS 'The name given to the interval of time, which is unique field.';


COMMENT ON TABLE core.frequency_setups IS 'Setup time interval of posting a transaction automatically.';
COMMENT ON COLUMN core.frequency_setups.frequency_setup_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.frequency_setups.fiscal_year_code IS 'Foreign key to the table core.fiscal_year.';
COMMENT ON COLUMN core.frequency_setups.frequency_setup_code IS ''; /*Does the time interval has to be only 1 month.*/
COMMENT ON COLUMN core.frequency_setups.value_date IS '';
COMMENT ON COLUMN core.frequency_setups.frequency_id IS 'Foreign key to the table core.frequencies.';
COMMENT ON COLUMN core.frequency_setups.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.frequency_setups.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.income_tax_setup IS 'Tax setup.';
COMMENT ON COLUMN core.income_tax_setup.income_tax_setup_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.income_tax_setup.office_id IS '';
COMMENT ON COLUMN core.income_tax_setup.effective_from IS 'The effective date of the tax rate.';
COMMENT ON COLUMN core.income_tax_setup.tax_rate IS 'The tax rate applicable.';
COMMENT ON COLUMN core.income_tax_setup.tax_authority_id IS '';
COMMENT ON COLUMN core.income_tax_setup.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.income_tax_setup.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.industries IS 'Details on industry the firm belongs.';
COMMENT ON COLUMN core.industries.industry_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.industries.industry_name IS 'The name of the industry, which is a unique field.';
COMMENT ON COLUMN core.industries.parent_industry_id IS '';
COMMENT ON COLUMN core.industries.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.industries.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.item_cost_prices IS 'This table stores information on cost price of a item and other associated informations.';
COMMENT ON COLUMN core.item_cost_prices.item_cost_price_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN core.item_cost_prices.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.item_cost_prices.entry_ts IS '';
COMMENT ON COLUMN core.item_cost_prices.unit_id IS 'Foreign key to the table core.units.';
COMMENT ON COLUMN core.item_cost_prices.party_id IS 'Foreign key to the table core.parties';
COMMENT ON COLUMN core.item_cost_prices.lead_time_in_days IS 'Time taken by the good to arrive in stock after it is ordered.';
COMMENT ON COLUMN core.item_cost_prices.includes_tax IS 'Tick if tax is to be included on the price of the item.';
COMMENT ON COLUMN core.item_cost_prices.price IS 'Cost price of the item.';
COMMENT ON COLUMN core.item_cost_prices.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.item_cost_prices.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.item_groups IS '';
COMMENT ON COLUMN core.item_groups.item_group_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.item_groups.item_group_code IS '';
COMMENT ON COLUMN core.item_groups.item_group_name IS '';
COMMENT ON COLUMN core.item_groups.exclude_from_purchase IS '';
COMMENT ON COLUMN core.item_groups.exclude_from_sales IS '';
COMMENT ON COLUMN core.item_groups.sales_tax_id IS '';
COMMENT ON COLUMN core.item_groups.sales_account_id IS '';
COMMENT ON COLUMN core.item_groups.sales_discount_account_id IS '';
COMMENT ON COLUMN core.item_groups.sales_return_account_id IS '';
COMMENT ON COLUMN core.item_groups.purchase_account_id IS '';
COMMENT ON COLUMN core.item_groups.purchase_discount_account_id IS '';
COMMENT ON COLUMN core.item_groups.inventory_account_id IS '';
COMMENT ON COLUMN core.item_groups.cost_of_goods_sold_account_id IS '';
COMMENT ON COLUMN core.item_groups.parent_item_group_id IS '';
COMMENT ON COLUMN core.item_groups.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.item_groups.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.item_selling_prices IS 'This table stores information on selling price of an item and other information.
 PLEASE NOTE :

    THESE ARE THE MOST EFFECTIVE STOCK ITEM PRICES.
    THE PRICE IN THIS CATALOG IS ACTUALLY PICKED UP AT THE TIME OF PURCHASE AND SALES.

    A STOCK ITEM PRICE MAY BE DIFFERENT FOR DIFFERENT UNITS.
    FURTHER, A STOCK ITEM WOULD BE SOLD AT A HIGHER PRICE WHEN SOLD LOOSE THAN WHAT IT WOULD ACTUALLY COST IN A
    COMPOUND UNIT.

    EXAMPLE, ONE CARTOON (20 BOTTLES) OF BEER BOUGHT AS A UNIT
    WOULD COST 25% LESS FROM THE SAME STORE.';
COMMENT ON COLUMN core.item_selling_prices.item_selling_price_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.item_selling_prices.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.item_selling_prices.unit_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.item_selling_prices.party_type_id IS '';
COMMENT ON COLUMN core.item_selling_prices.price_type_id IS '';
COMMENT ON COLUMN core.item_selling_prices.includes_tax IS '';
COMMENT ON COLUMN core.item_selling_prices.price IS '';
COMMENT ON COLUMN core.item_selling_prices.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.item_selling_prices.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.item_types IS '';
COMMENT ON COLUMN core.item_types.item_type_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.item_types.item_type_code IS '';
COMMENT ON COLUMN core.item_types.item_type_name IS '';
COMMENT ON COLUMN core.item_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.item_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.items IS 'This table stores information on items and other associated information.';
COMMENT ON COLUMN core.items.item_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.items.item_code IS 'Code given to the item.';
COMMENT ON COLUMN core.items.item_name IS 'Name given to the item.';
COMMENT ON COLUMN core.items.item_group_id IS '';
COMMENT ON COLUMN core.items.item_type_id IS 'Foreign key to the table core.item_groups.';
COMMENT ON COLUMN core.items.brand_id IS 'Foreign key to the table core.brands.';
COMMENT ON COLUMN core.items.preferred_supplier_id IS 'Foreign key to the table core.parties.';
COMMENT ON COLUMN core.items.lead_time_in_days IS 'Days taken for the shipment of the ordered goods.';
COMMENT ON COLUMN core.items.weight_in_grams IS 'Weight of an individual item in the unit of measure gram.';
COMMENT ON COLUMN core.items.width_in_centimeters IS 'Width of an individual item in centimeter.';
COMMENT ON COLUMN core.items.height_in_centimeters IS 'Height of an individual item in centimeter.';
COMMENT ON COLUMN core.items.length_in_centimeters IS 'Length of an individual item in centimeter.';
COMMENT ON COLUMN core.items.machinable IS 'Select "Yes" if the particular item can be handled by machine while shipping.';
COMMENT ON COLUMN core.items.preferred_shipping_mail_type_id IS 'Foreign key to the table core.shipping_mail_types.';
COMMENT ON COLUMN core.items.shipping_package_shape_id IS 'Foreign key to the table core.shipping_package_shapes.';
COMMENT ON COLUMN core.items.unit_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.items.hot_item IS 'Hot item will be featured on e-commerce website. Select "Yes" if the item is hot item or vice-versa.';
COMMENT ON COLUMN core.items.cost_price IS 'Cost price of the item.';
COMMENT ON COLUMN core.items.cost_price_includes_tax IS 'Select "Yes" if the cost price includes tax or vice-versa.';
COMMENT ON COLUMN core.items.selling_price IS 'Selling price of the item.';
COMMENT ON COLUMN core.items.selling_price_includes_tax IS 'Select "Yes" if the selling price includes tax or vice-versa.';
COMMENT ON COLUMN core.items.sales_tax_id IS 'Foreign key to the table core.sales_taxes.';
COMMENT ON COLUMN core.items.reorder_unit_id IS 'Foreign key to the table core.units.';
COMMENT ON COLUMN core.items.reorder_level IS 'The level of stock on which re-order needs to be placed.';
COMMENT ON COLUMN core.items.reorder_quantity IS 'The quantity of good that needs to be ordered as the stock reaches re-order level.';
COMMENT ON COLUMN core.items.maintain_stock IS 'Select "Yes" if you want to maintain the record of transfer (in & out) of stock items.Selecting "Yes" prohibits the user from maintaining negative stock level.';
COMMENT ON COLUMN core.items.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.items.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.late_fee IS 'This table stores information on late fees and other associated information.';
COMMENT ON COLUMN core.late_fee.late_fee_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.late_fee.late_fee_code IS 'Late fee code.';
COMMENT ON COLUMN core.late_fee.late_fee_name IS 'The name given to the late fee code, which is a unique field.';
COMMENT ON COLUMN core.late_fee.is_flat_amount IS 'Select "Yes" if the late fee amount is fixed or vice-versa.';
COMMENT ON COLUMN core.late_fee.rate IS 'The rate on which late fee will be charged.';
COMMENT ON COLUMN core.late_fee.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.late_fee.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE crm.lead_sources IS '';
COMMENT ON COLUMN crm.lead_sources.lead_source_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN crm.lead_sources.lead_source_code IS '';
COMMENT ON COLUMN crm.lead_sources.lead_source_name IS '';
COMMENT ON COLUMN crm.lead_sources.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN crm.lead_sources.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE crm.lead_statuses IS '';
COMMENT ON COLUMN crm.lead_statuses.lead_status_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN crm.lead_statuses.lead_status_code IS '';
COMMENT ON COLUMN crm.lead_statuses.lead_status_name IS '';
COMMENT ON COLUMN crm.lead_statuses.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN crm.lead_statuses.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE policy.lock_outs IS '';
COMMENT ON COLUMN policy.lock_outs.lock_out_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN policy.lock_outs.user_id IS '';
COMMENT ON COLUMN policy.lock_outs.lock_out_time IS '';
COMMENT ON COLUMN policy.lock_outs.lock_out_till IS '';


COMMENT ON TABLE audit.logged_actions IS '';
COMMENT ON COLUMN audit.logged_actions.event_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN audit.logged_actions.schema_name IS '';
COMMENT ON COLUMN audit.logged_actions.table_name IS '';
COMMENT ON COLUMN audit.logged_actions.relid IS '';
COMMENT ON COLUMN audit.logged_actions.session_user_name IS '';
COMMENT ON COLUMN audit.logged_actions.application_user_name IS '';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_tx IS '';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_stm IS '';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_clk IS '';
COMMENT ON COLUMN audit.logged_actions.transaction_id IS '';
COMMENT ON COLUMN audit.logged_actions.application_name IS '';
COMMENT ON COLUMN audit.logged_actions.client_addr IS '';
COMMENT ON COLUMN audit.logged_actions.client_port IS '';
COMMENT ON COLUMN audit.logged_actions.client_query IS '';
COMMENT ON COLUMN audit.logged_actions.action IS '';
COMMENT ON COLUMN audit.logged_actions.row_data IS '';
COMMENT ON COLUMN audit.logged_actions.changed_fields IS '';
COMMENT ON COLUMN audit.logged_actions.statement_only IS '';


COMMENT ON TABLE audit.logins IS '';
COMMENT ON COLUMN audit.logins.login_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN audit.logins.user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN audit.logins.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN audit.logins.browser IS 'The name of the broser used to run the application.';
COMMENT ON COLUMN audit.logins.ip_address IS 'The IP address of the of the computer network used.';
COMMENT ON COLUMN audit.logins.login_date_time IS '';
COMMENT ON COLUMN audit.logins.remote_user IS '';
COMMENT ON COLUMN audit.logins.culture IS '';


COMMENT ON TABLE policy.menu_access IS '';
COMMENT ON COLUMN policy.menu_access.access_id IS 'The primary key of this table.';
COMMENT ON COLUMN policy.menu_access.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN policy.menu_access.menu_id IS 'Foreign key to the table core.menus.';
COMMENT ON COLUMN policy.menu_access.user_id IS 'Foreign key to the table office.users';


COMMENT ON TABLE core.menu_locale IS '';
COMMENT ON COLUMN core.menu_locale.menu_locale_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.menu_locale.menu_id IS '';
COMMENT ON COLUMN core.menu_locale.culture IS '';
COMMENT ON COLUMN core.menu_locale.menu_text IS '';


COMMENT ON TABLE policy.menu_policy IS '';
COMMENT ON COLUMN policy.menu_policy.policy_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN policy.menu_policy.menu_id IS 'Foreign key to the table core.menus.';
COMMENT ON COLUMN policy.menu_policy.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN policy.menu_policy.inherit_in_child_offices IS '';
COMMENT ON COLUMN policy.menu_policy.role_id IS '';
COMMENT ON COLUMN policy.menu_policy.user_id IS '';
COMMENT ON COLUMN policy.menu_policy.scope IS '';


COMMENT ON TABLE core.menus IS 'This table stores information on the easy to use menu of MixERP.';
COMMENT ON COLUMN core.menus.menu_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.menus.menu_text IS 'The name of the menu.';
COMMENT ON COLUMN core.menus.url IS 'The  location of the menu.';
COMMENT ON COLUMN core.menus.menu_code IS 'The code of the menu, which is also a unique field.';
/*COMMENT ON COLUMN core.menus.level IS '';*/
COMMENT ON COLUMN core.menus.parent_menu_id IS 'Foreign key to the table core.menus.';
COMMENT ON COLUMN core.menus.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.menus.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.non_gl_stock_details IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.non_gl_stock_detail_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.non_gl_stock_details.non_gl_stock_master_id IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.value_date IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN transactions.non_gl_stock_details.quantity IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.unit_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN transactions.non_gl_stock_details.base_quantity IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.base_unit_id IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.price IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.discount IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.shipping_charge IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.sales_tax_id IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.tax IS '';
COMMENT ON COLUMN transactions.non_gl_stock_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.non_gl_stock_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.non_gl_stock_master IS 'This table stores information of quotations which were upgraded to order(s).';
COMMENT ON COLUMN transactions.non_gl_stock_master.non_gl_stock_master_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.non_gl_stock_master.value_date IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.book IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.party_id IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.price_type_id IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.transaction_ts IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.login_id IS 'Foreign key to the table audit.logins.';
COMMENT ON COLUMN transactions.non_gl_stock_master.user_id IS 'Foreign key to the table office.users.';
COMMENT ON COLUMN transactions.non_gl_stock_master.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN transactions.non_gl_stock_master.reference_number IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.statement_reference IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.non_taxable IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.salesperson_id IS 'Foreign key to the table core.salespersons.';
COMMENT ON COLUMN transactions.non_gl_stock_master.shipper_id IS 'Foreign key to the table core.shippers.';
COMMENT ON COLUMN transactions.non_gl_stock_master.shipping_address_id IS 'Foreign key to the table core.shipping_addresses.';
COMMENT ON COLUMN transactions.non_gl_stock_master.shipping_charge IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master.store_id IS 'Foreign key to the table office.stores.';
COMMENT ON COLUMN transactions.non_gl_stock_master.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.non_gl_stock_master.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.non_gl_stock_master_relations IS '';
COMMENT ON COLUMN transactions.non_gl_stock_master_relations.non_gl_stock_master_relation_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.non_gl_stock_master_relations.order_non_gl_stock_master_id IS 'Foreign key to the table transactions.non_gl_stock_master.';
COMMENT ON COLUMN transactions.non_gl_stock_master_relations.quotation_non_gl_stock_master_id IS 'Foreign key to the table transactions.non_gl_stock_master.';


COMMENT ON TABLE transactions.non_gl_stock_tax_details IS '';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.non_gl_stock_detail_id IS 'The primary key of this table.';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.sales_tax_detail_id IS 'Foreign key to the table core.state_sales_taxes';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.state_sales_tax_id IS 'Foreign key to the table core.county_sales_taxes.';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.county_sales_tax_id IS 'Foreign key to the table core.county_sales_taxes';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.principal IS '';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.rate IS '';
COMMENT ON COLUMN transactions.non_gl_stock_tax_details.tax IS '';


COMMENT ON TABLE office.offices IS 'This table stores information on various braches of the entity.';
COMMENT ON COLUMN office.offices.office_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.offices.office_code IS 'The code given to the office.';
COMMENT ON COLUMN office.offices.office_name IS 'The name given to the office which is also a unique field.';
COMMENT ON COLUMN office.offices.nick_name IS 'Another name of the office.';
COMMENT ON COLUMN office.offices.registration_date IS 'The date of registration of the office.';
COMMENT ON COLUMN office.offices.currency_code IS 'Foreign key to the table core.currencies.';
COMMENT ON COLUMN office.offices.po_box IS 'The Post Box number of the office.';
COMMENT ON COLUMN office.offices.address_line_1 IS 'The address of the office.';
COMMENT ON COLUMN office.offices.address_line_2 IS 'The address of the office.';
COMMENT ON COLUMN office.offices.street IS 'The name of the street where the office is located.';
COMMENT ON COLUMN office.offices.city IS 'The name of the city where the office is located.';
COMMENT ON COLUMN office.offices.state IS 'The name of the state where the office is located.';
COMMENT ON COLUMN office.offices.zip_code IS 'ZIP code of the office.';
COMMENT ON COLUMN office.offices.country IS 'The name of the county where the office is located.';
COMMENT ON COLUMN office.offices.phone IS 'Phone number of the office.';
COMMENT ON COLUMN office.offices.fax IS 'Fax number of the office.';
COMMENT ON COLUMN office.offices.email IS 'E-mail address of the office.';
COMMENT ON COLUMN office.offices.url IS 'Web address of the office.';
COMMENT ON COLUMN office.offices.registration_number IS 'The registration number of the enntity..';
COMMENT ON COLUMN office.offices.pan_number IS 'Permanent Office Number of the entity.';
COMMENT ON COLUMN office.offices.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.offices.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';
COMMENT ON COLUMN office.offices.parent_office_id IS 'Foreign key to the table office.offices.';


COMMENT ON TABLE crm.opportunity_stages IS '';
COMMENT ON COLUMN crm.opportunity_stages.opportunity_stage_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN crm.opportunity_stages.opportunity_stage_code IS '';
COMMENT ON COLUMN crm.opportunity_stages.opportunity_stage_name IS '';
COMMENT ON COLUMN crm.opportunity_stages.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN crm.opportunity_stages.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.parties IS 'This table stores information on parties and information associated with them.';
COMMENT ON COLUMN core.parties.party_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.parties.party_type_id IS 'Foreign key to the table core.party_types.';
COMMENT ON COLUMN core.parties.party_code IS 'Code given to the party.';
COMMENT ON COLUMN core.parties.first_name IS 'First name of the party.';
COMMENT ON COLUMN core.parties.middle_name IS 'Middle name of the party.';
COMMENT ON COLUMN core.parties.last_name IS 'Family name of the party.';
COMMENT ON COLUMN core.parties.party_name IS 'Full-name of the party.';
COMMENT ON COLUMN core.parties.date_of_birth IS 'Date of birth of the party.';
COMMENT ON COLUMN core.parties.entity_id IS 'Foreign key to the table core.entities.';
COMMENT ON COLUMN core.parties.industry_id IS 'Foreign key to the table core.industries.';
COMMENT ON COLUMN core.parties.country_id IS 'Foreign key to the table core.countries.';
COMMENT ON COLUMN core.parties.state_id IS 'Foreign key to the table core.states.';
COMMENT ON COLUMN core.parties.zip_code IS 'Zip code of the party.';
COMMENT ON COLUMN core.parties.address_line_1 IS 'The address of the party.';
COMMENT ON COLUMN core.parties.address_line_2 IS 'The address of the party.';
COMMENT ON COLUMN core.parties.street IS 'The street name where the party is located.';
COMMENT ON COLUMN core.parties.city IS 'The city name where the party is located.';
COMMENT ON COLUMN core.parties.phone IS 'The phone number of the party.';
COMMENT ON COLUMN core.parties.fax IS 'The fax number of the party.';
COMMENT ON COLUMN core.parties.cell IS 'Cell-phone number of the party.';
COMMENT ON COLUMN core.parties.email IS 'E-mail address of the party.';
COMMENT ON COLUMN core.parties.url IS 'Web address of the party. ';
COMMENT ON COLUMN core.parties.pan_number IS 'Permanent Address Number of the party.';
COMMENT ON COLUMN core.parties.sst_number IS '';
COMMENT ON COLUMN core.parties.cst_number IS '';
COMMENT ON COLUMN core.parties.currency_code IS 'Foreign key to the table core.currencies.';
COMMENT ON COLUMN core.parties.allow_credit IS 'Select "Yes" if you want to allow credit to the party.';
COMMENT ON COLUMN core.parties.maximum_credit_period IS 'Maximum credit period ';
COMMENT ON COLUMN core.parties.maximum_credit_amount IS '';
COMMENT ON COLUMN core.parties.account_id IS 'Foreign key to the table core.accounts.';
COMMENT ON COLUMN core.parties.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.parties.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.party_types IS 'This table stores information on types of parties and other infornation associated with it like weather a party is Agent/Customer/Dealer/Supplier..';
COMMENT ON COLUMN core.party_types.party_type_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.party_types.party_type_code IS 'Code given to the party';
COMMENT ON COLUMN core.party_types.party_type_name IS 'Name of the party which is a unique field.';
COMMENT ON COLUMN core.party_types.is_supplier IS 'Selct "Yes" if the party is supplier or vice-versa.';
COMMENT ON COLUMN core.party_types.account_id IS 'Foreign key to the table core.accounts.When a new party is added, this becomes the parent account.';
COMMENT ON COLUMN core.party_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.party_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.payment_terms IS 'This table stores information on terms of payment like due date, grace period and information associated with it.';
COMMENT ON COLUMN core.payment_terms.payment_term_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.payment_terms.payment_term_code IS 'Code given to the terms of payment.';
COMMENT ON COLUMN core.payment_terms.payment_term_name IS 'The name given to the term of payment, which is also a unique field.';
COMMENT ON COLUMN core.payment_terms.due_on_date IS '';
COMMENT ON COLUMN core.payment_terms.due_days IS '';
COMMENT ON COLUMN core.payment_terms.due_frequency_id IS '';
COMMENT ON COLUMN core.payment_terms.grace_peiod IS '';
COMMENT ON COLUMN core.payment_terms.late_fee_id IS '';
COMMENT ON COLUMN core.payment_terms.late_fee_posting_frequency_id IS '';
COMMENT ON COLUMN core.payment_terms.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.payment_terms.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.price_types IS '';
COMMENT ON COLUMN core.price_types.price_type_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.price_types.price_type_code IS '';
COMMENT ON COLUMN core.price_types.price_type_name IS '';
COMMENT ON COLUMN core.price_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.price_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.recurring_invoice_setup IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.recurring_invoice_setup_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.recurring_invoice_setup.recurring_invoice_id IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.party_id IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.starts_from IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.ends_on IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.recurring_amount IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.payment_term_id IS '';
COMMENT ON COLUMN core.recurring_invoice_setup.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.recurring_invoice_setup.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.recurring_invoices IS '';
COMMENT ON COLUMN core.recurring_invoices.recurring_invoice_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.recurring_invoices.recurring_invoice_code IS '';
COMMENT ON COLUMN core.recurring_invoices.recurring_invoice_name IS '';
COMMENT ON COLUMN core.recurring_invoices.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.recurring_invoices.compound_item_id IS '';
COMMENT ON COLUMN core.recurring_invoices.recurring_frequency_id IS '';
COMMENT ON COLUMN core.recurring_invoices.recurring_amount IS '';
COMMENT ON COLUMN core.recurring_invoices.auto_trigger_on_sales IS '';
COMMENT ON COLUMN core.recurring_invoices.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.recurring_invoices.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.roles IS '';
COMMENT ON COLUMN office.roles.role_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.roles.role_code IS '';
COMMENT ON COLUMN office.roles.role_name IS '';
COMMENT ON COLUMN office.roles.is_admin IS '';
COMMENT ON COLUMN office.roles.is_system IS '';
COMMENT ON COLUMN office.roles.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.roles.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.rounding_methods IS 'This table stores information on rounding off the amount. ';
COMMENT ON COLUMN core.rounding_methods.rounding_method_code IS 'The primary key of this table.';
COMMENT ON COLUMN core.rounding_methods.rounding_method_name IS 'The column that describes this table.';


COMMENT ON TABLE transactions.routines IS '';
COMMENT ON COLUMN transactions.routines.routine_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN transactions.routines.order IS '';
COMMENT ON COLUMN transactions.routines.routine_code IS '';
COMMENT ON COLUMN transactions.routines.routine_name IS '';
COMMENT ON COLUMN transactions.routines.status IS '';


COMMENT ON TABLE core.sales_tax_details IS 'This table stores information on sales tax and other information associated with it.';
COMMENT ON COLUMN core.sales_tax_details.sales_tax_detail_id IS '';
COMMENT ON COLUMN core.sales_tax_details.sales_tax_id IS '';
COMMENT ON COLUMN core.sales_tax_details.sales_tax_type_id IS '';
COMMENT ON COLUMN core.sales_tax_details.priority IS '';
COMMENT ON COLUMN core.sales_tax_details.sales_tax_detail_code IS '';
COMMENT ON COLUMN core.sales_tax_details.sales_tax_detail_name IS '';
COMMENT ON COLUMN core.sales_tax_details.based_on_shipping_address IS '';
COMMENT ON COLUMN core.sales_tax_details.check_nexus IS '';
COMMENT ON COLUMN core.sales_tax_details.applied_on_shipping_charge IS '';
COMMENT ON COLUMN core.sales_tax_details.state_sales_tax_id IS '';
COMMENT ON COLUMN core.sales_tax_details.county_sales_tax_id IS '';
COMMENT ON COLUMN core.sales_tax_details.tax_rate_type_code IS '';
COMMENT ON COLUMN core.sales_tax_details.rate IS '';
COMMENT ON COLUMN core.sales_tax_details.reporting_tax_authority_id IS '';
COMMENT ON COLUMN core.sales_tax_details.collecting_tax_authority_id IS '';
COMMENT ON COLUMN core.sales_tax_details.collecting_account_id IS '';
COMMENT ON COLUMN core.sales_tax_details.use_tax_collecting_account_id IS '';
COMMENT ON COLUMN core.sales_tax_details.rounding_method_code IS '';
COMMENT ON COLUMN core.sales_tax_details.rounding_decimal_places IS '';
COMMENT ON COLUMN core.sales_tax_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_tax_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.sales_tax_exempt_details IS 'This table stores information on sales tax exemption and other information associated with it.';
COMMENT ON COLUMN core.sales_tax_exempt_details.sales_tax_exempt_detail_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.sales_tax_exempt_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.entity_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.industry_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.party_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.party_type_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN core.sales_tax_exempt_details.item_group_id IS '';
COMMENT ON COLUMN core.sales_tax_exempt_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_tax_exempt_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.sales_tax_exempts IS 'This table stores information on sales tax exemption and other information associated with it.';
COMMENT ON COLUMN core.sales_tax_exempts.sales_tax_exempt_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.sales_tax_exempts.tax_master_id IS 'Foreign key to the table core.tax_master.';
COMMENT ON COLUMN core.sales_tax_exempts.sales_tax_exempt_code IS 'Sakes tax exemption code.';
COMMENT ON COLUMN core.sales_tax_exempts.sales_tax_exempt_name IS 'The name given to the sales tax exemption.';
COMMENT ON COLUMN core.sales_tax_exempts.tax_exempt_type_id IS 'Foreign key to the table core.tax_exempt_types.';
COMMENT ON COLUMN core.sales_tax_exempts.store_id IS 'Foreign key to the table office.stores.';
COMMENT ON COLUMN core.sales_tax_exempts.sales_tax_id IS 'Foreign key to the table core.sales_taxes.';
COMMENT ON COLUMN core.sales_tax_exempts.valid_from IS 'The effective date of the sales exemption cstegory.';
COMMENT ON COLUMN core.sales_tax_exempts.valid_till IS 'The last date of the sales exemption category.';
COMMENT ON COLUMN core.sales_tax_exempts.price_from IS 'The minimum sales amount required to fall into the sales exemption category.';
COMMENT ON COLUMN core.sales_tax_exempts.price_to IS 'The maximum sales amount that falls into the sales exemption category.';
COMMENT ON COLUMN core.sales_tax_exempts.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_tax_exempts.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.sales_tax_types IS 'Type of sales tax and information associated with it.';
COMMENT ON COLUMN core.sales_tax_types.sales_tax_type_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.sales_tax_types.sales_tax_type_code IS 'The code given to the sales tax type.';
COMMENT ON COLUMN core.sales_tax_types.sales_tax_type_name IS 'The name given to the type of a sales tax.';
COMMENT ON COLUMN core.sales_tax_types.is_vat IS 'Select "Yes" if the sales tax is VAT.';
COMMENT ON COLUMN core.sales_tax_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_tax_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.sales_taxes IS 'Details on sales tax.';
COMMENT ON COLUMN core.sales_taxes.sales_tax_id IS 'Primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.sales_taxes.tax_master_id IS 'Foreign key to the table core.tax_master.';
COMMENT ON COLUMN core.sales_taxes.office_id IS 'Foreign key to the table office.offices.';
COMMENT ON COLUMN core.sales_taxes.sales_tax_code IS 'The code given to the sales tax.';
COMMENT ON COLUMN core.sales_taxes.sales_tax_name IS 'The name given to the sales tax, which is also a unique field.';
COMMENT ON COLUMN core.sales_taxes.is_exemption IS '';
COMMENT ON COLUMN core.sales_taxes.tax_base_amount_type_code IS 'Foreign key to the table core.tax_base_amount_types.';
COMMENT ON COLUMN core.sales_taxes.rate IS 'Sales tax rate.';
COMMENT ON COLUMN core.sales_taxes.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_taxes.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.sales_teams IS 'Details on sales team.';
COMMENT ON COLUMN core.sales_teams.sales_team_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.sales_teams.sales_team_code IS 'The code given to the sales team.';
COMMENT ON COLUMN core.sales_teams.sales_team_name IS 'The name given to the sales team, which is also a unique field.';
COMMENT ON COLUMN core.sales_teams.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.sales_teams.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.salesperson_bonus_setups IS 'Setup bonuses to salespersons.';
COMMENT ON COLUMN core.salesperson_bonus_setups.salesperson_bonus_setup_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.salesperson_bonus_setups.salesperson_id IS 'The primary key from the table office.users (foreign key to this table).';
COMMENT ON COLUMN core.salesperson_bonus_setups.bonus_slab_id IS 'A unique numeric value assigned to the bonus slab';
COMMENT ON COLUMN core.salesperson_bonus_setups.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.salesperson_bonus_setups.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.salespersons IS 'Details on sales person and other information associated with it.';
COMMENT ON COLUMN core.salespersons.salesperson_id IS 'The primay key of the table.';
COMMENT ON COLUMN core.salespersons.sales_team_id IS 'The id given to the sales person.';
COMMENT ON COLUMN core.salespersons.salesperson_code IS 'The code given to the sales person.';
COMMENT ON COLUMN core.salespersons.salesperson_name IS 'The name of the sales person, which is also a unique field.';
COMMENT ON COLUMN core.salespersons.address IS 'The address of the sales person.';
COMMENT ON COLUMN core.salespersons.contact_number IS 'The contact number of the sales person.';
COMMENT ON COLUMN core.salespersons.commission_rate IS 'The rate of comission assigned to the sales person.';
COMMENT ON COLUMN core.salespersons.account_id IS 'Foreign key to the table core.accounts.';
COMMENT ON COLUMN core.salespersons.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.salespersons.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.shippers IS 'Details on shippers (shipping company) and other information associated with it.';
COMMENT ON COLUMN core.shippers.shipper_id IS 'The primary key of the table, which is also a bigserial field.';
COMMENT ON COLUMN core.shippers.shipper_code IS 'The code of the shipper.';
COMMENT ON COLUMN core.shippers.company_name IS 'Tha name of the shipping company. ';
COMMENT ON COLUMN core.shippers.shipper_name IS 'The name of the shipper.';
COMMENT ON COLUMN core.shippers.po_box IS 'The P.O Box number of the shipper.';
COMMENT ON COLUMN core.shippers.address_line_1 IS 'Address 1.';
COMMENT ON COLUMN core.shippers.address_line_2 IS 'Address 2.';
COMMENT ON COLUMN core.shippers.street IS 'The street name where the shipper operates.';
COMMENT ON COLUMN core.shippers.city IS 'The city name of the city where the shipper operates.';
COMMENT ON COLUMN core.shippers.state IS 'The name of the state where the shipper operates.';
COMMENT ON COLUMN core.shippers.country IS 'The name of the county where the shipper operates.';
COMMENT ON COLUMN core.shippers.phone IS 'The phone number of the shipper.';
COMMENT ON COLUMN core.shippers.fax IS 'The fax number of the shipper.';
COMMENT ON COLUMN core.shippers.cell IS 'The cell number of the shipper.';
COMMENT ON COLUMN core.shippers.email IS 'The e-mail address of the shipper.';
COMMENT ON COLUMN core.shippers.url IS 'The web address of the shipper.';
COMMENT ON COLUMN core.shippers.contact_person IS 'The contact person or agent of the shipping company.';
COMMENT ON COLUMN core.shippers.contact_po_box IS 'The P.O. Box number of the agent.';
COMMENT ON COLUMN core.shippers.contact_address_line_1 IS 'Address 1 of the shipping agent.';
COMMENT ON COLUMN core.shippers.contact_address_line_2 IS 'Address 2 of the shipping agent.';
COMMENT ON COLUMN core.shippers.contact_street IS 'The street name where the shipping agent resides.';
COMMENT ON COLUMN core.shippers.contact_city IS 'THe city name where the shipping agent resides.';
COMMENT ON COLUMN core.shippers.contact_state IS '';
COMMENT ON COLUMN core.shippers.contact_country IS '';
COMMENT ON COLUMN core.shippers.contact_email IS '';
COMMENT ON COLUMN core.shippers.contact_phone IS '';
COMMENT ON COLUMN core.shippers.contact_cell IS '';
COMMENT ON COLUMN core.shippers.factory_address IS '';
COMMENT ON COLUMN core.shippers.pan_number IS '';
COMMENT ON COLUMN core.shippers.sst_number IS '';
COMMENT ON COLUMN core.shippers.cst_number IS '';
COMMENT ON COLUMN core.shippers.account_id IS 'Foreign key to the table core.accounts.';
COMMENT ON COLUMN core.shippers.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.shippers.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.shipping_addresses IS 'Details on shipping address and other information associated with it.';
COMMENT ON COLUMN core.shipping_addresses.shipping_address_id IS '';
COMMENT ON COLUMN core.shipping_addresses.shipping_address_code IS '';
COMMENT ON COLUMN core.shipping_addresses.party_id IS '';
COMMENT ON COLUMN core.shipping_addresses.country_id IS '';
COMMENT ON COLUMN core.shipping_addresses.state_id IS '';
COMMENT ON COLUMN core.shipping_addresses.zip_code IS '';
COMMENT ON COLUMN core.shipping_addresses.address_line_1 IS '';
COMMENT ON COLUMN core.shipping_addresses.address_line_2 IS '';
COMMENT ON COLUMN core.shipping_addresses.street IS '';
COMMENT ON COLUMN core.shipping_addresses.city IS '';
COMMENT ON COLUMN core.shipping_addresses.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.shipping_addresses.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.shipping_mail_types IS 'Details on shipping mail type (Express, priority mail, parcel post etc.).';
COMMENT ON COLUMN core.shipping_mail_types.shipping_mail_type_id IS 'The primary key of the table.';
COMMENT ON COLUMN core.shipping_mail_types.shipping_mail_type_code IS 'The id of the shipping mail type.';
COMMENT ON COLUMN core.shipping_mail_types.shipping_mail_type_name IS 'The name given to the shipping mail type, which is also a unique field.';
COMMENT ON COLUMN core.shipping_mail_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.shipping_mail_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.shipping_package_shapes IS 'Details on shipping package and other information assiciated with it.';
COMMENT ON COLUMN core.shipping_package_shapes.shipping_package_shape_id IS 'Primary key of the table.';
COMMENT ON COLUMN core.shipping_package_shapes.shipping_package_shape_code IS 'Code given to the shipping package shape.';
COMMENT ON COLUMN core.shipping_package_shapes.shipping_package_shape_name IS 'Name given to the shipping package shape, which is a unique field.';
COMMENT ON COLUMN core.shipping_package_shapes.is_rectangular IS 'Select "t" if the shape of the package is rectangular or vice-versa.';
COMMENT ON COLUMN core.shipping_package_shapes.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.shipping_package_shapes.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.state_sales_taxes IS 'Details on sales tax of the state in the U.S.A and other information associated with it.';
COMMENT ON COLUMN core.state_sales_taxes.state_sales_tax_id IS 'The primary key of the table.';
COMMENT ON COLUMN core.state_sales_taxes.state_sales_tax_code IS 'The code given to the state sales tax.';
COMMENT ON COLUMN core.state_sales_taxes.state_sales_tax_name IS 'The  name of the sales tax, which is also a unique field.';
COMMENT ON COLUMN core.state_sales_taxes.state_id IS 'Foreign key to the table core.states.';
COMMENT ON COLUMN core.state_sales_taxes.entity_id IS 'Foreign key to the table core.entities.';
COMMENT ON COLUMN core.state_sales_taxes.industry_id IS 'Foreign key to the table core.industries.';
COMMENT ON COLUMN core.state_sales_taxes.item_group_id IS 'Foreign key to the table core.item_groups.';
COMMENT ON COLUMN core.state_sales_taxes.rate IS 'Tax rate of the state.';
COMMENT ON COLUMN core.state_sales_taxes.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.state_sales_taxes.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.states IS 'Information on the states of the U.S.A.';
COMMENT ON COLUMN core.states.state_id IS 'Primary key of the table.';
COMMENT ON COLUMN core.states.country_id IS 'Foreign key to the table core.states.';
COMMENT ON COLUMN core.states.state_code IS 'The code word given to the state name.';
COMMENT ON COLUMN core.states.state_name IS 'Tha name of the states in the U.S.A, which is a unique field.';
COMMENT ON COLUMN core.states.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.states.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.stock_details IS '';
COMMENT ON COLUMN transactions.stock_details.stock_detail_id IS '';
COMMENT ON COLUMN transactions.stock_details.value_date IS '';
COMMENT ON COLUMN transactions.stock_details.stock_master_id IS '';
COMMENT ON COLUMN transactions.stock_details.tran_type IS '';
COMMENT ON COLUMN transactions.stock_details.store_id IS '';
COMMENT ON COLUMN transactions.stock_details.item_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN transactions.stock_details.quantity IS '';
COMMENT ON COLUMN transactions.stock_details.unit_id IS 'Foreign key to the table core.items.';
COMMENT ON COLUMN transactions.stock_details.base_quantity IS '';
COMMENT ON COLUMN transactions.stock_details.base_unit_id IS '';
COMMENT ON COLUMN transactions.stock_details.price IS '';
COMMENT ON COLUMN transactions.stock_details.cost_of_goods_sold IS '';
COMMENT ON COLUMN transactions.stock_details.discount IS '';
COMMENT ON COLUMN transactions.stock_details.shipping_charge IS '';
COMMENT ON COLUMN transactions.stock_details.sales_tax_id IS '';
COMMENT ON COLUMN transactions.stock_details.tax IS '';
COMMENT ON COLUMN transactions.stock_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.stock_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.stock_master IS '';
COMMENT ON COLUMN transactions.stock_master.stock_master_id IS '';
COMMENT ON COLUMN transactions.stock_master.transaction_master_id IS '';
COMMENT ON COLUMN transactions.stock_master.value_date IS '';
COMMENT ON COLUMN transactions.stock_master.party_id IS '';
COMMENT ON COLUMN transactions.stock_master.salesperson_id IS '';
COMMENT ON COLUMN transactions.stock_master.price_type_id IS '';
COMMENT ON COLUMN transactions.stock_master.is_credit IS '';
COMMENT ON COLUMN transactions.stock_master.payment_term_id IS '';
COMMENT ON COLUMN transactions.stock_master.shipper_id IS '';
COMMENT ON COLUMN transactions.stock_master.shipping_address_id IS '';
COMMENT ON COLUMN transactions.stock_master.shipping_charge IS '';
COMMENT ON COLUMN transactions.stock_master.store_id IS '';
COMMENT ON COLUMN transactions.stock_master.non_taxable IS '';
COMMENT ON COLUMN transactions.stock_master.cash_repository_id IS '';
COMMENT ON COLUMN transactions.stock_master.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.stock_master.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.stock_master_non_gl_relations IS 'This table stores information of Non GL Stock Transactions such as orders and quotations
which were upgraded to deliveries or invoices.';
COMMENT ON COLUMN transactions.stock_master_non_gl_relations.stock_master_non_gl_relation_id IS '';
COMMENT ON COLUMN transactions.stock_master_non_gl_relations.stock_master_id IS '';
COMMENT ON COLUMN transactions.stock_master_non_gl_relations.non_gl_stock_master_id IS '';


COMMENT ON TABLE transactions.stock_return IS '';
COMMENT ON COLUMN transactions.stock_return.sales_return_id IS '';
COMMENT ON COLUMN transactions.stock_return.transaction_master_id IS '';
COMMENT ON COLUMN transactions.stock_return.return_transaction_master_id IS '';


COMMENT ON TABLE transactions.stock_tax_details IS '';
COMMENT ON COLUMN transactions.stock_tax_details.stock_detail_id IS '';
COMMENT ON COLUMN transactions.stock_tax_details.sales_tax_detail_id IS '';
COMMENT ON COLUMN transactions.stock_tax_details.state_sales_tax_id IS '';
COMMENT ON COLUMN transactions.stock_tax_details.county_sales_tax_id IS '';
COMMENT ON COLUMN transactions.stock_tax_details.principal IS '';
COMMENT ON COLUMN transactions.stock_tax_details.rate IS '';
COMMENT ON COLUMN transactions.stock_tax_details.tax IS '';


COMMENT ON TABLE policy.store_policies IS 'STORE POLICY DEFINES THE RIGHT OF USERS TO ACCESS A STORE.
    AN ADMINISTRATOR CAN ACCESS ALL THE stores, BY DEFAULT.';
COMMENT ON COLUMN policy.store_policies.store_policy_id IS '';
COMMENT ON COLUMN policy.store_policies.written_by_user_id IS '';
COMMENT ON COLUMN policy.store_policies.status IS '';
COMMENT ON COLUMN policy.store_policies.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN policy.store_policies.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE policy.store_policy_details IS '';
COMMENT ON COLUMN policy.store_policy_details.store_policy_detail_id IS '';
COMMENT ON COLUMN policy.store_policy_details.store_policy_id IS '';
COMMENT ON COLUMN policy.store_policy_details.user_id IS '';
COMMENT ON COLUMN policy.store_policy_details.store_id IS '';
COMMENT ON COLUMN policy.store_policy_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN policy.store_policy_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.store_types IS '';
COMMENT ON COLUMN office.store_types.store_type_id IS '';
COMMENT ON COLUMN office.store_types.store_type_code IS '';
COMMENT ON COLUMN office.store_types.store_type_name IS '';
COMMENT ON COLUMN office.store_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.store_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.stores IS '';
COMMENT ON COLUMN office.stores.store_id IS '';
COMMENT ON COLUMN office.stores.office_id IS '';
COMMENT ON COLUMN office.stores.store_code IS '';
COMMENT ON COLUMN office.stores.store_name IS '';
COMMENT ON COLUMN office.stores.address IS '';
COMMENT ON COLUMN office.stores.store_type_id IS '';
COMMENT ON COLUMN office.stores.allow_sales IS '';
COMMENT ON COLUMN office.stores.sales_tax_id IS '';
COMMENT ON COLUMN office.stores.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.stores.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.tax_authorities IS 'Details on tax authorities, its address and other information associated with it.';
COMMENT ON COLUMN core.tax_authorities.tax_authority_id IS 'The primary key of the table.';
COMMENT ON COLUMN core.tax_authorities.tax_master_id IS 'Foreign key to the table core.tax_master.';
COMMENT ON COLUMN core.tax_authorities.tax_authority_code IS 'The code given to the tax authority.';
COMMENT ON COLUMN core.tax_authorities.tax_authority_name IS 'The name of the tax authority, which is a unique field.';
COMMENT ON COLUMN core.tax_authorities.country_id IS 'Foreign key to the table core.countries.';
COMMENT ON COLUMN core.tax_authorities.state_id IS 'Foreign key to the table core.states.';
COMMENT ON COLUMN core.tax_authorities.zip_code IS 'ZIP code of the tax office.';
COMMENT ON COLUMN core.tax_authorities.address_line_1 IS 'Address 1.';
COMMENT ON COLUMN core.tax_authorities.address_line_2 IS 'Address 2.';
COMMENT ON COLUMN core.tax_authorities.street IS 'Street address.';
COMMENT ON COLUMN core.tax_authorities.city IS'Name of the city.';
COMMENT ON COLUMN core.tax_authorities.phone IS 'Phone number of the tax office.';
COMMENT ON COLUMN core.tax_authorities.fax IS 'Fax number of the tax office.';
COMMENT ON COLUMN core.tax_authorities.cell IS 'Cell phone number of the tax office.';
COMMENT ON COLUMN core.tax_authorities.email IS 'E-mail address of the tax office.';
COMMENT ON COLUMN core.tax_authorities.url IS 'Web address of the tax office.';
COMMENT ON COLUMN core.tax_authorities.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.tax_authorities.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.tax_base_amount_types IS 'Information on various tax base that are applicable.';
COMMENT ON COLUMN core.tax_base_amount_types.tax_base_amount_type_code IS 'The code of the tax base.';
COMMENT ON COLUMN core.tax_base_amount_types.tax_base_amount_type_name IS 'The name given to the tax base, which is also a unique field.';


COMMENT ON TABLE core.tax_exempt_types IS 'Various kinds of tax exemptions that are applicable.';
COMMENT ON COLUMN core.tax_exempt_types.tax_exempt_type_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.tax_exempt_types.tax_exempt_type_code IS 'The code given to the tax exemption type.';
COMMENT ON COLUMN core.tax_exempt_types.tax_exempt_type_name IS 'The name given to the tax exemption type, which is also a unique field.';
COMMENT ON COLUMN core.tax_exempt_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.tax_exempt_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.tax_master IS 'Information on the applicable tax rates of various countries (tax master)supported by the software. ';
COMMENT ON COLUMN core.tax_master.tax_master_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN core.tax_master.tax_master_code IS 'The code of the code master.';
COMMENT ON COLUMN core.tax_master.tax_master_name IS 'The name of the tax master.';
COMMENT ON COLUMN core.tax_master.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.tax_master.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.tax_rate_types IS 'The code and the name given to various types tax rates (flat rate or percentage basis).';
COMMENT ON COLUMN core.tax_rate_types.tax_rate_type_code IS 'The primary key of the table.';
COMMENT ON COLUMN core.tax_rate_types.tax_rate_type_name IS 'The name given to the tax-rate type, which is also a unique field.';


COMMENT ON TABLE transactions.transaction_details IS '';
COMMENT ON COLUMN transactions.transaction_details.transaction_detail_id IS '';
COMMENT ON COLUMN transactions.transaction_details.transaction_master_id IS '';
COMMENT ON COLUMN transactions.transaction_details.value_date IS '';
COMMENT ON COLUMN transactions.transaction_details.tran_type IS '';
COMMENT ON COLUMN transactions.transaction_details.account_id IS 'Foreign key to the table core.accounts.';
COMMENT ON COLUMN transactions.transaction_details.statement_reference IS '';
COMMENT ON COLUMN transactions.transaction_details.cash_repository_id IS '';
COMMENT ON COLUMN transactions.transaction_details.currency_code IS 'Foreign key to the table core.currencies.';
COMMENT ON COLUMN transactions.transaction_details.amount_in_currency IS '';
COMMENT ON COLUMN transactions.transaction_details.local_currency_code IS '';
COMMENT ON COLUMN transactions.transaction_details.er IS '';
COMMENT ON COLUMN transactions.transaction_details.amount_in_local_currency IS '';
COMMENT ON COLUMN transactions.transaction_details.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.transaction_details.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE transactions.transaction_master IS '';
COMMENT ON COLUMN transactions.transaction_master.transaction_master_id IS '';
COMMENT ON COLUMN transactions.transaction_master.transaction_counter IS '';
COMMENT ON COLUMN transactions.transaction_master.transaction_code IS '';
COMMENT ON COLUMN transactions.transaction_master.book IS '';
COMMENT ON COLUMN transactions.transaction_master.value_date IS '';
COMMENT ON COLUMN transactions.transaction_master.transaction_ts IS '';
COMMENT ON COLUMN transactions.transaction_master.login_id IS '';
COMMENT ON COLUMN transactions.transaction_master.user_id IS '';
COMMENT ON COLUMN transactions.transaction_master.sys_user_id IS '';
COMMENT ON COLUMN transactions.transaction_master.office_id IS '';
COMMENT ON COLUMN transactions.transaction_master.cost_center_id IS '';
COMMENT ON COLUMN transactions.transaction_master.reference_number IS '';
COMMENT ON COLUMN transactions.transaction_master.statement_reference IS '';
COMMENT ON COLUMN transactions.transaction_master.last_verified_on IS '';
COMMENT ON COLUMN transactions.transaction_master.verified_by_user_id IS '';
COMMENT ON COLUMN transactions.transaction_master.verification_status_id IS '';
COMMENT ON COLUMN transactions.transaction_master.verification_reason IS '';
COMMENT ON COLUMN transactions.transaction_master.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN transactions.transaction_master.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.units IS 'Contains units of measure.';
COMMENT ON COLUMN core.units.unit_id IS 'The primary key of this table, which is also a serial column.';
COMMENT ON COLUMN core.units.unit_code IS 'The case insensitive unique code which denotes the unit name.';
COMMENT ON COLUMN core.units.unit_name IS 'The case insensitive unique column which denotes the unit of measure.';
COMMENT ON COLUMN core.units.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.units.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.users IS 'The users table contains users accounts and their login information. It also contains a sys user account which does not have a password.
The sys user account is a special account used by the MixERP workflow to perform routine tasks. The sys user cannot have a valid password
or cannot be allowed to log in interactively.';
COMMENT ON COLUMN office.users.user_id IS 'The primary key of the table, which is also a serial field.';
COMMENT ON COLUMN office.users.role_id IS '';
COMMENT ON COLUMN office.users.office_id IS '';
COMMENT ON COLUMN office.users.user_name IS '';
COMMENT ON COLUMN office.users.full_name IS '';
COMMENT ON COLUMN office.users.password IS '';
COMMENT ON COLUMN office.users.elevated IS '';
COMMENT ON COLUMN office.users.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.users.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.verification_statuses IS 'Verification statuses are integer values used to represent the state of a transaction.
For example, a verification status of value "0" would mean that the transaction has not yet been verified.
A negative value indicates that the transaction was rejected, whereas a positive value means approved.

Remember:
1. Only approved transactions appear on ledgers and final reports.
2. Cash repository balance is maintained on the basis of LIFO principle. 

   This means that cash balance is affected (reduced) on your repository as soon as a credit transaction is posted,
   without the transaction being approved on the first place. If you reject the transaction, the cash balance then increases.
   This also means that the cash balance is not affected (increased) on your repository as soon as a debit transaction is posted.
   You will need to approve the transaction.

   It should however be noted that the cash repository balance might be less than the total cash shown on your balance sheet,
   if you have pending transactions to verify. You cannot perform EOD operation if you have pending verifications.';
COMMENT ON COLUMN core.verification_statuses.verification_status_id IS 'The primary key of this table.';
COMMENT ON COLUMN core.verification_statuses.verification_status_name IS 'The name of verification status, which is a unique field.';


COMMENT ON TABLE policy.voucher_verification_policy IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.user_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN policy.voucher_verification_policy.can_verify_sales_transactions IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.sales_verification_limit IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.can_verify_purchase_transactions IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.purchase_verification_limit IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.can_verify_gl_transactions IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.gl_verification_limit IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.can_self_verify IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.self_verification_limit IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.effective_from IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.ends_on IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.is_active IS '';
COMMENT ON COLUMN policy.voucher_verification_policy.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN policy.voucher_verification_policy.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE office.work_centers IS '';
COMMENT ON COLUMN office.work_centers.work_center_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN office.work_centers.office_id IS '';
COMMENT ON COLUMN office.work_centers.work_center_code IS '';
COMMENT ON COLUMN office.work_centers.work_center_name IS '';
COMMENT ON COLUMN office.work_centers.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN office.work_centers.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.zip_code_types IS 'Types of ZIP code.';
COMMENT ON COLUMN core.zip_code_types.zip_code_type_id IS 'The primary key of this table, which is also a serial field.';
COMMENT ON COLUMN core.zip_code_types.type IS 'The type of ZIP code, which is also a unique field.';
COMMENT ON COLUMN core.zip_code_types.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.zip_code_types.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';


COMMENT ON TABLE core.zip_codes IS 'This table stores information on the ZIP code.';
COMMENT ON COLUMN core.zip_codes.zip_code_id IS 'The primary key of this table, which is also a bigserial field.';
COMMENT ON COLUMN core.zip_codes.state_id IS 'Foreign key to the table core.states';
COMMENT ON COLUMN core.zip_codes.code IS 'ZIP code of the area.';
COMMENT ON COLUMN core.zip_codes.zip_code_type_id IS 'Foreign key to the table core.zip_code_types.';
COMMENT ON COLUMN core.zip_codes.city IS 'Name of the city,';
COMMENT ON COLUMN core.zip_codes.lat IS 'Latitude of the area.';
COMMENT ON COLUMN core.zip_codes.lon IS 'Longitude of the area.';
COMMENT ON COLUMN core.zip_codes.x_axis IS 'X-axis of the ZIP code.';
COMMENT ON COLUMN core.zip_codes.y_axis IS 'Y-axis of the ZIP code. ';
COMMENT ON COLUMN core.zip_codes.z_axis IS 'Z-axis of the ZIP code.';
COMMENT ON COLUMN core.zip_codes.audit_user_id IS 'Contains the id of the user who last inserted or updated the corresponding row.';
COMMENT ON COLUMN core.zip_codes.audit_ts IS 'Contains the date and timestamp of the last insert or update action.';




-->-->-- C:/Users/nirvan/Desktop/mixerp/0. GitHub/src/FrontEnd/MixERP.Net.FrontEnd/db/1.x/1.1/src/refresh-materialized-views.sql --<--<--
SELECT * FROM transactions.refresh_materialized_views(1);
